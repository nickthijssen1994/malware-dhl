package com.p051jd.lib.unification.video.editor;

import com.coremedia.iso.boxes.Container;
import com.googlecode.mp4parser.authoring.Movie;
import com.googlecode.mp4parser.authoring.Track;
import com.googlecode.mp4parser.authoring.builder.DefaultMp4Builder;
import com.googlecode.mp4parser.authoring.container.mp4.MovieCreator;
import com.googlecode.mp4parser.authoring.tracks.CroppedTrack;
import java.io.File;
import java.io.FileOutputStream;
import java.nio.channels.FileChannel;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/* compiled from: TbsSdkJava */
/* renamed from: com.jd.lib.unification.video.editor.VideoClip */
/* loaded from: classes.dex */
public class VideoClip {
    private static final String TAG = "VideoClip";

    /* compiled from: TbsSdkJava */
    /* renamed from: com.jd.lib.unification.video.editor.VideoClip$ClipFinishListener */
    /* loaded from: classes.dex */
    interface ClipFinishListener {
        void onClipFailed(String str);

        void onClipSuccess(String str);
    }

    public void clip(String str, String str2, String str3, double d, double d2, ClipFinishListener clipFinishListener) {
        try {
            Movie build = MovieCreator.build(str);
            List<Track> tracks = build.getTracks();
            build.setTracks(new LinkedList());
            double d3 = d;
            double d4 = d2;
            boolean z = false;
            for (Track track : tracks) {
                if (track.getSyncSamples() != null && track.getSyncSamples().length > 0) {
                    if (!z) {
                        double correctTimeToSyncSample = correctTimeToSyncSample(track, d3, false);
                        d4 = correctTimeToSyncSample(track, d4, true);
                        d3 = correctTimeToSyncSample;
                        z = true;
                    } else {
                        throw new RuntimeException("The startTime has already been corrected by another track with SyncSample. Not Supported.");
                    }
                }
            }
            for (Track track2 : tracks) {
                double d5 = 0.0d;
                double d6 = 0.0d;
                long j = 0;
                long j2 = -1;
                long j3 = -1;
                int i = 0;
                while (i < track2.getSampleDurations().length) {
                    long j4 = track2.getSampleDurations()[i];
                    if (d5 > d6 && d5 <= d3) {
                        j2 = j;
                    }
                    if (d5 > d6 && d5 <= d4) {
                        j3 = j;
                    }
                    double d7 = (double) j4;
                    double timescale = (double) track2.getTrackMetaData().getTimescale();
                    Double.isNaN(d7);
                    Double.isNaN(timescale);
                    d5 += d7 / timescale;
                    j++;
                    i++;
                    d3 = d3;
                    d6 = d5;
                }
                if (j2 == -1) {
                    j2 = 0;
                }
                build.addTrack(new CroppedTrack(track2, j2, j3));
                d3 = d3;
            }
            Container build2 = new DefaultMp4Builder().build(build);
            File file = new File(str2);
            file.mkdirs();
            FileOutputStream fileOutputStream = new FileOutputStream(new File(file, str3));
            FileChannel channel = fileOutputStream.getChannel();
            build2.writeContainer(channel);
            channel.close();
            fileOutputStream.close();
            clipFinishListener.onClipSuccess(str2 + str3);
        } catch (Exception unused) {
            clipFinishListener.onClipFailed(str2 + str3);
        }
    }

    private double correctTimeToSyncSample(Track track, double d, boolean z) {
        double[] dArr = new double[track.getSyncSamples().length];
        int i = 0;
        double d2 = 0.0d;
        long j = 0;
        double d3 = 0.0d;
        for (int i2 = 0; i2 < track.getSampleDurations().length; i2++) {
            long j2 = track.getSampleDurations()[i2];
            j++;
            if (Arrays.binarySearch(track.getSyncSamples(), j) >= 0) {
                dArr[Arrays.binarySearch(track.getSyncSamples(), j)] = d3;
            }
            double d4 = (double) j2;
            double timescale = (double) track.getTrackMetaData().getTimescale();
            Double.isNaN(d4);
            Double.isNaN(timescale);
            d3 += d4 / timescale;
        }
        int length = dArr.length;
        while (i < length) {
            double d5 = dArr[i];
            if (d5 > d) {
                return z ? d5 : d2;
            }
            i++;
            d2 = d5;
        }
        return dArr[dArr.length - 1];
    }
}
