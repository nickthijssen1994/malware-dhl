package com.p051jd.lib.unification.album.task;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.RectF;
import android.os.AsyncTask;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.p051jd.lib.unification.album.mInterface.BitmapCropCallback;
import com.p051jd.lib.unification.album.view.CropOverlayView;
import java.io.IOException;

/* compiled from: TbsSdkJava */
/* renamed from: com.jd.lib.unification.album.task.BitmapCropTask */
/* loaded from: classes.dex */
public class BitmapCropTask extends AsyncTask<Void, Void, Throwable> {
    private static final String TAG = "BitmapCropTask";
    private int cropOffsetX;
    private int cropOffsetY;
    private CropOverlayView.CropShape cropShape;
    private final BitmapCropCallback mCropCallback;
    private final RectF mCropRect;
    private int mCroppedImageHeight;
    private int mCroppedImageWidth;
    private final RectF mCurrentImageRect;
    private float mCurrentScale;
    private Bitmap mResultBitmap;
    private Bitmap mViewBitmap;

    public BitmapCropTask(@Nullable Bitmap bitmap, @NonNull RectF rectF, RectF rectF2, float f, CropOverlayView.CropShape cropShape, @Nullable BitmapCropCallback bitmapCropCallback) {
        this.mViewBitmap = bitmap;
        this.mCropRect = rectF;
        this.mCurrentImageRect = rectF2;
        this.mCurrentScale = f;
        this.cropShape = cropShape;
        this.mCropCallback = bitmapCropCallback;
    }

    /* JADX INFO: Access modifiers changed from: protected */
    @Nullable
    public Throwable doInBackground(Void... voidArr) {
        Log.d(TAG, "doInBackground... ");
        Bitmap bitmap = this.mViewBitmap;
        if (bitmap == null) {
            return new NullPointerException("ViewBitmap is null");
        }
        if (bitmap.isRecycled()) {
            return new NullPointerException("ViewBitmap is recycled");
        }
        if (this.mCurrentImageRect.isEmpty()) {
            return new NullPointerException("CurrentImageRect is empty");
        }
        try {
            crop();
            this.mViewBitmap = null;
            return null;
        } catch (Throwable th) {
            th.printStackTrace();
            return th;
        }
    }

    private Bitmap crop() throws IOException {
        this.cropOffsetX = Math.round((this.mCropRect.left - this.mCurrentImageRect.left) / this.mCurrentScale);
        this.cropOffsetY = Math.round((this.mCropRect.top - this.mCurrentImageRect.top) / this.mCurrentScale);
        this.mCroppedImageWidth = Math.round(this.mCropRect.width() / this.mCurrentScale);
        this.mCroppedImageHeight = Math.round(this.mCropRect.height() / this.mCurrentScale);
        if (this.cropOffsetX < 0) {
            this.cropOffsetX = 0;
        }
        if (this.cropOffsetY < 0) {
            this.cropOffsetY = 0;
        }
        if (this.mViewBitmap.getWidth() < this.mCroppedImageWidth + this.cropOffsetX || this.mViewBitmap.getHeight() < this.mCroppedImageHeight + this.cropOffsetY) {
            int i = this.mCroppedImageWidth;
            int i2 = this.mCroppedImageHeight;
            int min = Math.min(this.mViewBitmap.getWidth(), this.mViewBitmap.getHeight());
            this.mCroppedImageHeight = min;
            this.mCroppedImageWidth = min;
            if (this.mViewBitmap.getWidth() > this.mViewBitmap.getHeight()) {
                this.cropOffsetX += (i - this.mCroppedImageWidth) / 2;
                this.cropOffsetY = 0;
            } else {
                this.cropOffsetX = 0;
                this.cropOffsetY += (i2 - this.mCroppedImageHeight) / 2;
            }
        }
        Log.d(TAG, "cropShape:" + this.cropShape + " cropOffsetX:" + this.cropOffsetX + " cropOffsetY:" + this.cropOffsetY + " mCroppedImageWidth:" + this.mCroppedImageWidth + " mCroppedImageHeight:" + this.mCroppedImageHeight + " bitmapWidth:" + this.mViewBitmap.getWidth() + " bitmapHeight:" + this.mViewBitmap.getHeight());
        Bitmap createBitmap = Bitmap.createBitmap(this.mViewBitmap, this.cropOffsetX, this.cropOffsetY, this.mCroppedImageWidth, this.mCroppedImageHeight);
        if (this.cropShape == CropOverlayView.CropShape.CIRCLE) {
            this.mResultBitmap = getCirleBitmap(createBitmap);
        } else {
            this.mResultBitmap = createBitmap;
        }
        return this.mResultBitmap;
    }

    public static Bitmap getCirleBitmap(Bitmap bitmap) {
        int width = bitmap.getWidth();
        int height = bitmap.getHeight();
        Bitmap createBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(createBitmap);
        Paint paint = new Paint();
        paint.setAntiAlias(true);
        canvas.drawOval(new RectF(0.0f, 0.0f, (float) width, (float) height), paint);
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
        canvas.drawBitmap(bitmap, 0.0f, 0.0f, paint);
        if (bitmap != null && !bitmap.isRecycled()) {
            bitmap.recycle();
        }
        return createBitmap;
    }

    /* JADX INFO: Access modifiers changed from: protected */
    public void onPostExecute(@Nullable Throwable th) {
        BitmapCropCallback bitmapCropCallback = this.mCropCallback;
        if (bitmapCropCallback == null) {
            return;
        }
        if (th == null) {
            bitmapCropCallback.onBitmapCropped(this.mResultBitmap);
        } else {
            bitmapCropCallback.onCropFailure(th);
        }
    }
}
