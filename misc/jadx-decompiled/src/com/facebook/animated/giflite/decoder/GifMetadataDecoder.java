package com.facebook.animated.giflite.decoder;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;

/* loaded from: classes.dex */
public class GifMetadataDecoder {
    private static final int CONTROL_INDEX_DELAY = 1;
    private static final int CONTROL_INDEX_DISPOSE = 0;
    private static final int DEFAULT_FRAME_DURATION_MS = 100;
    private static final int MAX_BLOCK_SIZE = 256;
    private static final char[] NETSCAPE = {'N', 'E', 'T', 'S', 'C', 'A', 'P', 'E', '2', '.', '0'};
    private final InputStream mInputStream;
    @Nullable
    private final OutputStream mOutputStream;
    private boolean shouldFixStream;
    private final byte[] block = new byte[MAX_BLOCK_SIZE];
    private final List<int[]> mFrameControls = new ArrayList();
    private int mLoopCount = 1;
    private boolean mDecoded = false;
    private int mCurrentOffset = 0;

    private GifMetadataDecoder(InputStream inputStream, @Nullable OutputStream outputStream) {
        this.mInputStream = inputStream;
        this.mOutputStream = outputStream;
    }

    private void addFrame(int[] iArr) {
        this.mFrameControls.add(Arrays.copyOf(iArr, iArr.length));
    }

    private void copyFromIsToOs(InputStream inputStream, OutputStream outputStream, int i) {
        while (i > 0) {
            int read = inputStream.read(this.block, 0, Math.min((int) MAX_BLOCK_SIZE, i));
            i -= 256;
            outputStream.write(this.block, 0, read);
        }
    }

    public static GifMetadataDecoder create(InputStream inputStream, @Nullable OutputStream outputStream) {
        GifMetadataDecoder gifMetadataDecoder = new GifMetadataDecoder(inputStream, outputStream);
        gifMetadataDecoder.decode();
        return gifMetadataDecoder;
    }

    private void ignoreColorTable(int i) {
        skipAndWriteBytes(i * 3);
    }

    private void initFixedOutputStream() {
        if (!this.shouldFixStream && this.mOutputStream != null) {
            this.shouldFixStream = true;
            this.mInputStream.reset();
            copyFromIsToOs(this.mInputStream, this.mOutputStream, this.mCurrentOffset - 2);
            this.mInputStream.skip(2);
        }
    }

    private boolean isNetscape() {
        int length = this.block.length;
        char[] cArr = NETSCAPE;
        if (length < cArr.length) {
            return false;
        }
        int length2 = cArr.length;
        for (int i = 0; i < length2; i++) {
            if (NETSCAPE[i] != ((char) this.block[i])) {
                return false;
            }
        }
        return true;
    }

    private int readAndWriteNextByte() {
        int readNextByte = readNextByte();
        writeNextByte(readNextByte);
        return readNextByte;
    }

    private int readBlock() {
        int readAndWriteNextByte = readAndWriteNextByte();
        int i = 0;
        if (readAndWriteNextByte > 0) {
            while (i < readAndWriteNextByte) {
                i += readIntoBlock(i, readAndWriteNextByte - i);
            }
        }
        return i;
    }

    private void readGifInfo() {
        validateAndIgnoreHeader();
        int[] iArr = {0, 0};
        boolean z = false;
        while (!z) {
            int readAndWriteNextByte = readAndWriteNextByte();
            if (readAndWriteNextByte == 33) {
                int readAndWriteNextByte2 = readAndWriteNextByte();
                if (readAndWriteNextByte2 == 1) {
                    addFrame(iArr);
                } else if (readAndWriteNextByte2 == 249) {
                    readGraphicsControlExtension(iArr);
                } else if (readAndWriteNextByte2 == 255) {
                    readBlock();
                    if (isNetscape()) {
                        readNetscapeExtension();
                    }
                }
                skipExtension();
            } else if (readAndWriteNextByte == 44) {
                addFrame(iArr);
                skipImage();
            } else if (readAndWriteNextByte == 59) {
                z = true;
            } else {
                throw new IOException("Unknown block header [" + Integer.toHexString(readAndWriteNextByte) + "]");
            }
        }
    }

    private void readGraphicsControlExtension(int[] iArr) {
        skipAndWriteBytes(1);
        iArr[0] = (readAndWriteNextByte() & 28) >> 2;
        iArr[1] = readTwoByteInt() * 10;
        if (iArr[1] == 0) {
            iArr[1] = 100;
            initFixedOutputStream();
        }
        writeTwoByteInt(iArr[1] / 10);
        skipAndWriteBytes(2);
    }

    private int readIntoBlock(int i, int i2) {
        int read = this.mInputStream.read(this.block, i, i2);
        this.mCurrentOffset += i2;
        if (this.shouldFixStream) {
            this.mOutputStream.write(this.block, i, i2);
        }
        if (read != -1) {
            return read;
        }
        throw new EOFException("Unexpected end of gif file");
    }

    private void readNetscapeExtension() {
        int readBlock;
        do {
            readBlock = readBlock();
            byte[] bArr = this.block;
            if (bArr[0] == 1) {
                this.mLoopCount = (bArr[1] & 255) | ((bArr[2] & 255) << 8);
                continue;
            }
        } while (readBlock > 0);
    }

    private int readNextByte() {
        int read = this.mInputStream.read();
        this.mCurrentOffset++;
        if (read != -1) {
            return read;
        }
        throw new EOFException("Unexpected end of gif file");
    }

    private int readTwoByteInt() {
        return readNextByte() | (readNextByte() << 8);
    }

    private void skipAndWriteBytes(int i) {
        if (this.shouldFixStream) {
            copyFromIsToOs(this.mInputStream, this.mOutputStream, i);
        } else {
            this.mInputStream.skip((long) i);
        }
        this.mCurrentOffset += i;
    }

    private void skipExtension() {
        do {
        } while (readBlock() > 0);
    }

    private void skipImage() {
        skipAndWriteBytes(8);
        int readAndWriteNextByte = readAndWriteNextByte();
        if ((readAndWriteNextByte & 128) != 0) {
            ignoreColorTable(2 << (readAndWriteNextByte & 7));
        }
        skipAndWriteBytes(1);
        skipExtension();
    }

    private void validateAndIgnoreHeader() {
        boolean z = false;
        readIntoBlock(0, 6);
        byte[] bArr = this.block;
        if ('G' == ((char) bArr[0]) && 'I' == ((char) bArr[1]) && 'F' == ((char) bArr[2]) && '8' == ((char) bArr[3]) && ('7' == ((char) bArr[4]) || '9' == ((char) bArr[4])) && 'a' == ((char) this.block[5])) {
            skipAndWriteBytes(4);
            int readAndWriteNextByte = readAndWriteNextByte();
            if ((readAndWriteNextByte & 128) != 0) {
                z = true;
            }
            int i = 2 << (readAndWriteNextByte & 7);
            skipAndWriteBytes(2);
            if (z) {
                ignoreColorTable(i);
                return;
            }
            return;
        }
        throw new IOException("Illegal header for gif");
    }

    private void writeNextByte(int i) {
        if (this.shouldFixStream) {
            this.mOutputStream.write(i);
        }
    }

    private void writeTwoByteInt(int i) {
        writeNextByte(i);
        writeNextByte(i >> 8);
    }

    public void decode() {
        if (!this.mDecoded) {
            this.mDecoded = true;
            readGifInfo();
            return;
        }
        throw new IllegalStateException("decode called multiple times");
    }

    public int getFrameCount() {
        if (this.mDecoded) {
            return this.mFrameControls.size();
        }
        throw new IllegalStateException("getFrameCount called before decode");
    }

    public int getFrameDisposal(int i) {
        if (this.mDecoded) {
            return this.mFrameControls.get(i)[0];
        }
        throw new IllegalStateException("getFrameDisposal called before decode");
    }

    public int getFrameDurationMs(int i) {
        if (!this.mDecoded) {
            throw new IllegalStateException("getFrameDurationMs called before decode");
        } else if (i >= getFrameCount()) {
            return 1;
        } else {
            return this.mFrameControls.get(i)[1];
        }
    }

    public int getLoopCount() {
        if (this.mDecoded) {
            return this.mLoopCount;
        }
        throw new IllegalStateException("getLoopCount called before decode");
    }
}
