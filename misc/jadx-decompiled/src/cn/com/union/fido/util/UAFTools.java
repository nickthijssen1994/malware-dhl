package cn.com.union.fido.util;

import android.content.Context;
import android.os.Build;
import android.util.Base64;
import cn.com.union.fido.bean.Version;
import cn.com.union.fido.bean.authenticator.RawKeyHandle;
import cn.com.union.fido.bean.uafclient.FinalChallengeParams;
import cn.com.union.fido.bean.uafclient.tls.ChannelBinding;
import cn.com.union.fido.common.GlobalConfiguration;
import com.jdjr.risk.jdcn.common.utils.FsGsonUtil;
import java.io.ByteArrayInputStream;
import java.security.KeyPair;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

/* renamed from: cn.com.union.fido.util.UAFTools */
/* loaded from: classes.dex */
public class UAFTools {
    private static final String TAG;

    public static String genFinalChallengeParams(String str, String str2, String str3, ChannelBinding channelBinding) {
        try {
            return new String(Base64.encode(FsGsonUtil.gsonString(new FinalChallengeParams(str, str2, str3, channelBinding)).getBytes(), 10), "utf-8");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String genKHAccessToken(String str, String str2, String str3, String str4, boolean z) {
        String str5 = "";
        if (z) {
            try {
                StringBuffer stringBuffer = new StringBuffer(str);
                stringBuffer.append(str2);
                stringBuffer.append(str3);
                stringBuffer.append(str4);
                str = stringBuffer.toString();
            } catch (Exception unused) {
            }
        }
        str5 = StringTools.urlSafeBase64Enc(CryptoTools.hash(str, "SHA256"));
        return StringTools.subStringByByte(str5, 32);
    }

    public static byte[] genSignature(int i, PrivateKey privateKey, byte[] bArr) {
        return Build.VERSION.SDK_INT >= 18 ? genSignatureTEE(i, privateKey, bArr) : genSignatureREE(i, privateKey, bArr);
    }

    private static byte[] genSignatureREE(int i, PrivateKey privateKey, byte[] bArr) {
        String str;
        switch (i) {
            case 1:
            case 5:
            default:
                return null;
            case 2:
            case 6:
                str = "SHA256withECDSA";
                break;
            case 3:
            case 4:
                str = "SHA256withRSA";
                break;
            case 7:
                str = "SM3withSM2";
                break;
        }
        return CryptoTools.doSignData(privateKey, str, bArr);
    }

    private static byte[] genSignatureTEE(int i, PrivateKey privateKey, byte[] bArr) {
        String str;
        if (i != 99) {
            switch (i) {
                case 1:
                case 5:
                default:
                    return null;
                case 2:
                case 6:
                    str = "SHA256withECDSA";
                    break;
                case 3:
                case 4:
                    str = "SHA256withRSA/PSS";
                    break;
                case 7:
                    return CryptoTools.doSignData(privateKey, "SM3withSM2", bArr);
            }
        } else {
            str = "SHA256withRSA";
        }
        return CryptoTools.doSignDataTee(privateKey, str, bArr);
    }

    public static KeyPair genUAuthKeyPair(int i, String str, Context context) {
        if (Build.VERSION.SDK_INT >= 18) {
            return genUAuthKeyPairTEE(i, str, context);
        }
        return null;
    }

    private static KeyPair genUAuthKeyPairREE(int i) {
        return null;
    }

    private static KeyPair genUAuthKeyPairTEE(int i, String str, Context context) {
        String str2;
        try {
            if (i == 99) {
                return CryptoTools.genRSAKeyTee(1024, str, true, 0, context);
            }
            switch (i) {
                case 1:
                case 2:
                    str2 = "SECP256R1";
                    break;
                case 3:
                case 4:
                    return CryptoTools.genRSAKeyTee(2048, str, true, 0, context);
                case 5:
                case 6:
                    str2 = "SECP256K1";
                    break;
                case 7:
                    return CryptoTools.genAsymmetricKey("SM2", 256);
                default:
                    return null;
            }
            return CryptoTools.genECKeyTee(str2, str, true, 0, context);
        } catch (Exception e) {
            while (true) {
                e.printStackTrace();
                return null;
            }
        }
    }

    public static String genUVI(String str, String str2) {
        if (!StringTools.isValidateString(str) || !StringTools.isValidateString(str2)) {
            return null;
        }
        String hash2Hex = CryptoTools.hash2Hex(str2);
        return CryptoTools.hash2Hex(str + hash2Hex);
    }

    /* JADX WARN: Removed duplicated region for block: B:19:0x0031 A[Catch: Exception -> 0x003e, TRY_LEAVE, TryCatch #0 {Exception -> 0x003e, blocks: (B:3:0x0001, B:5:0x0009, B:6:0x000b, B:7:0x0010, B:9:0x0016, B:11:0x001c, B:12:0x0021, B:14:0x0027, B:19:0x0031), top: B:27:0x0001 }] */
    /* JADX WARN: Removed duplicated region for block: B:22:0x003c  */
    /* Code decompiled incorrectly, please refer to instructions dump */
    public static RawKeyHandle generateDecryptedKeyHandle(Context context, String str) {
        RawKeyHandle rawKeyHandle;
        Exception e;
        byte[] bArr;
        String seriNumSerial;
        try {
            if (CryptoTools.secretKeyDetection(GlobalConfiguration.SERI_NUM)) {
                seriNumSerial = GlobalConfiguration.SERI_NUM;
            } else {
                String seriNumFingerprint = GlobalConfiguration.getSeriNumFingerprint(context);
                if (seriNumFingerprint == null || !CryptoTools.secretKeyDetection(seriNumFingerprint)) {
                    seriNumSerial = GlobalConfiguration.getSeriNumSerial(context);
                    if (seriNumSerial == null || !CryptoTools.secretKeyDetection(seriNumSerial)) {
                        bArr = null;
                    }
                } else {
                    bArr = CryptoTools.decrypt(seriNumFingerprint, str);
                }
                if (bArr != null) {
                    return null;
                }
                rawKeyHandle = new RawKeyHandle();
                try {
                    rawKeyHandle.deserialize(bArr);
                    return rawKeyHandle;
                } catch (Exception e2) {
                    e = e2;
                    e.printStackTrace();
                    return rawKeyHandle;
                }
            }
            bArr = CryptoTools.decrypt(seriNumSerial, str);
            if (bArr != null) {
            }
        } catch (Exception e3) {
            e = e3;
            rawKeyHandle = null;
        }
    }

    public static String generateEncryptedKeyHandleAhth(Context context, RawKeyHandle rawKeyHandle) {
        try {
            byte[] serialize = rawKeyHandle.serialize();
            if (CryptoTools.secretKeyDetection(GlobalConfiguration.SERI_NUM)) {
                return CryptoTools.encrypt(GlobalConfiguration.SERI_NUM, serialize);
            }
            String seriNumFingerprint = GlobalConfiguration.getSeriNumFingerprint(context);
            if (seriNumFingerprint != null && CryptoTools.secretKeyDetection(seriNumFingerprint)) {
                return CryptoTools.encrypt(seriNumFingerprint, serialize);
            }
            String seriNumSerial = GlobalConfiguration.getSeriNumSerial(context);
            if (seriNumSerial == null || !CryptoTools.secretKeyDetection(seriNumSerial)) {
                return null;
            }
            return CryptoTools.encrypt(seriNumSerial, serialize);
        } catch (Exception e) {
            while (true) {
                e.printStackTrace();
                return null;
            }
        }
    }

    public static String generateEncryptedKeyHandleReg(RawKeyHandle rawKeyHandle) {
        try {
            return CryptoTools.encrypt(GlobalConfiguration.SERI_NUM, rawKeyHandle.serialize());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static Version getAsmVersion() {
        Version version = new Version();
        version.major = 1;
        version.minor = 0;
        return version;
    }

    public static String getCallerID(Context context, int i) {
        String[] packagesForUid = context.getPackageManager().getPackagesForUid(i);
        if (packagesForUid == null) {
            return null;
        }
        try {
            return Base64.encodeToString(MessageDigest.getInstance("SHA1").digest(((X509Certificate) CertificateFactory.getInstance("X509").generateCertificate(new ByteArrayInputStream(context.getPackageManager().getPackageInfo(packagesForUid[0], 64).signatures[0].toByteArray()))).getEncoded()), 3);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static Version getClientVersion() {
        Version version = new Version();
        version.major = 1;
        version.minor = 0;
        return version;
    }

    public static Version getUAFVersion() {
        Version version = new Version();
        version.major = 1;
        version.minor = 0;
        return version;
    }

    public static KeyPair getUAuthKeyPairTEE(int i, String str, String str2) {
        if (i != 355) {
            switch (i) {
                case 256:
                case 257:
                case 258:
                case 259:
                    break;
                default:
                    return null;
            }
        }
        try {
            return CryptoTools.getPrivateKeyPairInTee(str2);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static PrivateKey getUAuthPrivateKey(int i, String str, String str2) {
        if (Build.VERSION.SDK_INT >= 19) {
            return getUAuthPrivateKeyTEE(i, str, str2);
        }
        return null;
    }

    public static PrivateKey getUAuthPrivateKeyREE(int i, String str) {
        return null;
    }

    public static PrivateKey getUAuthPrivateKeyTEE(int i, String str, String str2) {
        if (i != 355) {
            switch (i) {
                case 256:
                case 257:
                case 258:
                case 259:
                    break;
                default:
                    return null;
            }
        }
        try {
            return CryptoTools.getPrivateKeyInTee(str2);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static byte[] getUAuthPublicKey(int i, KeyPair keyPair) {
        PublicKey publicKey;
        try {
            if (i != 355) {
                switch (i) {
                    case 256:
                        return CryptoTools.getRAWECPublicKey(keyPair);
                    case 257:
                        publicKey = keyPair.getPublic();
                        break;
                    case 258:
                        return CryptoTools.getRAWRSAPublicKey(keyPair);
                    case 259:
                        return CryptoTools.getDERRSAPublicKey(keyPair);
                    case 260:
                        publicKey = keyPair.getPublic();
                        break;
                    default:
                        return null;
                }
            } else {
                publicKey = keyPair.getPublic();
            }
            return publicKey.getEncoded();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String getVendorIDFromAAID(String str) {
        if (StringTools.isValidateString(str)) {
            return StringTools.splitStrFlag(str, "#")[0];
        }
        return null;
    }

    public static String mixKHATokenWithAppID(String str, String str2) {
        return StringTools.subStringByByte(StringTools.urlSafeBase64Enc(CryptoTools.hash(str + str2, "SHA256")), 32);
    }
}
