package org.org.union.fido.util.asn1;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import org.org.union.fido.util.asn1.util.Arrays;

public class DERApplicationSpecific
  extends ASN1Object
{
  private final boolean isConstructed;
  private final byte[] octets;
  private final int tag;
  
  public DERApplicationSpecific(int paramInt, ASN1EncodableVector paramASN1EncodableVector)
  {
    tag = paramInt;
    isConstructed = true;
    Object localObject1 = new ByteArrayOutputStream();
    paramInt = 0;
    while (paramInt != paramASN1EncodableVector.size()) {
      try
      {
        Object localObject2 = paramASN1EncodableVector.get(paramInt);
        localObject2 = (ASN1Encodable)localObject2;
        ((ByteArrayOutputStream)localObject1).write(((ASN1Encodable)localObject2).getEncoded());
        paramInt += 1;
      }
      catch (IOException paramASN1EncodableVector)
      {
        localObject1 = new StringBuilder("malformed object: ");
        ((StringBuilder)localObject1).append(paramASN1EncodableVector);
        throw new ASN1ParsingException(((StringBuilder)localObject1).toString(), paramASN1EncodableVector);
      }
    }
    octets = ((ByteArrayOutputStream)localObject1).toByteArray();
  }
  
  public DERApplicationSpecific(int paramInt, DEREncodable paramDEREncodable)
  {
    this(true, paramInt, paramDEREncodable);
  }
  
  public DERApplicationSpecific(int paramInt, byte[] paramArrayOfByte)
  {
    this(false, paramInt, paramArrayOfByte);
  }
  
  public DERApplicationSpecific(boolean paramBoolean, int paramInt, DEREncodable paramDEREncodable)
  {
    paramDEREncodable = paramDEREncodable.getDERObject().getDEREncoded();
    isConstructed = paramBoolean;
    tag = paramInt;
    if (paramBoolean)
    {
      octets = paramDEREncodable;
      return;
    }
    paramInt = getLengthOfLength(paramDEREncodable);
    byte[] arrayOfByte = new byte[paramDEREncodable.length - paramInt];
    System.arraycopy(paramDEREncodable, paramInt, arrayOfByte, 0, arrayOfByte.length);
    octets = arrayOfByte;
  }
  
  DERApplicationSpecific(boolean paramBoolean, int paramInt, byte[] paramArrayOfByte)
  {
    isConstructed = paramBoolean;
    tag = paramInt;
    octets = paramArrayOfByte;
  }
  
  private int getLengthOfLength(byte[] paramArrayOfByte)
  {
    int i = 2;
    while ((paramArrayOfByte[(i - 1)] & 0x80) != 0) {
      i += 1;
    }
    return i;
  }
  
  private byte[] replaceTagNumber(int paramInt, byte[] paramArrayOfByte)
  {
    if ((paramArrayOfByte[0] & 0x1F) == 31)
    {
      int i = 2;
      int j = paramArrayOfByte[1] & 0xFF;
      if ((j & 0x7F) != 0) {
        for (;;)
        {
          k = i;
          if (j < 0) {
            break;
          }
          k = i;
          if ((j & 0x80) == 0) {
            break;
          }
          j = paramArrayOfByte[i] & 0xFF;
          i += 1;
        }
      }
      throw new ASN1ParsingException("corrupted stream - invalid high tag number found");
    }
    int k = 1;
    byte[] arrayOfByte = new byte[paramArrayOfByte.length - k + 1];
    System.arraycopy(paramArrayOfByte, k, arrayOfByte, 1, arrayOfByte.length - 1);
    arrayOfByte[0] = ((byte)paramInt);
    return arrayOfByte;
  }
  
  boolean asn1Equals(DERObject paramDERObject)
  {
    if (!(paramDERObject instanceof DERApplicationSpecific)) {
      return false;
    }
    paramDERObject = (DERApplicationSpecific)paramDERObject;
    return (isConstructed == isConstructed) && (tag == tag) && (Arrays.areEqual(octets, octets));
  }
  
  void encode(DEROutputStream paramDEROutputStream)
  {
    int i;
    if (isConstructed) {
      i = 96;
    } else {
      i = 64;
    }
    paramDEROutputStream.writeEncoded(i, tag, octets);
  }
  
  public int getApplicationTag()
  {
    return tag;
  }
  
  public byte[] getContents()
  {
    return octets;
  }
  
  public DERObject getObject()
  {
    return new ASN1InputStream(getContents()).readObject();
  }
  
  public DERObject getObject(int paramInt)
  {
    if (paramInt < 31)
    {
      byte[] arrayOfByte1 = getEncoded();
      byte[] arrayOfByte2 = replaceTagNumber(paramInt, arrayOfByte1);
      if ((arrayOfByte1[0] & 0x20) != 0) {
        arrayOfByte2[0] = ((byte)(arrayOfByte2[0] | 0x20));
      }
      return new ASN1InputStream(arrayOfByte2).readObject();
    }
    throw new IOException("unsupported tag number");
  }
  
  public int hashCode()
  {
    int i = tag;
    return isConstructed ^ i ^ Arrays.hashCode(octets);
  }
  
  public boolean isConstructed()
  {
    return isConstructed;
  }
}
