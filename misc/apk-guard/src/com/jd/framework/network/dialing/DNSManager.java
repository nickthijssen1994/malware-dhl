package com.jd.framework.network.dialing;

import android.text.TextUtils;
import android.util.Log;
import com.android.volley.VolleyLog;
import com.jingdong.common.network.IpModel;
import com.jingdong.jdsdk.network.JDHttpTookit;
import com.jingdong.jdsdk.network.JDHttpTookit.Engine;
import com.jingdong.jdsdk.network.dependency.IHttpDnsController;
import com.jingdong.sdk.oklog.OKLog;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.http.conn.util.InetAddressUtils;

public class DNSManager
  implements ConnectivityChangeObserver.Event
{
  public static final String C = "DNSManager";
  public static final int MAX_FAIL_THRESHOLD = 3;
  private static DNSManager instance;
  private ConcurrentHashMap<String, ArrayList<IPEntity>> buildInIPContainer = new ConcurrentHashMap();
  private IBuildInIPBackUpConfig config = null;
  private IPEntity dailingHealthIP = null;
  private ConcurrentHashMap<String, Integer> domainFailListMap = new ConcurrentHashMap();
  private ConcurrentHashMap<String, HashMap<String, ArrayList<IPEntity>>> httpDNSBackupIPContainer = new ConcurrentHashMap();
  private ConcurrentHashMap<String, ConcurrentHashMap<String, Integer>> ipFailListMap = new ConcurrentHashMap();
  
  private DNSManager()
  {
    HashMap localHashMap = IPConfiguration.buildInIPMap();
    Iterator localIterator = localHashMap.keySet().iterator();
    while (localIterator.hasNext())
    {
      String str1 = (String)localIterator.next();
      if ((localHashMap.get(str1) != null) && (((String[])localHashMap.get(str1)).length > 0))
      {
        ArrayList localArrayList = new ArrayList();
        String[] arrayOfString = (String[])localHashMap.get(str1);
        int j = arrayOfString.length;
        int i = 0;
        while (i < j)
        {
          String str2 = arrayOfString[i];
          IPEntity localIPEntity = new IPEntity();
          type = 0;
          destination = str2;
          localArrayList.add(localIPEntity);
          i += 1;
        }
        buildInIPContainer.put(str1, localArrayList);
      }
    }
  }
  
  public static DNSManager getInstance()
  {
    try
    {
      if (instance == null) {
        instance = new DNSManager();
      }
      DNSManager localDNSManager = instance;
      return localDNSManager;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public void add2DomainFailList(String paramString, Exception paramException)
  {
    ConcurrentHashMap localConcurrentHashMap = domainFailListMap;
    try
    {
      if ((!TextUtils.isEmpty(paramString)) && (paramException != null) && (NetworkExceptionFilter.filter(paramException)))
      {
        StringBuilder localStringBuilder;
        if (!domainFailListMap.containsKey(paramString))
        {
          if (VolleyLog.DEBUG)
          {
            paramException = C;
            localStringBuilder = new StringBuilder();
            localStringBuilder.append("add ");
            localStringBuilder.append(paramString);
            localStringBuilder.append(" to fail list ");
            Log.d(paramException, localStringBuilder.toString());
          }
          domainFailListMap.put(paramString, Integer.valueOf(1));
        }
        else
        {
          int i = ((Integer)domainFailListMap.get(paramString)).intValue();
          domainFailListMap.replace(paramString, Integer.valueOf(i), Integer.valueOf(i + 1));
          if (VolleyLog.DEBUG)
          {
            paramException = C;
            localStringBuilder = new StringBuilder();
            localStringBuilder.append("increase ");
            localStringBuilder.append(paramString);
            localStringBuilder.append(" occure count : ");
            localStringBuilder.append(domainFailListMap.get(paramString));
            Log.d(paramException, localStringBuilder.toString());
          }
        }
        return;
      }
      return;
    }
    catch (Throwable paramString)
    {
      throw paramString;
    }
  }
  
  public void add2IPFailList(String paramString1, String paramString2, Exception paramException)
  {
    ConcurrentHashMap localConcurrentHashMap = ipFailListMap;
    try
    {
      if ((!TextUtils.isEmpty(paramString1)) && (!TextUtils.isEmpty(paramString2)) && (paramException != null) && (NetworkExceptionFilter.filter(paramException)))
      {
        Object localObject;
        if (!ipFailListMap.containsKey(paramString1))
        {
          paramException = new ConcurrentHashMap();
          paramException.put(paramString2, Integer.valueOf(1));
          ipFailListMap.put(paramString1, paramException);
          if (VolleyLog.DEBUG)
          {
            paramException = C;
            localObject = new StringBuilder();
            ((StringBuilder)localObject).append("add host : ");
            ((StringBuilder)localObject).append(paramString1);
            ((StringBuilder)localObject).append(", with ip : ");
            ((StringBuilder)localObject).append(paramString2);
            ((StringBuilder)localObject).append(" to fail list.");
            Log.d(paramException, ((StringBuilder)localObject).toString());
          }
        }
        else
        {
          paramException = (ConcurrentHashMap)ipFailListMap.get(paramString1);
          if (paramException.containsKey(paramString2))
          {
            int i = ((Integer)paramException.get(paramString2)).intValue();
            paramException.replace(paramString2, Integer.valueOf(i), Integer.valueOf(i + 1));
            if (VolleyLog.DEBUG)
            {
              localObject = C;
              StringBuilder localStringBuilder = new StringBuilder();
              localStringBuilder.append("increase host : ");
              localStringBuilder.append(paramString1);
              localStringBuilder.append(", with ip : ");
              localStringBuilder.append(paramString2);
              localStringBuilder.append(" occure count : ");
              localStringBuilder.append(paramException.get(paramString2));
              Log.d((String)localObject, localStringBuilder.toString());
            }
          }
          else
          {
            paramException.put(paramString2, Integer.valueOf(1));
          }
        }
        return;
      }
      return;
    }
    catch (Throwable paramString1)
    {
      throw paramString1;
    }
  }
  
  /* Error */
  public void clearFailList()
  {
    // Byte code:
    //   0: aload_0
    //   1: getfield 46	com/jd/framework/network/dialing/DNSManager:ipFailListMap	Ljava/util/concurrent/ConcurrentHashMap;
    //   4: astore_1
    //   5: aload_1
    //   6: monitorenter
    //   7: aload_0
    //   8: getfield 46	com/jd/framework/network/dialing/DNSManager:ipFailListMap	Ljava/util/concurrent/ConcurrentHashMap;
    //   11: invokevirtual 197	java/util/concurrent/ConcurrentHashMap:clear	()V
    //   14: aload_1
    //   15: monitorexit
    //   16: aload_0
    //   17: getfield 48	com/jd/framework/network/dialing/DNSManager:domainFailListMap	Ljava/util/concurrent/ConcurrentHashMap;
    //   20: astore_1
    //   21: aload_1
    //   22: monitorenter
    //   23: aload_0
    //   24: getfield 48	com/jd/framework/network/dialing/DNSManager:domainFailListMap	Ljava/util/concurrent/ConcurrentHashMap;
    //   27: invokevirtual 197	java/util/concurrent/ConcurrentHashMap:clear	()V
    //   30: aload_1
    //   31: monitorexit
    //   32: return
    //   33: astore_2
    //   34: aload_1
    //   35: monitorexit
    //   36: aload_2
    //   37: athrow
    //   38: astore_2
    //   39: aload_1
    //   40: monitorexit
    //   41: aload_2
    //   42: athrow
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	43	0	this	DNSManager
    //   4	36	1	localConcurrentHashMap	ConcurrentHashMap
    //   33	4	2	localThrowable1	Throwable
    //   38	4	2	localThrowable2	Throwable
    // Exception table:
    //   from	to	target	type
    //   23	32	33	java/lang/Throwable
    //   34	36	33	java/lang/Throwable
    //   7	16	38	java/lang/Throwable
    //   39	41	38	java/lang/Throwable
  }
  
  void fetchHttpdnsBackupIP(String paramString)
  {
    Object localObject1 = JDHttpTookit.getEngine().getHttpDnsControllerImpl().getIpModelByHost(paramString, true);
    if (localObject1 == null) {
      return;
    }
    Object localObject2;
    Object localObject3;
    Object localObject4;
    int j;
    int i;
    Object localObject5;
    IPEntity localIPEntity1;
    if (httpDNSBackupIPContainer.containsKey(paramString))
    {
      paramString = (HashMap)httpDNSBackupIPContainer.get(paramString);
      localObject2 = (ArrayList)paramString.get("v6");
      paramString = (ArrayList)paramString.get("v4");
      if ((((IpModel)localObject1).getV6Backup() != null) && (((IpModel)localObject1).getV6Backup().length > 0))
      {
        localObject3 = new HashSet();
        localObject4 = ((ArrayList)localObject2).iterator();
        while (((Iterator)localObject4).hasNext()) {
          ((HashSet)localObject3).add(nextdestination);
        }
        localObject4 = ((IpModel)localObject1).getV6Backup();
        j = localObject4.length;
        i = 0;
        while (i < j)
        {
          localObject5 = localObject4[i];
          if (!((HashSet)localObject3).contains(localObject5))
          {
            localIPEntity1 = new IPEntity();
            type = 2;
            isV6 = true;
            destination = String.format("[%s]", new Object[] { localObject5 });
            ((ArrayList)localObject2).add(localIPEntity1);
          }
          i += 1;
        }
      }
      if ((((IpModel)localObject1).getV4Backup() != null) && (((IpModel)localObject1).getV4Backup().length > 0))
      {
        localObject2 = new HashSet();
        localObject3 = paramString.iterator();
        while (((Iterator)localObject3).hasNext()) {
          ((HashSet)localObject2).add(nextdestination);
        }
        localObject1 = ((IpModel)localObject1).getV4Backup();
        j = localObject1.length;
        i = 0;
        while (i < j)
        {
          localObject3 = localObject1[i];
          if (!((HashSet)localObject2).contains(localObject3))
          {
            localObject4 = new IPEntity();
            type = 2;
            isV6 = false;
            destination = ((String)localObject3);
            paramString.add(localObject4);
          }
          i += 1;
        }
      }
    }
    else
    {
      localObject2 = new HashMap();
      localObject3 = new ArrayList();
      localObject4 = new ArrayList();
      if ((((IpModel)localObject1).getV4Backup() != null) && (((IpModel)localObject1).getV4Backup().length > 0))
      {
        localObject5 = ((IpModel)localObject1).getV4Backup();
        j = localObject5.length;
        i = 0;
        while (i < j)
        {
          localIPEntity1 = localObject5[i];
          IPEntity localIPEntity2 = new IPEntity();
          type = 2;
          destination = localIPEntity1;
          isV6 = false;
          ((ArrayList)localObject3).add(localIPEntity2);
          i += 1;
        }
      }
      if ((((IpModel)localObject1).getV6Backup() != null) && (((IpModel)localObject1).getV6Backup().length > 0))
      {
        localObject1 = ((IpModel)localObject1).getV6Backup();
        j = localObject1.length;
        i = 0;
        while (i < j)
        {
          localObject5 = localObject1[i];
          localIPEntity1 = new IPEntity();
          type = 2;
          destination = String.format("[%s]", new Object[] { localObject5 });
          isV6 = true;
          ((ArrayList)localObject4).add(localIPEntity1);
          i += 1;
        }
      }
      ((HashMap)localObject2).put("v4", localObject3);
      ((HashMap)localObject2).put("v6", localObject4);
      httpDNSBackupIPContainer.put(paramString, localObject2);
    }
  }
  
  public IPEntity getDailingHealthIp(String paramString1, String paramString2)
  {
    try
    {
      Object localObject = config;
      ArrayList localArrayList = null;
      boolean bool;
      if (localObject != null)
      {
        bool = config.isFeatureEnable();
        if (!bool) {
          return null;
        }
      }
      if (!TextUtils.isEmpty(paramString2))
      {
        bool = hasFailedBefore(paramString1, paramString2);
        if (!bool) {
          return null;
        }
      }
      else
      {
        bool = hasFailedBefore(paramString1);
        if (!bool) {
          return null;
        }
      }
      if (dailingHealthIP != null)
      {
        OKLog.append(C, "get dialing ip via last cached health ip");
        paramString1 = dailingHealthIP;
        return paramString1;
      }
      if (OKLog.c) {
        OKLog.append(C, "get dialing ip via httpdns master ip.");
      }
      IpModel localIpModel = JDHttpTookit.getEngine().getHttpDnsControllerImpl().getIpModelByHost(paramString1, true);
      localObject = localArrayList;
      if (localIpModel != null)
      {
        localObject = localArrayList;
        if (!TextUtils.isEmpty(localIpModel.getMaster()))
        {
          localObject = localArrayList;
          if (!TextUtils.equals(localIpModel.getMaster(), paramString2))
          {
            paramString2 = new IPEntity();
            type = 1;
            if (InetAddressUtils.isIPv6Address(localIpModel.getMaster()))
            {
              destination = String.format("[%s]", new Object[] { localIpModel.getMaster() });
              isV6 = true;
            }
            else
            {
              destination = localIpModel.getMaster();
            }
            localObject = DialingExecutor.select(paramString2, 2000);
          }
        }
      }
      if (localObject != null)
      {
        if (OKLog.c)
        {
          paramString1 = C;
          paramString2 = new StringBuilder();
          paramString2.append("get dialing ip via httpdns ip.");
          paramString2.append(localObject);
          OKLog.append(paramString1, paramString2.toString());
        }
        dailingHealthIP = ((IPEntity)localObject);
        return localObject;
      }
      if (OKLog.c) {
        OKLog.append(C, "get dialing ip via httpdns backup ip.");
      }
      fetchHttpdnsBackupIP(paramString1);
      if (httpDNSBackupIPContainer.containsKey(paramString1))
      {
        paramString2 = (HashMap)httpDNSBackupIPContainer.get(paramString1);
        localArrayList = (ArrayList)paramString2.get("v6");
        if (localArrayList.size() > 0) {
          localObject = DialingExecutor.randomSelect(localArrayList, 2000);
        }
        if (localObject != null)
        {
          if (OKLog.c)
          {
            paramString1 = C;
            paramString2 = new StringBuilder();
            paramString2.append("get dialing ip via ipv6 backup ip.");
            paramString2.append(localObject);
            OKLog.append(paramString1, paramString2.toString());
          }
          dailingHealthIP = ((IPEntity)localObject);
          return localObject;
        }
        paramString2 = (ArrayList)paramString2.get("v4");
        if (paramString2.size() > 0) {
          localObject = DialingExecutor.randomSelect(paramString2, 2000);
        }
        if (localObject != null)
        {
          if (OKLog.c)
          {
            paramString1 = C;
            paramString2 = new StringBuilder();
            paramString2.append("get dialing ip via ipv4 backup ip. ");
            paramString2.append(localObject);
            OKLog.append(paramString1, paramString2.toString());
          }
          dailingHealthIP = ((IPEntity)localObject);
          return localObject;
        }
      }
      if (OKLog.c) {
        OKLog.append(C, "get dialing ip via buildin ip.");
      }
      paramString1 = DialingExecutor.randomSelect((ArrayList)buildInIPContainer.get(paramString1), 2000);
      dailingHealthIP = paramString1;
      return paramString1;
    }
    catch (Throwable paramString1)
    {
      throw paramString1;
    }
  }
  
  public boolean hasFailedBefore(String paramString)
  {
    ConcurrentHashMap localConcurrentHashMap = domainFailListMap;
    for (;;)
    {
      try
      {
        if ((domainFailListMap.containsKey(paramString)) && (((Integer)domainFailListMap.get(paramString)).intValue() >= 3))
        {
          bool = true;
          return bool;
        }
      }
      catch (Throwable paramString)
      {
        throw paramString;
      }
      boolean bool = false;
    }
  }
  
  public boolean hasFailedBefore(String paramString1, String paramString2)
  {
    ConcurrentHashMap localConcurrentHashMap = ipFailListMap;
    for (;;)
    {
      try
      {
        if ((ipFailListMap.containsKey(paramString1)) && (ipFailListMap.get(paramString1) != null) && (((ConcurrentHashMap)ipFailListMap.get(paramString1)).containsKey(paramString2)) && (((Integer)((ConcurrentHashMap)ipFailListMap.get(paramString1)).get(paramString2)).intValue() >= 3))
        {
          bool = true;
          return bool;
        }
      }
      catch (Throwable paramString1)
      {
        throw paramString1;
      }
      boolean bool = false;
    }
  }
  
  public void onNetworkChange()
  {
    if (VolleyLog.DEBUG) {
      VolleyLog.d(C, new Object[] { "network change" });
    }
    clearFailList();
    resetDailingResult();
  }
  
  public void removeFromFailList(String paramString)
  {
    ConcurrentHashMap localConcurrentHashMap = domainFailListMap;
    try
    {
      if (domainFailListMap.containsKey(paramString))
      {
        if (VolleyLog.DEBUG)
        {
          String str = C;
          StringBuilder localStringBuilder = new StringBuilder();
          localStringBuilder.append("remove ");
          localStringBuilder.append(paramString);
          localStringBuilder.append("from fail list");
          Log.d(str, localStringBuilder.toString());
        }
        domainFailListMap.remove(paramString);
      }
      return;
    }
    catch (Throwable paramString)
    {
      throw paramString;
    }
  }
  
  public void removeFromFailList(String paramString1, String paramString2)
  {
    ConcurrentHashMap localConcurrentHashMap = ipFailListMap;
    try
    {
      if (ipFailListMap.containsKey(paramString1))
      {
        if ((ipFailListMap.get(paramString1) != null) && (((ConcurrentHashMap)ipFailListMap.get(paramString1)).containsKey(paramString2))) {
          ((ConcurrentHashMap)ipFailListMap.get(paramString1)).remove(paramString2);
        }
        if (VolleyLog.DEBUG)
        {
          String str = C;
          StringBuilder localStringBuilder = new StringBuilder();
          localStringBuilder.append("remove host : ");
          localStringBuilder.append(paramString1);
          localStringBuilder.append(" with ip ");
          localStringBuilder.append(paramString2);
          localStringBuilder.append("from fail list.");
          Log.d(str, localStringBuilder.toString());
        }
      }
      return;
    }
    catch (Throwable paramString1)
    {
      throw paramString1;
    }
  }
  
  public void resetDailingResult()
  {
    try
    {
      dailingHealthIP = null;
      if (buildInIPContainer != null)
      {
        Iterator localIterator = buildInIPContainer.keySet().iterator();
        while (localIterator.hasNext())
        {
          Object localObject = (String)localIterator.next();
          localObject = ((ArrayList)buildInIPContainer.get(localObject)).iterator();
          while (((Iterator)localObject).hasNext()) {
            nexttime = 0L;
          }
        }
      }
      httpDNSBackupIPContainer.clear();
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public void setBuildInIPBackUpConfig(IBuildInIPBackUpConfig paramIBuildInIPBackUpConfig)
  {
    config = paramIBuildInIPBackUpConfig;
  }
  
  public static abstract interface IBuildInIPBackUpConfig
  {
    public abstract boolean isFeatureEnable();
  }
}
