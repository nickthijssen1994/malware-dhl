package com.jd.lib.unification.album.view;

import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Matrix;
import android.graphics.Matrix.ScaleToFit;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.util.AttributeSet;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.ScaleGestureDetector.SimpleOnScaleGestureListener;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnLongClickListener;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import com.jingdong.common.DpiUtil;
import com.jingdong.common.UnLog;
import java.util.LinkedList;

@SuppressLint({"AppCompatCustomView"})
public class CropPhotoView
  extends ImageView
{
  private static final byte MODE_DEFAULT = 0;
  private static final byte MODE_SCALE = 1;
  private static final String TAG = "PhotoView";
  private Matrix changeMatrix;
  private GestureDetector commonGestureDetector;
  private RectF cropRect = new RectF();
  private int currentMode = 0;
  private float doubleTapScaleLevel = maxScaleLevel;
  private FlingAnimator flingAnimator;
  private boolean limitCropRectTransAera;
  protected final float[] mCurrentImageCenter = new float[2];
  protected final float[] mCurrentImageCorners = new float[8];
  private Bitmap mImageBitmap;
  private float[] mInitialImageCenter;
  private float[] mInitialImageCorners;
  private PointF mLastScalePoint;
  private float mScaleFactor = 1.0F;
  private MatrixPool matrixPool;
  private float maxScaleLevel = 4.0F;
  private float minScaleLevel = 1.0F;
  private View.OnClickListener onClickListener;
  private View.OnLongClickListener onLongClickListener;
  private ScaleAnimator scaleAnimator;
  private ScaleGestureDetector scaleGestureDetector;
  private boolean scaleable;
  
  public CropPhotoView(Context paramContext)
  {
    super(paramContext);
    initConfig();
    initGestureDetector();
  }
  
  public CropPhotoView(Context paramContext, AttributeSet paramAttributeSet)
  {
    super(paramContext, paramAttributeSet);
    initConfig();
    initGestureDetector();
  }
  
  public CropPhotoView(Context paramContext, AttributeSet paramAttributeSet, int paramInt)
  {
    super(paramContext, paramAttributeSet, paramInt);
    initConfig();
    initGestureDetector();
  }
  
  private void cancelFlingAnim()
  {
    FlingAnimator localFlingAnimator = flingAnimator;
    if (localFlingAnimator != null) {
      localFlingAnimator.cancel();
    }
  }
  
  private void cancelScaleAnim()
  {
    ScaleAnimator localScaleAnimator = scaleAnimator;
    if (localScaleAnimator != null) {
      localScaleAnimator.cancel();
    }
  }
  
  private Matrix changeMatrixToFitScale(Matrix paramMatrix, float paramFloat1, float paramFloat2)
  {
    float f1 = mScaleFactor;
    float f2 = minScaleLevel;
    float f3 = f1 * maxScaleLevel;
    float f4 = getMatrixValue(paramMatrix, 0);
    if (f4 < f2 * f1) {
      return matrixPool.borrowObject(getInnerMatrix());
    }
    if (f4 > f3)
    {
      paramMatrix = matrixPool.borrowObject(paramMatrix);
      f1 = f3 / f4;
      paramMatrix.postScale(f1, f1, paramFloat1, paramFloat2);
      return paramMatrix;
    }
    return matrixPool.borrowObject(paramMatrix);
  }
  
  private Matrix changeMatrixToFitTranslate(Matrix paramMatrix)
  {
    paramMatrix = matrixPool.borrowObject(paramMatrix);
    RectF localRectF = getImageBounds(paramMatrix);
    int i = getWidth();
    int j = getHeight();
    float f2 = localRectF.width();
    float f1 = localRectF.height();
    float f5 = i;
    float f6 = f5 - f2;
    float f4 = j;
    float f3 = f4 - f1;
    f1 = 0.0F;
    f2 = 0.0F;
    if ((f6 > 0.0F) && (f3 > 0.0F))
    {
      f1 = f6 / 2.0F;
      f2 = left;
      f3 /= 2.0F;
      f4 = top;
      f2 = f1 - f2;
      f1 = f3 - f4;
    }
    else if ((f6 <= 0.0F) && (f3 <= 0.0F))
    {
      if (left > 0.0F) {
        f3 = -left;
      } else if (right < f5) {
        f3 = f5 - right;
      } else {
        f3 = 0.0F;
      }
      if (top > 0.0F)
      {
        f1 = -top;
        f2 = f3;
      }
      else
      {
        f2 = f3;
        if (bottom < f4)
        {
          f1 = f4 - bottom;
          f2 = f3;
        }
      }
    }
    else if ((f6 <= 0.0F) && (f3 > 0.0F))
    {
      if (left > 0.0F)
      {
        f1 = -left;
      }
      else
      {
        f1 = f2;
        if (right < f5) {
          f1 = f5 - right;
        }
      }
      f3 /= 2.0F;
      f4 = top;
      f2 = f1;
      f1 = f3 - f4;
    }
    else if ((f6 > 0.0F) && (f3 <= 0.0F))
    {
      f3 = f6 / 2.0F - left;
      if (top > 0.0F)
      {
        f1 = -top;
        f2 = f3;
      }
      else
      {
        f2 = f3;
        if (bottom < f4)
        {
          f1 = f4 - bottom;
          f2 = f3;
        }
      }
    }
    else
    {
      f2 = 0.0F;
    }
    paramMatrix.postTranslate(f2, f1);
    return paramMatrix;
  }
  
  private Matrix changeMatrixToFitTranslate(Matrix paramMatrix, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    paramMatrix = matrixPool.borrowObject(paramMatrix);
    RectF localRectF = getImageBounds(paramMatrix);
    int i = getWidth();
    int j = getHeight();
    float f1 = localRectF.width();
    float f2 = localRectF.height();
    f1 = i - f1;
    float f4 = j - f2;
    f2 = 0.0F;
    float f3;
    if ((f1 > 0.0F) && (f4 > 0.0F))
    {
      f3 = f1 / 2.0F - left;
      f2 = f4 / 2.0F - top;
    }
    else
    {
      f1 = left;
      f3 = paramInt1;
      if (f1 > f3)
      {
        f1 = -(left - f3);
      }
      else
      {
        f1 = right;
        f3 = paramInt3;
        if (f1 < f3) {
          f1 = f3 - right;
        } else {
          f1 = 0.0F;
        }
      }
      f3 = top;
      f4 = paramInt2;
      if (f3 > f4)
      {
        f2 = -(top - f4);
        f3 = f1;
      }
      else
      {
        f4 = bottom;
        float f5 = paramInt4;
        f3 = f1;
        if (f4 < f5)
        {
          f2 = f5 - bottom;
          f3 = f1;
        }
      }
    }
    paramMatrix.postTranslate(f3, f2);
    return paramMatrix;
  }
  
  private void dispatchDoubleTapChange(MotionEvent paramMotionEvent)
  {
    if (!isReady()) {
      return;
    }
    float f1 = (float)(Math.floor(getMatrixValue(changeMatrix, 0) * 100.0F) / 100.0D);
    float f2 = minScaleLevel;
    float f4 = mScaleFactor;
    float f5 = f2 * f4;
    float f6 = doubleTapScaleLevel;
    f2 = paramMotionEvent.getX();
    float f3 = paramMotionEvent.getY();
    if (f1 <= f5) {
      f1 = f6 * f4 / f1;
    } else {
      f1 = f5 / f1;
    }
    paramMotionEvent = matrixPool.borrowObject(changeMatrix);
    paramMotionEvent.postScale(f1, f1, f2, f3);
    paramMotionEvent = changeMatrixToFitTranslate(paramMotionEvent);
    scaleAnimator = new ScaleAnimator(changeMatrix, paramMotionEvent);
    scaleAnimator.start();
    matrixPool.returnObject(paramMotionEvent);
  }
  
  private void dispatchFlingChange(float paramFloat1, float paramFloat2)
  {
    if (!isReady()) {
      return;
    }
    flingAnimator = new FlingAnimator(paramFloat1 / 60.0F, paramFloat2 / 60.0F);
    flingAnimator.start();
  }
  
  private void dispatchScaleEndChange()
  {
    if (!isReady()) {
      return;
    }
    float f1 = mLastScalePoint.x;
    float f2 = mLastScalePoint.y;
    Matrix localMatrix = changeMatrixToFitTranslate(changeMatrixToFitScale(changeMatrix, f1, f2));
    scaleAnimator = new ScaleAnimator(changeMatrix, localMatrix);
    scaleAnimator.start();
    matrixPool.returnObject(localMatrix);
  }
  
  private void dispatchScrollChange(float paramFloat1, float paramFloat2)
  {
    if (!isReady()) {
      return;
    }
    if (currentMode == 0)
    {
      changeMatrix.postTranslate(paramFloat1, paramFloat2);
      if (limitCropRectTransAera)
      {
        int i = (int)cropRect.left;
        int j = (int)cropRect.top;
        int k = (int)cropRect.right;
        int m = (int)cropRect.bottom;
        StringBuilder localStringBuilder = new StringBuilder();
        localStringBuilder.append("limitLeft:");
        localStringBuilder.append(i);
        localStringBuilder.append(" limitTop:");
        localStringBuilder.append(j);
        localStringBuilder.append(" limitRight:");
        localStringBuilder.append(k);
        localStringBuilder.append(" limitBottom:");
        localStringBuilder.append(m);
        Log.d("PhotoView", localStringBuilder.toString());
        changeMatrix = changeMatrixToFitTranslate(changeMatrix, i, j, k, m);
      }
      else
      {
        changeMatrix = changeMatrixToFitTranslate(changeMatrix);
      }
    }
    else
    {
      changeMatrix.postTranslate(paramFloat1, paramFloat2);
    }
    setImageMatrix(changeMatrix);
  }
  
  private void fitImageToCenter()
  {
    Matrix localMatrix = getInnerMatrix();
    if (localMatrix != null)
    {
      mScaleFactor = getMatrixValue(localMatrix, 0);
      changeMatrix.set(localMatrix);
      setImageMatrix(changeMatrix);
      matrixPool.returnObject(localMatrix);
    }
  }
  
  private RectF getImageBounds(Matrix paramMatrix)
  {
    if ((isReady()) && (paramMatrix != null))
    {
      RectF localRectF = new RectF(0.0F, 0.0F, getDrawable().getIntrinsicWidth(), getDrawable().getIntrinsicHeight());
      paramMatrix.mapRect(localRectF);
      return localRectF;
    }
    return new RectF();
  }
  
  private Matrix getInnerMatrix()
  {
    if (!isReady()) {
      return null;
    }
    Object localObject1 = getDrawable();
    int i = ((Drawable)localObject1).getIntrinsicWidth();
    int j = ((Drawable)localObject1).getIntrinsicHeight();
    Object localObject2 = new RectF(0.0F, 0.0F, i, j);
    i = getWidth();
    j = getHeight();
    RectF localRectF = new RectF(0.0F, 0.0F, i, j);
    localObject1 = matrixPool.borrowObject();
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("before scale change ");
    localStringBuilder.append(getMatrixValue((Matrix)localObject1, 0));
    localStringBuilder.append(" ");
    localStringBuilder.append(getMatrixValue((Matrix)localObject1, 4));
    localStringBuilder.append(" ");
    localStringBuilder.append(getMatrixValue((Matrix)localObject1, 2));
    localStringBuilder.append(" ");
    localStringBuilder.append(getMatrixValue((Matrix)localObject1, 5));
    Log.d("PhotoView", localStringBuilder.toString());
    ((Matrix)localObject1).setRectToRect((RectF)localObject2, localRectF, Matrix.ScaleToFit.CENTER);
    localObject2 = new StringBuilder();
    ((StringBuilder)localObject2).append("after scale change ");
    ((StringBuilder)localObject2).append(getMatrixValue((Matrix)localObject1, 0));
    ((StringBuilder)localObject2).append(" ");
    ((StringBuilder)localObject2).append(getMatrixValue((Matrix)localObject1, 4));
    ((StringBuilder)localObject2).append(" ");
    ((StringBuilder)localObject2).append(getMatrixValue((Matrix)localObject1, 2));
    ((StringBuilder)localObject2).append(" ");
    ((StringBuilder)localObject2).append(getMatrixValue((Matrix)localObject1, 5));
    Log.d("PhotoView", ((StringBuilder)localObject2).toString());
    float f = minScaleLevel;
    if (f == 1.0F) {
      return localObject1;
    }
    ((Matrix)localObject1).postScale(f, f, DpiUtil.getWidth(getContext()) / 2, DpiUtil.getHeight(getContext()) / 2);
    return localObject1;
  }
  
  private float getMatrixValue(Matrix paramMatrix, int paramInt)
  {
    float[] arrayOfFloat = new float[9];
    paramMatrix.getValues(arrayOfFloat);
    return arrayOfFloat[paramInt];
  }
  
  private void initConfig()
  {
    setScaleType(ImageView.ScaleType.MATRIX);
    changeMatrix = new Matrix();
    matrixPool = new MatrixPool();
  }
  
  private void initGestureDetector()
  {
    commonGestureDetector = new GestureDetector(getContext(), new DealCommonGestureCallback(null));
    scaleGestureDetector = new ScaleGestureDetector(getContext(), new DealScaleGestureCallback(null));
  }
  
  private boolean isReady()
  {
    return (getWidth() > 0) && (getHeight() > 0) && (getDrawable() != null) && (getDrawable().getIntrinsicWidth() > 0) && (getDrawable().getIntrinsicHeight() > 0);
  }
  
  private boolean isScaleAnimRunning()
  {
    ScaleAnimator localScaleAnimator = scaleAnimator;
    return (localScaleAnimator != null) && (localScaleAnimator.isRunning());
  }
  
  private void updateCurrentImagePoints()
  {
    changeMatrix.mapPoints(mCurrentImageCorners, mInitialImageCorners);
    changeMatrix.mapPoints(mCurrentImageCenter, mInitialImageCenter);
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("updateImagePoint  left: ");
    localStringBuilder.append(mCurrentImageCorners[0]);
    localStringBuilder.append(" top: ");
    localStringBuilder.append(mCurrentImageCorners[1]);
    localStringBuilder.append(" right: ");
    localStringBuilder.append(mCurrentImageCorners[2]);
    localStringBuilder.append(" bottom: ");
    localStringBuilder.append(mCurrentImageCorners[5]);
    Log.d("PhotoView", localStringBuilder.toString());
  }
  
  private void updateLastScalePoint(float paramFloat1, float paramFloat2)
  {
    PointF localPointF = mLastScalePoint;
    if (localPointF == null)
    {
      mLastScalePoint = new PointF(paramFloat1, paramFloat2);
      return;
    }
    localPointF.set(paramFloat1, paramFloat2);
  }
  
  private void updateMode(byte paramByte)
  {
    currentMode = paramByte;
  }
  
  public boolean canScrollHorizontally(int paramInt)
  {
    if (currentMode != 1)
    {
      if (isScaleAnimRunning()) {
        return false;
      }
      RectF localRectF = getImageBounds(changeMatrix);
      if (localRectF.isEmpty()) {
        return false;
      }
      if (paramInt > 0) {
        return right > getWidth();
      }
      return left < 0.0F;
    }
    return false;
  }
  
  public boolean canScrollVertically(int paramInt)
  {
    if (currentMode != 1)
    {
      if (isScaleAnimRunning()) {
        return false;
      }
      RectF localRectF = getImageBounds(changeMatrix);
      if (localRectF.isEmpty()) {
        return false;
      }
      if (paramInt > 0) {
        return bottom > getHeight();
      }
      return top < 0.0F;
    }
    return false;
  }
  
  public void dispatchScaleChange(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    if (!isReady()) {
      return;
    }
    updateLastScalePoint(paramFloat2, paramFloat3);
    changeMatrix.postScale(paramFloat1, paramFloat1, paramFloat2, paramFloat3);
    setImageMatrix(changeMatrix);
  }
  
  public float getCurrentScale()
  {
    return getMatrixValue(changeMatrix, 0);
  }
  
  public float getDoubleTapScaleLevel()
  {
    return doubleTapScaleLevel;
  }
  
  public Bitmap getImageBitmap()
  {
    return mImageBitmap;
  }
  
  public float getMaxScaleLevel()
  {
    return maxScaleLevel;
  }
  
  public boolean isZoomed()
  {
    if (changeMatrix == null) {
      return false;
    }
    Matrix localMatrix = getInnerMatrix();
    if (localMatrix == null) {
      return false;
    }
    return localMatrix.equals(changeMatrix) ^ true;
  }
  
  protected void onLayout(boolean paramBoolean, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    super.onLayout(paramBoolean, paramInt1, paramInt2, paramInt3, paramInt4);
    if (paramBoolean)
    {
      Object localObject = getDrawable();
      if (localObject != null)
      {
        localObject = new RectF(0.0F, 0.0F, getDrawable().getIntrinsicWidth(), ((Drawable)localObject).getIntrinsicHeight());
        mInitialImageCorners = new float[] { left, top, right, top, right, bottom, left, bottom };
        mInitialImageCenter = new float[] { ((RectF)localObject).centerX(), ((RectF)localObject).centerY() };
      }
      fitImageToCenter();
    }
  }
  
  public boolean onTouchEvent(MotionEvent paramMotionEvent)
  {
    if (scaleable)
    {
      commonGestureDetector.onTouchEvent(paramMotionEvent);
      scaleGestureDetector.onTouchEvent(paramMotionEvent);
    }
    return true;
  }
  
  public void reset()
  {
    fitImageToCenter();
  }
  
  public void setCropRect(RectF paramRectF)
  {
    limitCropRectTransAera = true;
    cropRect = paramRectF;
  }
  
  public void setDoubleTapScaleLevel(int paramInt)
  {
    float f = paramInt;
    if ((f >= minScaleLevel) && (f <= maxScaleLevel))
    {
      doubleTapScaleLevel = f;
      return;
    }
    UnLog.e("PhotoView", "doubleTapScaleLevel??????minScaleLevel-maxScaleLevel???");
  }
  
  public void setImageBitmap(Bitmap paramBitmap)
  {
    super.setImageBitmap(paramBitmap);
    mImageBitmap = paramBitmap;
    reset();
  }
  
  public void setImageDrawable(Drawable paramDrawable)
  {
    super.setImageDrawable(paramDrawable);
    reset();
  }
  
  public void setImageMatrix(Matrix paramMatrix)
  {
    super.setImageMatrix(paramMatrix);
    changeMatrix.set(paramMatrix);
    updateCurrentImagePoints();
  }
  
  public void setImageResource(int paramInt)
  {
    super.setImageResource(paramInt);
    reset();
  }
  
  public void setImageURI(Uri paramUri)
  {
    super.setImageURI(paramUri);
    reset();
  }
  
  public void setMaxScaleLevel(float paramFloat)
  {
    if (paramFloat < minScaleLevel)
    {
      UnLog.e("PhotoView", "maxScaleLevel?????minScaleLevel?");
      return;
    }
    maxScaleLevel = paramFloat;
    if (doubleTapScaleLevel > paramFloat) {
      doubleTapScaleLevel = paramFloat;
    }
  }
  
  public void setMinScaleLevel(float paramFloat)
  {
    minScaleLevel = paramFloat;
  }
  
  public void setOnClickListener(View.OnClickListener paramOnClickListener)
  {
    onClickListener = paramOnClickListener;
  }
  
  public void setOnLongClickListener(View.OnLongClickListener paramOnLongClickListener)
  {
    onLongClickListener = paramOnLongClickListener;
  }
  
  public void setScaleable(boolean paramBoolean)
  {
    scaleable = paramBoolean;
  }
  
  private class DealCommonGestureCallback
    extends GestureDetector.SimpleOnGestureListener
  {
    private DealCommonGestureCallback() {}
    
    public boolean onDoubleTap(MotionEvent paramMotionEvent)
    {
      CropPhotoView.this.cancelFlingAnim();
      CropPhotoView.this.cancelScaleAnim();
      CropPhotoView.this.dispatchDoubleTapChange(paramMotionEvent);
      return true;
    }
    
    public boolean onFling(MotionEvent paramMotionEvent1, MotionEvent paramMotionEvent2, float paramFloat1, float paramFloat2)
    {
      if (!CropPhotoView.this.isScaleAnimRunning())
      {
        CropPhotoView.this.cancelFlingAnim();
        CropPhotoView.this.dispatchFlingChange(paramFloat1, paramFloat2);
      }
      return true;
    }
    
    public void onLongPress(MotionEvent paramMotionEvent)
    {
      super.onLongPress(paramMotionEvent);
      if (onLongClickListener != null) {
        onLongClickListener.onLongClick(CropPhotoView.this);
      }
    }
    
    public boolean onScroll(MotionEvent paramMotionEvent1, MotionEvent paramMotionEvent2, float paramFloat1, float paramFloat2)
    {
      if (!CropPhotoView.this.isScaleAnimRunning())
      {
        CropPhotoView.this.cancelFlingAnim();
        CropPhotoView.this.dispatchScrollChange(-paramFloat1, -paramFloat2);
      }
      return true;
    }
    
    public boolean onSingleTapUp(MotionEvent paramMotionEvent)
    {
      if (onClickListener != null) {
        onClickListener.onClick(CropPhotoView.this);
      }
      return true;
    }
  }
  
  private class DealScaleGestureCallback
    extends ScaleGestureDetector.SimpleOnScaleGestureListener
  {
    private DealScaleGestureCallback() {}
    
    public boolean onScale(ScaleGestureDetector paramScaleGestureDetector)
    {
      if (!CropPhotoView.this.isScaleAnimRunning())
      {
        CropPhotoView.this.cancelFlingAnim();
        dispatchScaleChange(paramScaleGestureDetector.getScaleFactor(), paramScaleGestureDetector.getFocusX(), paramScaleGestureDetector.getFocusY());
      }
      return true;
    }
    
    public boolean onScaleBegin(ScaleGestureDetector paramScaleGestureDetector)
    {
      if (!CropPhotoView.this.isScaleAnimRunning())
      {
        CropPhotoView.this.updateMode((byte)1);
        return true;
      }
      return false;
    }
    
    public void onScaleEnd(ScaleGestureDetector paramScaleGestureDetector)
    {
      super.onScaleEnd(paramScaleGestureDetector);
      CropPhotoView.this.updateMode((byte)0);
      CropPhotoView.this.cancelFlingAnim();
      CropPhotoView.this.cancelScaleAnim();
      CropPhotoView.this.dispatchScaleEndChange();
    }
  }
  
  private class FlingAnimator
    extends ValueAnimator
    implements ValueAnimator.AnimatorUpdateListener
  {
    private float[] mVector;
    
    public FlingAnimator(float paramFloat1, float paramFloat2)
    {
      setFloatValues(new float[] { 0.0F, 1.0F });
      setDuration(1000000L);
      addUpdateListener(this);
      mVector = new float[] { paramFloat1, paramFloat2 };
    }
    
    public void onAnimationUpdate(ValueAnimator paramValueAnimator)
    {
      float[] arrayOfFloat = mVector;
      if ((arrayOfFloat[0] != 0.0F) && (arrayOfFloat[1] != 0.0F))
      {
        CropPhotoView.this.dispatchScrollChange(arrayOfFloat[0], arrayOfFloat[1]);
        arrayOfFloat = mVector;
        arrayOfFloat[0] *= 0.9F;
        arrayOfFloat[1] *= 0.9F;
        if (Math.sqrt(arrayOfFloat[0] * arrayOfFloat[0] + arrayOfFloat[1] * arrayOfFloat[1]) < 1.0D) {
          paramValueAnimator.cancel();
        }
      }
      else
      {
        paramValueAnimator.cancel();
      }
    }
  }
  
  private class MatrixPool
  {
    private LinkedList<Matrix> caches;
    private int maxSize;
    
    public MatrixPool()
    {
      this(16);
    }
    
    public MatrixPool(int paramInt)
    {
      maxSize = paramInt;
      caches = new LinkedList();
    }
    
    public Matrix borrowObject()
    {
      if (!caches.isEmpty()) {
        return (Matrix)caches.poll();
      }
      return new Matrix();
    }
    
    public Matrix borrowObject(Matrix paramMatrix)
    {
      Matrix localMatrix = borrowObject();
      localMatrix.set(paramMatrix);
      return localMatrix;
    }
    
    public boolean returnObject(Matrix paramMatrix)
    {
      if ((paramMatrix != null) && (caches.size() < maxSize))
      {
        paramMatrix.reset();
        caches.offer(paramMatrix);
        return true;
      }
      return false;
    }
  }
  
  private class ScaleAnimator
    extends ValueAnimator
    implements ValueAnimator.AnimatorUpdateListener
  {
    private float[] mEnd = new float[9];
    private float[] mResult = new float[9];
    private float[] mStart = new float[9];
    
    public ScaleAnimator(Matrix paramMatrix1, Matrix paramMatrix2)
    {
      this(paramMatrix1, paramMatrix2, 300L);
    }
    
    public ScaleAnimator(Matrix paramMatrix1, Matrix paramMatrix2, long paramLong)
    {
      setFloatValues(new float[] { 0.0F, 1.0F });
      setDuration(paramLong);
      addUpdateListener(this);
      paramMatrix1.getValues(mStart);
      paramMatrix2.getValues(mEnd);
    }
    
    public void onAnimationUpdate(ValueAnimator paramValueAnimator)
    {
      float f = ((Float)paramValueAnimator.getAnimatedValue()).floatValue();
      int i = 0;
      while (i < 9)
      {
        paramValueAnimator = mResult;
        float[] arrayOfFloat = mStart;
        arrayOfFloat[i] += (mEnd[i] - arrayOfFloat[i]) * f;
        i += 1;
      }
      changeMatrix.setValues(mResult);
      paramValueAnimator = CropPhotoView.this;
      paramValueAnimator.setImageMatrix(changeMatrix);
    }
  }
}
