package com.jd.jdsdk.security;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

public class Base64
{
  private static final byte[] _ORDERED_ALPHABET = { 45, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 };
  private static final byte[] _ORDERED_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 0, -9, -9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -9, -9, -9, -1, -9, -9, -9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, -9, -9, -9, -9, 37, -9, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 };
  private static final byte[] _STANDARD_ALPHABET = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };
  private static final byte[] _STANDARD_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, -9, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, -9, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 };
  private static final byte[] _URL_SAFE_ALPHABET = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 95 };
  private static final byte[] _URL_SAFE_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, 63, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 };
  
  private Base64() {}
  
  public static byte[] decode(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3)
    throws IOException
  {
    if (paramArrayOfByte != null)
    {
      if (paramInt1 >= 0)
      {
        int m = paramInt1 + paramInt2;
        if (m <= paramArrayOfByte.length)
        {
          if (paramInt2 == 0) {
            return new byte[0];
          }
          if (paramInt2 >= 4)
          {
            byte[] arrayOfByte2 = getDecodabet(paramInt3);
            byte[] arrayOfByte1 = new byte[paramInt2 * 3 / 4];
            byte[] arrayOfByte3 = new byte[4];
            int j = 0;
            paramInt2 = 0;
            int i = paramInt1;
            int k;
            for (;;)
            {
              k = paramInt2;
              if (i >= m) {
                break label210;
              }
              int n = arrayOfByte2[(paramArrayOfByte[i] & 0xFF)];
              if (n < -5) {
                break;
              }
              paramInt1 = j;
              k = paramInt2;
              if (n >= -1)
              {
                paramInt1 = j + 1;
                arrayOfByte3[j] = paramArrayOfByte[i];
                if (paramInt1 > 3)
                {
                  k = paramInt2 + decode4to3(arrayOfByte3, 0, arrayOfByte1, paramInt2, paramInt3);
                  if (paramArrayOfByte[i] == 61) {
                    break label210;
                  }
                  paramInt1 = 0;
                }
                else
                {
                  k = paramInt2;
                }
              }
              i += 1;
              j = paramInt1;
              paramInt2 = k;
            }
            throw new IOException(String.format("Bad Base64 input character decimal %d in array position %d", new Object[] { Integer.valueOf(paramArrayOfByte[i] & 0xFF), Integer.valueOf(i) }));
            label210:
            paramArrayOfByte = new byte[k];
            System.arraycopy(arrayOfByte1, 0, paramArrayOfByte, 0, k);
            return paramArrayOfByte;
          }
          paramArrayOfByte = new StringBuilder();
          paramArrayOfByte.append("Base64-encoded string must have at least four characters, but length specified was ");
          paramArrayOfByte.append(paramInt2);
          throw new IllegalArgumentException(paramArrayOfByte.toString());
        }
      }
      throw new IllegalArgumentException(String.format("Source array with length %d cannot have offset of %d and process %d bytes.", new Object[] { Integer.valueOf(paramArrayOfByte.length), Integer.valueOf(paramInt1), Integer.valueOf(paramInt2) }));
    }
    throw new NullPointerException("Cannot decode null source array.");
  }
  
  private static int decode4to3(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3)
  {
    if (paramArrayOfByte1 != null)
    {
      if (paramArrayOfByte2 != null)
      {
        if (paramInt1 >= 0)
        {
          int j = paramInt1 + 3;
          if (j < paramArrayOfByte1.length)
          {
            if (paramInt2 >= 0)
            {
              int i = paramInt2 + 2;
              if (i < paramArrayOfByte2.length)
              {
                byte[] arrayOfByte = getDecodabet(paramInt3);
                paramInt3 = paramInt1 + 2;
                if (paramArrayOfByte1[paramInt3] == 61)
                {
                  paramInt3 = arrayOfByte[paramArrayOfByte1[paramInt1]];
                  paramArrayOfByte2[paramInt2] = ((byte)(((arrayOfByte[paramArrayOfByte1[(paramInt1 + 1)]] & 0xFF) << 12 | (paramInt3 & 0xFF) << 18) >>> 16));
                  return 1;
                }
                if (paramArrayOfByte1[j] == 61)
                {
                  i = arrayOfByte[paramArrayOfByte1[paramInt1]];
                  paramInt1 = arrayOfByte[paramArrayOfByte1[(paramInt1 + 1)]];
                  paramInt1 = (arrayOfByte[paramArrayOfByte1[paramInt3]] & 0xFF) << 6 | (paramInt1 & 0xFF) << 12 | (i & 0xFF) << 18;
                  paramArrayOfByte2[paramInt2] = ((byte)(paramInt1 >>> 16));
                  paramArrayOfByte2[(paramInt2 + 1)] = ((byte)(paramInt1 >>> 8));
                  return 2;
                }
                int k = arrayOfByte[paramArrayOfByte1[paramInt1]];
                paramInt1 = arrayOfByte[paramArrayOfByte1[(paramInt1 + 1)]];
                paramInt3 = arrayOfByte[paramArrayOfByte1[paramInt3]];
                paramInt1 = arrayOfByte[paramArrayOfByte1[j]] & 0xFF | (paramInt1 & 0xFF) << 12 | (k & 0xFF) << 18 | (paramInt3 & 0xFF) << 6;
                paramArrayOfByte2[paramInt2] = ((byte)(paramInt1 >> 16));
                paramArrayOfByte2[(paramInt2 + 1)] = ((byte)(paramInt1 >> 8));
                paramArrayOfByte2[i] = ((byte)paramInt1);
                return 3;
              }
            }
            throw new IllegalArgumentException(String.format("Destination array with length %d cannot have offset of %d and still store three bytes.", new Object[] { Integer.valueOf(paramArrayOfByte2.length), Integer.valueOf(paramInt2) }));
          }
        }
        throw new IllegalArgumentException(String.format("Source array with length %d cannot have offset of %d and still process four bytes.", new Object[] { Integer.valueOf(paramArrayOfByte1.length), Integer.valueOf(paramInt1) }));
      }
      throw new NullPointerException("Destination array was null.");
    }
    throw new NullPointerException("Source array was null.");
  }
  
  public static byte[] decodeBase64(byte[] paramArrayOfByte)
    throws IOException
  {
    return decode(paramArrayOfByte, 0, paramArrayOfByte.length, 0);
  }
  
  public static String encode(byte[] paramArrayOfByte)
  {
    int i = paramArrayOfByte.length;
    try
    {
      paramArrayOfByte = encode(paramArrayOfByte, 0, i, 0);
    }
    catch (IOException paramArrayOfByte)
    {
      if (!$assertionsDisabled) {
        break label43;
      }
    }
    paramArrayOfByte = null;
    if (!$assertionsDisabled)
    {
      if (paramArrayOfByte != null) {
        return paramArrayOfByte;
      }
      throw new AssertionError();
      label43:
      throw new AssertionError(paramArrayOfByte.getMessage());
    }
    return paramArrayOfByte;
  }
  
  public static String encode(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3)
    throws IOException
  {
    paramArrayOfByte = encodeBytesToBytes(paramArrayOfByte, paramInt1, paramInt2, paramInt3);
    try
    {
      String str = new String(paramArrayOfByte, "US-ASCII");
      return str;
    }
    catch (UnsupportedEncodingException localUnsupportedEncodingException)
    {
      for (;;) {}
    }
    return new String(paramArrayOfByte);
  }
  
  private static byte[] encode3to4(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3, int paramInt4)
  {
    byte[] arrayOfByte = getAlphabet(paramInt4);
    int j = 0;
    if (paramInt2 > 0) {
      paramInt4 = paramArrayOfByte1[paramInt1] << 24 >>> 8;
    } else {
      paramInt4 = 0;
    }
    int i;
    if (paramInt2 > 1) {
      i = paramArrayOfByte1[(paramInt1 + 1)] << 24 >>> 16;
    } else {
      i = 0;
    }
    if (paramInt2 > 2) {
      j = paramArrayOfByte1[(paramInt1 + 2)] << 24 >>> 24;
    }
    paramInt1 = paramInt4 | i | j;
    switch (paramInt2)
    {
    default: 
      return paramArrayOfByte2;
    case 3: 
      paramArrayOfByte2[paramInt3] = arrayOfByte[(paramInt1 >>> 18)];
      paramArrayOfByte2[(paramInt3 + 1)] = arrayOfByte[(paramInt1 >>> 12 & 0x3F)];
      paramArrayOfByte2[(paramInt3 + 2)] = arrayOfByte[(paramInt1 >>> 6 & 0x3F)];
      paramArrayOfByte2[(paramInt3 + 3)] = arrayOfByte[(paramInt1 & 0x3F)];
      return paramArrayOfByte2;
    case 2: 
      paramArrayOfByte2[paramInt3] = arrayOfByte[(paramInt1 >>> 18)];
      paramArrayOfByte2[(paramInt3 + 1)] = arrayOfByte[(paramInt1 >>> 12 & 0x3F)];
      paramArrayOfByte2[(paramInt3 + 2)] = arrayOfByte[(paramInt1 >>> 6 & 0x3F)];
      paramArrayOfByte2[(paramInt3 + 3)] = 61;
      return paramArrayOfByte2;
    }
    paramArrayOfByte2[paramInt3] = arrayOfByte[(paramInt1 >>> 18)];
    paramArrayOfByte2[(paramInt3 + 1)] = arrayOfByte[(paramInt1 >>> 12 & 0x3F)];
    paramArrayOfByte2[(paramInt3 + 2)] = 61;
    paramArrayOfByte2[(paramInt3 + 3)] = 61;
    return paramArrayOfByte2;
  }
  
  private static byte[] encode3to4(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2)
  {
    encode3to4(paramArrayOfByte2, 0, paramInt1, paramArrayOfByte1, 0, paramInt2);
    return paramArrayOfByte1;
  }
  
  public static byte[] encodeBytesToBytes(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3)
    throws IOException
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a6 = a5\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n");
  }
  
  private static final byte[] getAlphabet(int paramInt)
  {
    if ((paramInt & 0x10) == 16) {
      return _URL_SAFE_ALPHABET;
    }
    if ((paramInt & 0x20) == 32) {
      return _ORDERED_ALPHABET;
    }
    return _STANDARD_ALPHABET;
  }
  
  private static final byte[] getDecodabet(int paramInt)
  {
    if ((paramInt & 0x10) == 16) {
      return _URL_SAFE_DECODABET;
    }
    if ((paramInt & 0x20) == 32) {
      return _ORDERED_DECODABET;
    }
    return _STANDARD_DECODABET;
  }
  
  public class OutputStream
    extends FilterOutputStream
  {
    private byte[] b4;
    private boolean breakLines;
    private byte[] buffer;
    private int bufferLength;
    private byte[] decodabet;
    private boolean encode;
    private int lineLength;
    private int options;
    private int position;
    private boolean suspendEncoding;
    
    public OutputStream(int paramInt)
    {
      super();
      boolean bool2 = true;
      boolean bool1;
      if ((paramInt & 0x8) != 0) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      breakLines = bool1;
      if ((paramInt & 0x1) != 0) {
        bool1 = bool2;
      } else {
        bool1 = false;
      }
      encode = bool1;
      int i;
      if (encode) {
        i = 3;
      } else {
        i = 4;
      }
      bufferLength = i;
      buffer = new byte[bufferLength];
      position = 0;
      lineLength = 0;
      suspendEncoding = false;
      b4 = new byte[4];
      options = paramInt;
      decodabet = Base64.access$getGetDecodabet(paramInt);
    }
    
    public void close()
      throws IOException
    {
      flushBase64();
      super.close();
      buffer = null;
      out = null;
    }
    
    public void flushBase64()
      throws IOException
    {
      if (position > 0)
      {
        if (encode)
        {
          out.write(Base64.access$getEncode3to4(b4, buffer, position, options));
          position = 0;
          return;
        }
        throw new IOException("Base64 input not properly padded.");
      }
    }
    
    public void write(int paramInt)
      throws IOException
    {
      if (suspendEncoding)
      {
        out.write(paramInt);
        return;
      }
      byte[] arrayOfByte;
      int i;
      if (encode)
      {
        arrayOfByte = buffer;
        i = position;
        position = (i + 1);
        arrayOfByte[i] = ((byte)paramInt);
        if (position >= bufferLength)
        {
          out.write(Base64.access$getEncode3to4(b4, buffer, bufferLength, options));
          lineLength += 4;
          if ((breakLines) && (lineLength >= 76))
          {
            out.write(10);
            lineLength = 0;
          }
          position = 0;
        }
      }
      else
      {
        arrayOfByte = decodabet;
        i = paramInt & 0x7F;
        if (arrayOfByte[i] > -5)
        {
          arrayOfByte = buffer;
          i = position;
          position = (i + 1);
          arrayOfByte[i] = ((byte)paramInt);
          if (position >= bufferLength)
          {
            paramInt = Base64.access$getDecode4to3(arrayOfByte, 0, b4, 0, options);
            out.write(b4, 0, paramInt);
            position = 0;
          }
        }
        else
        {
          if (arrayOfByte[i] == -5) {
            return;
          }
          throw new IOException("Invalid character in Base64 data.");
        }
      }
    }
    
    public void write(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
      throws IOException
    {
      if (suspendEncoding)
      {
        out.write(paramArrayOfByte, paramInt1, paramInt2);
        return;
      }
      int i = 0;
      while (i < paramInt2)
      {
        write(paramArrayOfByte[(paramInt1 + i)]);
        i += 1;
      }
    }
  }
}
