package com.jd.feedback.album.widget.photoview;

import android.animation.TimeInterpolator;
import android.content.Context;
import android.graphics.Matrix;
import android.graphics.Matrix.ScaleToFit;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.View.OnTouchListener;
import android.view.ViewParent;
import android.view.ViewTreeObserver;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.animation.Interpolator;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import com.jd.feedback.album.widget.photoview.adapter.ScrollerProxy;
import com.jd.feedback.album.widget.photoview.gestures.OnGestureListener;
import java.lang.ref.WeakReference;

public final class PhotoViewAttacher
  implements View.OnTouchListener, ViewTreeObserver.OnGlobalLayoutListener, OnGestureListener, VersionedGestureDetector.OnGestureListener
{
  static int SINGLE_TOUCH;
  int ZOOM_DURATION;
  private boolean mAllowParentInterceptOnEdge;
  private final Matrix mBaseMatrix;
  private float mBaseRotation;
  private boolean mBlockParentIntercept;
  private final RectF mDisplayRect;
  private final Matrix mDrawMatrix;
  private Interpolator mEdgeInterpolator;
  private android.view.GestureDetector mGestureDetector;
  private WeakReference<ImageView> mImageView;
  private int mIvBottom;
  private int mIvLeft;
  private int mIvRight;
  private int mIvTop;
  public View.OnLongClickListener mLongClickListener;
  private OnMatrixChangedListener mMatrixChangeListener;
  private final float[] mMatrixValues;
  float mMaxScale;
  float mMidScale;
  float mMinScale;
  OnPhotoTapListener mPhotoTapListener;
  private com.jd.feedback.album.widget.photoview.gestures.GestureDetector mScaleDragDetector;
  private ImageView.ScaleType mScaleType;
  private int mScrollEdge;
  private FlingRunnable mScroller;
  private OnSingleFlingListener mSingleFlingListener;
  private final Matrix mSuppMatrix;
  public OnViewTapListener mViewTapListener;
  private boolean mZoomEnabled;
  
  public PhotoViewAttacher(ImageView paramImageView)
  {
    this(paramImageView, (byte)0);
  }
  
  private PhotoViewAttacher(ImageView paramImageView, byte paramByte) {}
  
  private void cancelFling()
  {
    FlingRunnable localFlingRunnable = mScroller;
    if (localFlingRunnable != null)
    {
      mScroller.forceFinished();
      mScroller = null;
    }
  }
  
  private void checkAndDisplayMatrix()
  {
    if (checkMatrixBounds()) {
      setImageViewMatrix(getDrawMatrix());
    }
  }
  
  private void checkImageViewScaleType()
  {
    ImageView localImageView = getImageView();
    if ((localImageView != null) && (!(localImageView instanceof VersionedGestureDetector.OnGestureListener)))
    {
      if (ImageView.ScaleType.MATRIX.equals(localImageView.getScaleType())) {
        return;
      }
      throw new IllegalStateException("The ImageView's ScaleType has been changed since attaching a PhotoViewAttacher. You should call setScaleType on the PhotoViewAttacher instead of on the ImageView");
    }
  }
  
  private boolean checkMatrixBounds()
  {
    ImageView localImageView = getImageView();
    if (localImageView == null) {
      return false;
    }
    RectF localRectF = getDisplayRect(getDrawMatrix());
    if (localRectF == null) {
      return false;
    }
    float f1 = localRectF.height();
    float f3 = localRectF.width();
    float f4 = getImageViewHeight(localImageView);
    float f2 = 0.0F;
    if (f1 <= f4) {
      switch (2.$SwitchMap$android$widget$ImageView$ScaleType[mScaleType.ordinal()])
      {
      default: 
        f1 = (f4 - f1) / 2.0F - top;
        break;
      case 3: 
        f1 = f4 - f1 - top;
        break;
      case 2: 
        f1 = -top;
        break;
      }
    } else if (top > 0.0F) {
      f1 = -top;
    } else if (bottom < f4) {
      f1 = f4 - bottom;
    } else {
      f1 = 0.0F;
    }
    f4 = getImageViewWidth(localImageView);
    if (f3 <= f4)
    {
      switch (2.$SwitchMap$android$widget$ImageView$ScaleType[mScaleType.ordinal()])
      {
      default: 
        f2 = (f4 - f3) / 2.0F - left;
        break;
      case 3: 
        f2 = f4 - f3 - left;
        break;
      case 2: 
        f2 = -left;
      }
      mScrollEdge = 2;
    }
    else if (left > 0.0F)
    {
      mScrollEdge = 0;
      f2 = -left;
    }
    else if (right < f4)
    {
      f2 = f4 - right;
      mScrollEdge = 1;
    }
    else
    {
      mScrollEdge = -1;
    }
    mSuppMatrix.postTranslate(f2, f1);
    return true;
  }
  
  private void cleanup()
  {
    Object localObject = mImageView;
    if (localObject == null) {
      return;
    }
    localObject = (ImageView)((WeakReference)localObject).get();
    if (localObject != null)
    {
      ViewTreeObserver localViewTreeObserver = ((View)localObject).getViewTreeObserver();
      if ((localViewTreeObserver != null) && (localViewTreeObserver.isAlive())) {
        localViewTreeObserver.removeGlobalOnLayoutListener(this);
      }
      ((View)localObject).setOnTouchListener(null);
      cancelFling();
    }
    localObject = mGestureDetector;
    if (localObject != null) {
      ((android.view.GestureDetector)localObject).setOnDoubleTapListener(null);
    }
    mMatrixChangeListener = null;
    mPhotoTapListener = null;
    mViewTapListener = null;
    mImageView = null;
  }
  
  private RectF getDisplayRect(Matrix paramMatrix)
  {
    Object localObject = getImageView();
    if (localObject != null)
    {
      localObject = ((ImageView)localObject).getDrawable();
      if (localObject != null)
      {
        mDisplayRect.set(0.0F, 0.0F, ((Drawable)localObject).getIntrinsicWidth(), ((Drawable)localObject).getIntrinsicHeight());
        paramMatrix.mapRect(mDisplayRect);
        return mDisplayRect;
      }
    }
    return null;
  }
  
  private Matrix getDrawMatrix()
  {
    mDrawMatrix.set(mBaseMatrix);
    mDrawMatrix.postConcat(mSuppMatrix);
    return mDrawMatrix;
  }
  
  private static int getImageViewHeight(ImageView paramImageView)
  {
    if (paramImageView == null) {
      return 0;
    }
    return paramImageView.getHeight() - paramImageView.getPaddingTop() - paramImageView.getPaddingBottom();
  }
  
  private static int getImageViewWidth(ImageView paramImageView)
  {
    if (paramImageView == null) {
      return 0;
    }
    return paramImageView.getWidth() - paramImageView.getPaddingLeft() - paramImageView.getPaddingRight();
  }
  
  private float getValue(Matrix paramMatrix, int paramInt)
  {
    paramMatrix.getValues(mMatrixValues);
    return mMatrixValues[paramInt];
  }
  
  private void resetMatrix()
  {
    mSuppMatrix.reset();
    setRotationBy(mBaseRotation);
    setImageViewMatrix(getDrawMatrix());
    checkMatrixBounds();
  }
  
  private void setImageViewMatrix(Matrix paramMatrix)
  {
    ImageView localImageView = getImageView();
    if (localImageView != null)
    {
      checkImageViewScaleType();
      localImageView.setImageMatrix(paramMatrix);
      if (mMatrixChangeListener != null) {
        getDisplayRect(paramMatrix);
      }
    }
  }
  
  private static void setImageViewScaleTypeMatrix(ImageView paramImageView)
  {
    if ((paramImageView != null) && (!(paramImageView instanceof VersionedGestureDetector.OnGestureListener)) && (!ImageView.ScaleType.MATRIX.equals(paramImageView.getScaleType()))) {
      paramImageView.setScaleType(ImageView.ScaleType.MATRIX);
    }
  }
  
  private void setRotationBy(float paramFloat)
  {
    mSuppMatrix.postRotate(paramFloat % 360.0F);
    checkAndDisplayMatrix();
  }
  
  private void updateBaseMatrix(Drawable paramDrawable)
  {
    Object localObject = getImageView();
    if (localObject != null)
    {
      if (paramDrawable == null) {
        return;
      }
      float f1 = getImageViewWidth((ImageView)localObject);
      float f2 = getImageViewHeight((ImageView)localObject);
      int i = paramDrawable.getIntrinsicWidth();
      int j = paramDrawable.getIntrinsicHeight();
      mBaseMatrix.reset();
      float f3 = i;
      float f5 = f1 / f3;
      float f4 = j;
      float f6 = f2 / f4;
      if (mScaleType == ImageView.ScaleType.CENTER)
      {
        mBaseMatrix.postTranslate((f1 - f3) / 2.0F, (f2 - f4) / 2.0F);
      }
      else if (mScaleType == ImageView.ScaleType.CENTER_CROP)
      {
        f5 = Math.max(f5, f6);
        mBaseMatrix.postScale(f5, f5);
        mBaseMatrix.postTranslate((f1 - f3 * f5) / 2.0F, (f2 - f4 * f5) / 2.0F);
      }
      else if (mScaleType == ImageView.ScaleType.CENTER_INSIDE)
      {
        f5 = Math.min(1.0F, Math.min(f5, f6));
        mBaseMatrix.postScale(f5, f5);
        mBaseMatrix.postTranslate((f1 - f3 * f5) / 2.0F, (f2 - f4 * f5) / 2.0F);
      }
      else
      {
        paramDrawable = new RectF(0.0F, 0.0F, f3, f4);
        localObject = new RectF(0.0F, 0.0F, f1, f2);
        if ((int)mBaseRotation % 180 != 0) {
          paramDrawable = new RectF(0.0F, 0.0F, f4, f3);
        }
        switch (2.$SwitchMap$android$widget$ImageView$ScaleType[mScaleType.ordinal()])
        {
        default: 
          break;
        case 5: 
          mBaseMatrix.setRectToRect(paramDrawable, (RectF)localObject, Matrix.ScaleToFit.FILL);
          break;
        case 4: 
          mBaseMatrix.setRectToRect(paramDrawable, (RectF)localObject, Matrix.ScaleToFit.CENTER);
          break;
        case 3: 
          mBaseMatrix.setRectToRect(paramDrawable, (RectF)localObject, Matrix.ScaleToFit.END);
          break;
        case 2: 
          mBaseMatrix.setRectToRect(paramDrawable, (RectF)localObject, Matrix.ScaleToFit.START);
        }
      }
      resetMatrix();
    }
  }
  
  public final void fling(float paramFloat1, float paramFloat2)
  {
    ImageView localImageView = getImageView();
    mScroller = new FlingRunnable(localImageView.getContext());
    FlingRunnable localFlingRunnable = mScroller;
    int j = getImageViewWidth(localImageView);
    int n = getImageViewHeight(localImageView);
    int i2 = (int)paramFloat1;
    int i3 = (int)paramFloat2;
    RectF localRectF = this$0.getDisplayRect();
    if (localRectF != null)
    {
      int i = Math.round(-left);
      paramFloat1 = j;
      int k;
      if (paramFloat1 < localRectF.width())
      {
        j = Math.round(localRectF.width() - paramFloat1);
        k = 0;
      }
      else
      {
        k = i;
        j = i;
      }
      int m = Math.round(-top);
      paramFloat1 = n;
      int i1;
      if (paramFloat1 < localRectF.height())
      {
        n = Math.round(localRectF.height() - paramFloat1);
        i1 = 0;
      }
      else
      {
        i1 = m;
        n = m;
      }
      mCurrentX = i;
      mCurrentY = m;
      if ((i != j) || (m != n)) {
        mScroller.fling(i, m, i2, i3, k, j, i1, n);
      }
    }
    localImageView.post(mScroller);
  }
  
  public final RectF getDisplayRect()
  {
    checkMatrixBounds();
    return getDisplayRect(getDrawMatrix());
  }
  
  public final ImageView getImageView()
  {
    Object localObject = mImageView;
    if (localObject != null) {
      localObject = (ImageView)((WeakReference)localObject).get();
    } else {
      localObject = null;
    }
    if (localObject == null) {
      cleanup();
    }
    return localObject;
  }
  
  public final float getScale()
  {
    return (float)Math.sqrt((float)Math.pow(getValue(mSuppMatrix, 0), 2.0D) + (float)Math.pow(getValue(mSuppMatrix, 3), 2.0D));
  }
  
  public final void onDrag(float paramFloat1, float paramFloat2)
  {
    if (mScaleDragDetector.isScaling()) {
      return;
    }
    Object localObject = getImageView();
    mSuppMatrix.postTranslate(paramFloat1, paramFloat2);
    checkAndDisplayMatrix();
    localObject = ((View)localObject).getParent();
    if ((mAllowParentInterceptOnEdge) && (!mScaleDragDetector.isScaling()) && (!mBlockParentIntercept))
    {
      int i = mScrollEdge;
      if (((i == 2) || ((i == 0) && (paramFloat1 >= 1.0F)) || ((mScrollEdge == 1) && (paramFloat1 <= -1.0F))) && (localObject != null)) {
        ((ViewParent)localObject).requestDisallowInterceptTouchEvent(false);
      }
    }
    else if (localObject != null)
    {
      ((ViewParent)localObject).requestDisallowInterceptTouchEvent(true);
    }
  }
  
  public final void onGlobalLayout()
  {
    ImageView localImageView = getImageView();
    if (localImageView != null) {
      if (mZoomEnabled)
      {
        int i = localImageView.getTop();
        int j = localImageView.getRight();
        int k = localImageView.getBottom();
        int m = localImageView.getLeft();
        if ((i != mIvTop) || (k != mIvBottom) || (m != mIvLeft) || (j != mIvRight))
        {
          updateBaseMatrix(localImageView.getDrawable());
          mIvTop = i;
          mIvRight = j;
          mIvBottom = k;
          mIvLeft = m;
        }
      }
      else
      {
        updateBaseMatrix(localImageView.getDrawable());
      }
    }
  }
  
  public final void onScale(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    if (((getScale() < mMaxScale) || (paramFloat1 < 1.0F)) && ((getScale() > mMinScale) || (paramFloat1 > 1.0F)))
    {
      mSuppMatrix.postScale(paramFloat1, paramFloat1, paramFloat2, paramFloat3);
      checkAndDisplayMatrix();
    }
  }
  
  public final boolean onTouch(View paramView, MotionEvent paramMotionEvent)
  {
    boolean bool1 = mZoomEnabled;
    boolean bool2 = false;
    if (bool1)
    {
      Object localObject = (ImageView)paramView;
      int i;
      if ((localObject != null) && (((ImageView)localObject).getDrawable() != null)) {
        i = 1;
      } else {
        i = 0;
      }
      if (i != 0)
      {
        localObject = paramView.getParent();
        i = paramMotionEvent.getAction();
        if (i != 3)
        {
          switch (i)
          {
          default: 
            break;
          case 0: 
            if (localObject != null) {
              ((ViewParent)localObject).requestDisallowInterceptTouchEvent(true);
            }
            cancelFling();
            break;
          }
        }
        else if (getScale() < mMinScale)
        {
          localObject = getDisplayRect();
          if (localObject != null)
          {
            paramView.post(new AnimatedZoomRunnable(getScale(), mMinScale, ((RectF)localObject).centerX(), ((RectF)localObject).centerY()));
            bool1 = true;
            break label177;
          }
        }
        bool1 = false;
        label177:
        paramView = mScaleDragDetector;
        if (paramView != null)
        {
          bool1 = paramView.isScaling();
          boolean bool4 = mScaleDragDetector.isDragging();
          boolean bool3 = mScaleDragDetector.onTouchEvent(paramMotionEvent);
          if ((!bool1) && (!mScaleDragDetector.isScaling())) {
            i = 1;
          } else {
            i = 0;
          }
          int j;
          if ((!bool4) && (!mScaleDragDetector.isDragging())) {
            j = 1;
          } else {
            j = 0;
          }
          bool1 = bool2;
          if (i != 0)
          {
            bool1 = bool2;
            if (j != 0) {
              bool1 = true;
            }
          }
          mBlockParentIntercept = bool1;
          bool1 = bool3;
        }
        paramView = mGestureDetector;
        if ((paramView == null) || (!paramView.onTouchEvent(paramMotionEvent))) {
          break label321;
        }
        return true;
      }
    }
    return false;
    label321:
    return bool1;
  }
  
  public final void setScale(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    ImageView localImageView = getImageView();
    if ((localImageView != null) && (paramFloat1 >= mMinScale))
    {
      if (paramFloat1 > mMaxScale) {
        return;
      }
      localImageView.post(new AnimatedZoomRunnable(getScale(), paramFloat1, paramFloat2, paramFloat3));
    }
  }
  
  public final void update()
  {
    ImageView localImageView = getImageView();
    if (localImageView != null)
    {
      if (mZoomEnabled)
      {
        setImageViewScaleTypeMatrix(localImageView);
        updateBaseMatrix(localImageView.getDrawable());
        return;
      }
      resetMatrix();
    }
  }
  
  final class AnimatedZoomRunnable
    implements Runnable
  {
    private final float mFocalX;
    private final float mFocalY;
    private final long mStartTime;
    private final float mZoomEnd;
    private final float mZoomStart;
    
    public AnimatedZoomRunnable(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
    {
      mFocalX = paramFloat3;
      mFocalY = paramFloat4;
      mStartTime = System.currentTimeMillis();
      mZoomStart = paramFloat1;
      mZoomEnd = paramFloat2;
    }
    
    public final void run()
    {
      ImageView localImageView = getImageView();
      if (localImageView == null) {
        return;
      }
      float f1 = Math.min(1.0F, (float)(System.currentTimeMillis() - mStartTime) * 1.0F / ZOOM_DURATION);
      f1 = PhotoViewAttacher.access$getMImageView(PhotoViewAttacher.this).getInterpolation(f1);
      float f2 = mZoomStart;
      f2 = (f2 + (mZoomEnd - f2) * f1) / getScale();
      onScale(f2, mFocalX, mFocalY);
      if (f1 < 1.0F) {
        ViewCompat.postOnAnimation(localImageView, this);
      }
    }
  }
  
  final class FlingRunnable
    implements Runnable
  {
    int mCurrentX;
    int mCurrentY;
    final ScrollerProxy mScroller;
    
    public FlingRunnable(Context paramContext) {}
    
    public final void run()
    {
      if (mScroller.isFinished()) {
        return;
      }
      ImageView localImageView = this$0.getImageView();
      if ((localImageView != null) && (mScroller.computeScrollOffset()))
      {
        int i = mScroller.getCurrX();
        int j = mScroller.getCurrY();
        PhotoViewAttacher.access$getMSuppMatrix(this$0).postTranslate(mCurrentX - i, mCurrentY - j);
        PhotoViewAttacher localPhotoViewAttacher = this$0;
        PhotoViewAttacher.access$getSetImageViewMatrix(localPhotoViewAttacher, PhotoViewAttacher.getDisplayMatrix(localPhotoViewAttacher));
        mCurrentX = i;
        mCurrentY = j;
        ViewCompat.postOnAnimation(localImageView, this);
      }
    }
  }
  
  public abstract interface OnMatrixChangedListener {}
  
  public abstract interface OnPhotoTapListener {}
  
  public abstract interface OnSingleFlingListener
  {
    public abstract boolean onFling();
  }
  
  public abstract interface OnViewTapListener
  {
    public abstract void onViewTap(View paramView);
  }
}
