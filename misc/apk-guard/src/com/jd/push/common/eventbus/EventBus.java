package com.jd.push.common.eventbus;

import android.os.Looper;
import android.util.Log;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;

public class EventBus
{
  private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();
  public static String TAG;
  static volatile EventBus defaultInstance;
  private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap();
  private final AsyncPoster asyncPoster = new AsyncPoster(this);
  private final BackgroundPoster backgroundPoster = new BackgroundPoster(this);
  private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal()
  {
    protected EventBus.PostingThreadState initialValue()
    {
      return new EventBus.PostingThreadState();
    }
  };
  private final boolean eventInheritance;
  private final ExecutorService executorService;
  private final int indexCount;
  private final boolean logNoSubscriberMessages;
  private final boolean logSubscriberExceptions;
  private final HandlerPoster mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
  private final boolean sendNoSubscriberEvent;
  private final boolean sendSubscriberExceptionEvent;
  private final Map<Class<?>, Object> stickyEvents = new ConcurrentHashMap();
  private final SubscriberMethodFinder subscriberMethodFinder;
  private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType = new HashMap();
  private final boolean throwSubscriberException;
  private final Map<Object, List<Class<?>>> typesBySubscriber = new HashMap();
  
  public EventBus()
  {
    this(DEFAULT_BUILDER);
  }
  
  EventBus(EventBusBuilder paramEventBusBuilder)
  {
    int i;
    if (subscriberInfoIndexes != null) {
      i = subscriberInfoIndexes.size();
    } else {
      i = 0;
    }
    indexCount = i;
    subscriberMethodFinder = new SubscriberMethodFinder(subscriberInfoIndexes, strictMethodVerification, ignoreGeneratedIndex);
    logSubscriberExceptions = logSubscriberExceptions;
    logNoSubscriberMessages = logNoSubscriberMessages;
    sendSubscriberExceptionEvent = sendSubscriberExceptionEvent;
    sendNoSubscriberEvent = sendNoSubscriberEvent;
    throwSubscriberException = throwSubscriberException;
    eventInheritance = eventInheritance;
    executorService = executorService;
  }
  
  static void addInterfaces(List paramList, Class[] paramArrayOfClass)
  {
    int j = paramArrayOfClass.length;
    int i = 0;
    while (i < j)
    {
      Class localClass = paramArrayOfClass[i];
      if (!paramList.contains(localClass))
      {
        paramList.add(localClass);
        addInterfaces(paramList, localClass.getInterfaces());
      }
      i += 1;
    }
  }
  
  public static EventBusBuilder builder()
  {
    return new EventBusBuilder();
  }
  
  private void checkPostStickyEventToSubscription(Subscription paramSubscription, Object paramObject)
  {
    if (paramObject != null)
    {
      boolean bool;
      if (Looper.getMainLooper() == Looper.myLooper()) {
        bool = true;
      } else {
        bool = false;
      }
      postToSubscription(paramSubscription, paramObject, bool);
    }
  }
  
  public static void clearCaches()
  {
    SubscriberMethodFinder.clearCaches();
    eventTypesCache.clear();
  }
  
  public static EventBus getDefault()
  {
    if (defaultInstance == null) {
      try
      {
        if (defaultInstance == null) {
          defaultInstance = new EventBus();
        }
      }
      catch (Throwable localThrowable)
      {
        throw localThrowable;
      }
    }
    return defaultInstance;
  }
  
  private void handleSubscriberException(Subscription paramSubscription, Object paramObject, Throwable paramThrowable)
  {
    String str;
    StringBuilder localStringBuilder;
    if ((paramObject instanceof SubscriberExceptionEvent))
    {
      if (logSubscriberExceptions)
      {
        str = TAG;
        localStringBuilder = new StringBuilder();
        localStringBuilder.append("SubscriberExceptionEvent subscriber ");
        localStringBuilder.append(subscriber.getClass());
        localStringBuilder.append(" threw an exception");
        Log.e(str, localStringBuilder.toString(), paramThrowable);
        paramSubscription = (SubscriberExceptionEvent)paramObject;
        paramObject = TAG;
        paramThrowable = new StringBuilder();
        paramThrowable.append("Initial event ");
        paramThrowable.append(causingEvent);
        paramThrowable.append(" caused exception in ");
        paramThrowable.append(causingSubscriber);
        Log.e(paramObject, paramThrowable.toString(), throwable);
      }
    }
    else if (!throwSubscriberException)
    {
      if (logSubscriberExceptions)
      {
        str = TAG;
        localStringBuilder = new StringBuilder();
        localStringBuilder.append("Could not dispatch event: ");
        localStringBuilder.append(paramObject.getClass());
        localStringBuilder.append(" to subscribing class ");
        localStringBuilder.append(subscriber.getClass());
        Log.e(str, localStringBuilder.toString(), paramThrowable);
      }
      if (sendSubscriberExceptionEvent) {
        post(new SubscriberExceptionEvent(this, paramThrowable, paramObject, subscriber));
      }
    }
    else
    {
      throw new EventBusException("Invoking subscriber failed", paramThrowable);
    }
  }
  
  private static List lookupAllEventTypes(Class paramClass)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a4 = a3\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n");
  }
  
  private void postSingleEvent(Object paramObject, PostingThreadState paramPostingThreadState)
  {
    Class localClass = paramObject.getClass();
    Object localObject;
    if (eventInheritance)
    {
      localObject = lookupAllEventTypes(localClass);
      int j = ((List)localObject).size();
      int i = 0;
      boolean bool1 = false;
      for (;;)
      {
        bool2 = bool1;
        if (i >= j) {
          break;
        }
        bool1 |= postSingleEventForEventType(paramObject, paramPostingThreadState, (Class)((List)localObject).get(i));
        i += 1;
      }
    }
    boolean bool2 = postSingleEventForEventType(paramObject, paramPostingThreadState, localClass);
    if (!bool2)
    {
      if (logNoSubscriberMessages)
      {
        paramPostingThreadState = TAG;
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append("No subscribers registered for event ");
        ((StringBuilder)localObject).append(localClass);
        Log.d(paramPostingThreadState, ((StringBuilder)localObject).toString());
      }
      if ((sendNoSubscriberEvent) && (localClass != NoSubscriberEvent.class) && (localClass != SubscriberExceptionEvent.class)) {
        post(new NoSubscriberEvent(this, paramObject));
      }
    }
  }
  
  private boolean postSingleEventForEventType(Object paramObject, PostingThreadState paramPostingThreadState, Class paramClass)
  {
    try
    {
      paramClass = (CopyOnWriteArrayList)subscriptionsByEventType.get(paramClass);
      if (paramClass != null)
      {
        if (!paramClass.isEmpty())
        {
          paramClass = paramClass.iterator();
          while (paramClass.hasNext())
          {
            Subscription localSubscription = (Subscription)paramClass.next();
            event = paramObject;
            subscription = localSubscription;
            try
            {
              postToSubscription(localSubscription, paramObject, isMainThread);
              boolean bool = canceled;
              event = null;
              subscription = null;
              canceled = false;
              if (!bool) {}
            }
            catch (Throwable paramObject)
            {
              event = null;
              subscription = null;
              canceled = false;
              throw paramObject;
            }
          }
          return true;
        }
      }
      else {
        return false;
      }
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
    return false;
  }
  
  private void postToSubscription(Subscription paramSubscription, Object paramObject, boolean paramBoolean)
  {
    switch (2.$SwitchMap$com$jd$push$common$eventbus$ThreadMode[subscriberMethod.threadMode.ordinal()])
    {
    default: 
      paramObject = new StringBuilder();
      paramObject.append("Unknown thread mode: ");
      paramObject.append(subscriberMethod.threadMode);
      throw new IllegalStateException(paramObject.toString());
    case 4: 
      asyncPoster.enqueue(paramSubscription, paramObject);
      return;
    case 3: 
      if (paramBoolean)
      {
        backgroundPoster.enqueue(paramSubscription, paramObject);
        return;
      }
      break;
    case 2: 
      if (!paramBoolean)
      {
        mainThreadPoster.enqueue(paramSubscription, paramObject);
        return;
      }
      break;
    }
    invokeSubscriber(paramSubscription, paramObject);
  }
  
  private void subscribe(Object paramObject, SubscriberMethod paramSubscriberMethod)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a7 = a6\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n");
  }
  
  private void unsubscribeByEventType(Object paramObject, Class paramClass)
  {
    paramClass = (List)subscriptionsByEventType.get(paramClass);
    if (paramClass != null)
    {
      int j = paramClass.size();
      int i = 0;
      while (i < j)
      {
        Subscription localSubscription = (Subscription)paramClass.get(i);
        int k = j;
        int m = i;
        if (subscriber == paramObject)
        {
          active = false;
          paramClass.remove(i);
          m = i - 1;
          k = j - 1;
        }
        i = m + 1;
        j = k;
      }
    }
  }
  
  public void cancelEventDelivery(Object paramObject)
  {
    PostingThreadState localPostingThreadState = (PostingThreadState)currentPostingThreadState.get();
    if (isPosting)
    {
      if (paramObject != null)
      {
        if (event == paramObject)
        {
          if (subscription.subscriberMethod.threadMode == ThreadMode.POSTING)
          {
            canceled = true;
            return;
          }
          throw new EventBusException(" event handlers may only abort the incoming event");
        }
        throw new EventBusException("Only the currently handled event may be aborted");
      }
      throw new EventBusException("Event may not be null");
    }
    throw new EventBusException("This method may only be called from inside event handling methods on the posting thread");
  }
  
  ExecutorService getExecutorService()
  {
    return executorService;
  }
  
  public Object getStickyEvent(Class paramClass)
  {
    Map localMap = stickyEvents;
    try
    {
      paramClass = paramClass.cast(stickyEvents.get(paramClass));
      return paramClass;
    }
    catch (Throwable paramClass)
    {
      throw paramClass;
    }
  }
  
  public boolean hasSubscriberForEvent(Class paramClass)
  {
    paramClass = lookupAllEventTypes(paramClass);
    if (paramClass != null)
    {
      int j = paramClass.size();
      int i = 0;
      while (i < j)
      {
        Object localObject = (Class)paramClass.get(i);
        try
        {
          localObject = (CopyOnWriteArrayList)subscriptionsByEventType.get(localObject);
          if ((localObject != null) && (!((CopyOnWriteArrayList)localObject).isEmpty())) {
            return true;
          }
          i += 1;
        }
        catch (Throwable paramClass)
        {
          throw paramClass;
        }
      }
    }
    return false;
  }
  
  void invokeSubscriber(PendingPost paramPendingPost)
  {
    Object localObject = event;
    Subscription localSubscription = subscription;
    PendingPost.releasePendingPost(paramPendingPost);
    if (active) {
      invokeSubscriber(localSubscription, localObject);
    }
  }
  
  void invokeSubscriber(Subscription paramSubscription, Object paramObject)
  {
    Method localMethod = subscriberMethod.method;
    Object localObject = subscriber;
    try
    {
      localMethod.invoke(localObject, new Object[] { paramObject });
      return;
    }
    catch (IllegalAccessException paramSubscription)
    {
      throw new IllegalStateException("Unexpected exception", paramSubscription);
    }
    catch (InvocationTargetException localInvocationTargetException)
    {
      handleSubscriberException(paramSubscription, paramObject, localInvocationTargetException.getCause());
    }
  }
  
  public boolean isRegistered(Object paramObject)
  {
    try
    {
      boolean bool = typesBySubscriber.containsKey(paramObject);
      return bool;
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
  }
  
  public void post(Object paramObject)
  {
    PostingThreadState localPostingThreadState = (PostingThreadState)currentPostingThreadState.get();
    List localList = eventQueue;
    localList.add(paramObject);
    if (!isPosting)
    {
      boolean bool;
      if (Looper.getMainLooper() == Looper.myLooper()) {
        bool = true;
      } else {
        bool = false;
      }
      isMainThread = bool;
      isPosting = true;
      if (!canceled) {
        try
        {
          for (;;)
          {
            bool = localList.isEmpty();
            if (bool) {
              break;
            }
            postSingleEvent(localList.remove(0), localPostingThreadState);
          }
          isPosting = false;
          isMainThread = false;
          return;
        }
        catch (Throwable paramObject)
        {
          isPosting = false;
          isMainThread = false;
          throw paramObject;
        }
      }
      throw new EventBusException("Internal error. Abort state was not reset");
    }
  }
  
  public void postSticky(Object paramObject)
  {
    Map localMap = stickyEvents;
    try
    {
      stickyEvents.put(paramObject.getClass(), paramObject);
      post(paramObject);
      return;
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
  }
  
  public void register(Object paramObject)
  {
    Object localObject = paramObject.getClass();
    localObject = subscriberMethodFinder.findSubscriberMethods((Class)localObject);
    try
    {
      localObject = ((List)localObject).iterator();
      while (((Iterator)localObject).hasNext()) {
        subscribe(paramObject, (SubscriberMethod)((Iterator)localObject).next());
      }
      return;
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
  }
  
  public void removeAllStickyEvents()
  {
    Map localMap = stickyEvents;
    try
    {
      stickyEvents.clear();
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public Object removeStickyEvent(Class paramClass)
  {
    Map localMap = stickyEvents;
    try
    {
      paramClass = paramClass.cast(stickyEvents.remove(paramClass));
      return paramClass;
    }
    catch (Throwable paramClass)
    {
      throw paramClass;
    }
  }
  
  public boolean removeStickyEvent(Object paramObject)
  {
    Map localMap = stickyEvents;
    try
    {
      Class localClass = paramObject.getClass();
      if (paramObject.equals(stickyEvents.get(localClass)))
      {
        stickyEvents.remove(localClass);
        return true;
      }
      return false;
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
  }
  
  public String toString()
  {
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("EventBus[indexCount=");
    localStringBuilder.append(indexCount);
    localStringBuilder.append(", eventInheritance=");
    localStringBuilder.append(eventInheritance);
    localStringBuilder.append("]");
    return localStringBuilder.toString();
  }
  
  public void unregister(Object paramObject)
  {
    try
    {
      Object localObject = (List)typesBySubscriber.get(paramObject);
      if (localObject != null)
      {
        localObject = ((List)localObject).iterator();
        while (((Iterator)localObject).hasNext()) {
          unsubscribeByEventType(paramObject, (Class)((Iterator)localObject).next());
        }
        typesBySubscriber.remove(paramObject);
      }
      else
      {
        localObject = TAG;
        StringBuilder localStringBuilder = new StringBuilder();
        localStringBuilder.append("Subscriber to unregister was not registered before: ");
        localStringBuilder.append(paramObject.getClass());
        Log.w((String)localObject, localStringBuilder.toString());
      }
      return;
    }
    catch (Throwable paramObject)
    {
      throw paramObject;
    }
  }
  
  static abstract interface PostCallback
  {
    public abstract void onPostCompleted(List paramList);
  }
  
  static final class PostingThreadState
  {
    boolean canceled;
    Object event;
    final List<Object> eventQueue = new ArrayList();
    boolean isMainThread;
    boolean isPosting;
    Subscription subscription;
    
    PostingThreadState() {}
  }
}
