package com.jd.push.common.eventbus;

import com.jd.push.common.eventbus.meta.SubscriberInfo;
import com.jd.push.common.eventbus.meta.SubscriberInfoIndex;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

class SubscriberMethodFinder
{
  private static final int BRIDGE = 64;
  private static final FindState[] FIND_STATE_POOL = new FindState[4];
  private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap();
  private static final int MODIFIERS_IGNORE = 5192;
  private static final int POOL_SIZE = 4;
  private static final int SYNTHETIC = 4096;
  private final boolean ignoreGeneratedIndex;
  private final boolean strictMethodVerification;
  private List<SubscriberInfoIndex> subscriberInfoIndexes;
  
  SubscriberMethodFinder(List paramList, boolean paramBoolean1, boolean paramBoolean2)
  {
    subscriberInfoIndexes = paramList;
    strictMethodVerification = paramBoolean1;
    ignoreGeneratedIndex = paramBoolean2;
  }
  
  static void clearCaches()
  {
    METHOD_CACHE.clear();
  }
  
  private List findUsingInfo(Class paramClass)
  {
    FindState localFindState = prepareFindState();
    localFindState.initForSubscriber(paramClass);
    while (clazz != null)
    {
      subscriberInfo = getSubscriberInfo(localFindState);
      if (subscriberInfo != null)
      {
        paramClass = subscriberInfo.getSubscriberMethods();
        int j = paramClass.length;
        int i = 0;
        while (i < j)
        {
          Object localObject = paramClass[i];
          if (localFindState.checkAdd(method, eventType)) {
            subscriberMethods.add(localObject);
          }
          i += 1;
        }
      }
      findUsingReflectionInSingleClass(localFindState);
      localFindState.moveToSuperclass();
    }
    return getMethodsAndRelease(localFindState);
  }
  
  private List findUsingReflection(Class paramClass)
  {
    FindState localFindState = prepareFindState();
    localFindState.initForSubscriber(paramClass);
    while (clazz != null)
    {
      findUsingReflectionInSingleClass(localFindState);
      localFindState.moveToSuperclass();
    }
    return getMethodsAndRelease(localFindState);
  }
  
  private void findUsingReflectionInSingleClass(FindState paramFindState)
  {
    try
    {
      localObject1 = clazz.getDeclaredMethods();
    }
    catch (Throwable localThrowable)
    {
      Object localObject1;
      int j;
      int i;
      for (;;) {}
    }
    localObject1 = clazz.getMethods();
    skipSuperClasses = true;
    j = localObject1.length;
    i = 0;
    while (i < j)
    {
      Method localMethod = localObject1[i];
      int k = localMethod.getModifiers();
      if (((k & 0x1) != 0) && ((k & 0x1448) == 0))
      {
        Object localObject2 = localMethod.getParameterTypes();
        if (localObject2.length == 1)
        {
          Subscribe localSubscribe = (Subscribe)localMethod.getAnnotation(Subscribe.class);
          if (localSubscribe != null)
          {
            localObject2 = localObject2[0];
            if (paramFindState.checkAdd(localMethod, (Class)localObject2))
            {
              ThreadMode localThreadMode = localSubscribe.threadMode();
              subscriberMethods.add(new SubscriberMethod(localMethod, (Class)localObject2, localThreadMode, localSubscribe.priority(), localSubscribe.sticky()));
            }
          }
        }
        else if ((strictMethodVerification) && (localMethod.isAnnotationPresent(Subscribe.class)))
        {
          paramFindState = new StringBuilder();
          paramFindState.append(localMethod.getDeclaringClass().getName());
          paramFindState.append(".");
          paramFindState.append(localMethod.getName());
          paramFindState = paramFindState.toString();
          localObject1 = new StringBuilder();
          ((StringBuilder)localObject1).append("@Subscribe method ");
          ((StringBuilder)localObject1).append(paramFindState);
          ((StringBuilder)localObject1).append("must have exactly 1 parameter but has ");
          ((StringBuilder)localObject1).append(localObject2.length);
          throw new EventBusException(((StringBuilder)localObject1).toString());
        }
      }
      else if ((strictMethodVerification) && (localMethod.isAnnotationPresent(Subscribe.class)))
      {
        paramFindState = new StringBuilder();
        paramFindState.append(localMethod.getDeclaringClass().getName());
        paramFindState.append(".");
        paramFindState.append(localMethod.getName());
        paramFindState = paramFindState.toString();
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append(paramFindState);
        ((StringBuilder)localObject1).append(" is a illegal @Subscribe method: must be public, non-static, and non-abstract");
        throw new EventBusException(((StringBuilder)localObject1).toString());
      }
      i += 1;
    }
  }
  
  private List getMethodsAndRelease(FindState paramFindState)
  {
    ArrayList localArrayList = new ArrayList(subscriberMethods);
    paramFindState.recycle();
    FindState[] arrayOfFindState = FIND_STATE_POOL;
    int i = 0;
    for (;;)
    {
      if (i < 4) {}
      try
      {
        if (FIND_STATE_POOL[i] == null)
        {
          FIND_STATE_POOL[i] = paramFindState;
          return localArrayList;
        }
      }
      catch (Throwable paramFindState)
      {
        throw paramFindState;
      }
      i += 1;
    }
  }
  
  private SubscriberInfo getSubscriberInfo(FindState paramFindState)
  {
    if ((subscriberInfo != null) && (subscriberInfo.getSuperSubscriberInfo() != null))
    {
      localObject = subscriberInfo.getSuperSubscriberInfo();
      if (clazz == ((SubscriberInfo)localObject).getSubscriberClass()) {
        return localObject;
      }
    }
    Object localObject = subscriberInfoIndexes;
    if (localObject != null)
    {
      localObject = ((List)localObject).iterator();
      while (((Iterator)localObject).hasNext())
      {
        SubscriberInfo localSubscriberInfo = ((SubscriberInfoIndex)((Iterator)localObject).next()).getSubscriberInfo(clazz);
        if (localSubscriberInfo != null) {
          return localSubscriberInfo;
        }
      }
    }
    return null;
  }
  
  private FindState prepareFindState()
  {
    arrayOfFindState = FIND_STATE_POOL;
    int i = 0;
    for (;;)
    {
      if (i < 4) {}
      try
      {
        FindState localFindState = FIND_STATE_POOL[i];
        if (localFindState != null)
        {
          FIND_STATE_POOL[i] = null;
          return localFindState;
        }
        i += 1;
      }
      catch (Throwable localThrowable)
      {
        throw localThrowable;
      }
    }
    return new FindState();
  }
  
  List findSubscriberMethods(Class paramClass)
  {
    Object localObject = (List)METHOD_CACHE.get(paramClass);
    if (localObject != null) {
      return localObject;
    }
    if (ignoreGeneratedIndex) {
      localObject = findUsingReflection(paramClass);
    } else {
      localObject = findUsingInfo(paramClass);
    }
    if (!((List)localObject).isEmpty())
    {
      METHOD_CACHE.put(paramClass, localObject);
      return localObject;
    }
    localObject = new StringBuilder();
    ((StringBuilder)localObject).append("Subscriber ");
    ((StringBuilder)localObject).append(paramClass);
    ((StringBuilder)localObject).append(" and its super classes have no public methods with the @Subscribe annotation");
    throw new EventBusException(((StringBuilder)localObject).toString());
  }
  
  static class FindState
  {
    final Map<Class, Object> anyMethodByEventType = new HashMap();
    Class<?> clazz;
    final StringBuilder methodKeyBuilder = new StringBuilder(128);
    boolean skipSuperClasses;
    Class<?> subscriberClass;
    final Map<String, Class> subscriberClassByMethodKey = new HashMap();
    SubscriberInfo subscriberInfo;
    final List<SubscriberMethod> subscriberMethods = new ArrayList();
    
    FindState() {}
    
    private boolean checkAddWithMethodSignature(Method paramMethod, Class paramClass)
    {
      methodKeyBuilder.setLength(0);
      methodKeyBuilder.append(paramMethod.getName());
      Object localObject = methodKeyBuilder;
      ((StringBuilder)localObject).append('>');
      ((StringBuilder)localObject).append(paramClass.getName());
      paramClass = methodKeyBuilder.toString();
      paramMethod = paramMethod.getDeclaringClass();
      localObject = (Class)subscriberClassByMethodKey.put(paramClass, paramMethod);
      if ((localObject != null) && (!((Class)localObject).isAssignableFrom(paramMethod)))
      {
        subscriberClassByMethodKey.put(paramClass, localObject);
        return false;
      }
      return true;
    }
    
    boolean checkAdd(Method paramMethod, Class paramClass)
    {
      Object localObject = anyMethodByEventType.put(paramClass, paramMethod);
      if (localObject == null) {
        return true;
      }
      if ((localObject instanceof Method)) {
        if (checkAddWithMethodSignature((Method)localObject, paramClass)) {
          anyMethodByEventType.put(paramClass, this);
        } else {
          throw new IllegalStateException();
        }
      }
      return checkAddWithMethodSignature(paramMethod, paramClass);
    }
    
    void initForSubscriber(Class paramClass)
    {
      clazz = paramClass;
      subscriberClass = paramClass;
      skipSuperClasses = false;
      subscriberInfo = null;
    }
    
    void moveToSuperclass()
    {
      if (skipSuperClasses) {}
      String str;
      do
      {
        clazz = null;
        return;
        clazz = clazz.getSuperclass();
        str = clazz.getName();
      } while ((str.startsWith("java.")) || (str.startsWith("javax.")) || (str.startsWith("android.")));
    }
    
    void recycle()
    {
      subscriberMethods.clear();
      anyMethodByEventType.clear();
      subscriberClassByMethodKey.clear();
      methodKeyBuilder.setLength(0);
      subscriberClass = null;
      clazz = null;
      skipSuperClasses = false;
      subscriberInfo = null;
    }
  }
}
