package com.jingdong.aura.core.reflection;

import com.jingdong.aura.core.runing.Label;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Hack
{
  private static a j;
  
  private static void b(Hack.HackDeclaration.HackAssertionException paramHackAssertionException)
  {
    a localA = j;
    if ((localA != null) && (localA.b(paramHackAssertionException))) {
      return;
    }
    throw paramHackAssertionException;
  }
  
  public static void b(a paramA)
  {
    j = paramA;
  }
  
  public static b getString(Class paramClass)
  {
    return new b(paramClass);
  }
  
  public static b valueOf(String paramString)
  {
    try
    {
      paramString = new b(Class.forName(paramString));
      return paramString;
    }
    catch (Exception paramString)
    {
      b(new Hack.HackDeclaration.HackAssertionException(paramString));
    }
    return new b(null);
  }
  
  public static abstract class HackDeclaration
  {
    public HackDeclaration() {}
    
    public static class HackAssertionException
      extends Throwable
    {
      private static final long serialVersionUID = 1L;
      private Class<?> mHackedClass;
      private String mHackedFieldName;
      private String mHackedMethodName;
      
      public HackAssertionException(Exception paramException)
      {
        super();
      }
      
      public HackAssertionException(String paramString)
      {
        super();
      }
      
      public Class getHackedClass()
      {
        return mHackedClass;
      }
      
      public String getHackedFieldName()
      {
        return mHackedFieldName;
      }
      
      public String getHackedMethodName()
      {
        return mHackedMethodName;
      }
      
      public void setHackedClass(Class paramClass)
      {
        mHackedClass = paramClass;
      }
      
      public void setHackedFieldName(String paramString)
      {
        mHackedFieldName = paramString;
      }
      
      public void setHackedMethodName(String paramString)
      {
        mHackedMethodName = paramString;
      }
      
      public String toString()
      {
        if (getCause() != null)
        {
          StringBuilder localStringBuilder = new StringBuilder();
          localStringBuilder.append(getClass().getName());
          localStringBuilder.append(": ");
          localStringBuilder.append(getCause());
          return localStringBuilder.toString();
        }
        return super.toString();
      }
    }
  }
  
  public static abstract interface a
  {
    public abstract boolean b(Hack.HackDeclaration.HackAssertionException paramHackAssertionException);
  }
  
  public static class b<C>
  {
    protected Class<C> c;
    
    public b(Class paramClass)
    {
      c = paramClass;
    }
    
    public Hack.e a(String paramString, Class... paramVarArgs)
    {
      return new Hack.e(c, paramString, paramVarArgs, 0);
    }
    
    public Hack.d get(String paramString)
    {
      return new Hack.d(c, paramString, 8);
    }
    
    public Class get()
    {
      return c;
    }
    
    public Hack.c toString(Class... paramVarArgs)
    {
      return new Hack.c(c, paramVarArgs);
    }
    
    public Hack.d toString(String paramString)
    {
      return new Hack.d(c, paramString, 0);
    }
  }
  
  public static class c
  {
    protected Constructor<?> factory;
    
    c(Class paramClass, Class[] paramArrayOfClass)
    {
      if (paramClass != null) {
        try
        {
          paramArrayOfClass = paramClass.getDeclaredConstructor(paramArrayOfClass);
          factory = paramArrayOfClass;
          return;
        }
        catch (Exception paramArrayOfClass)
        {
          paramArrayOfClass = new Hack.HackDeclaration.HackAssertionException(paramArrayOfClass);
          paramArrayOfClass.setHackedClass(paramClass);
          Hack.d(paramArrayOfClass);
        }
      }
    }
    
    public Object get(Object... paramVarArgs)
    {
      factory.setAccessible(true);
      Constructor localConstructor = factory;
      try
      {
        paramVarArgs = localConstructor.newInstance(paramVarArgs);
        return paramVarArgs;
      }
      catch (Exception paramVarArgs)
      {
        paramVarArgs.printStackTrace();
      }
      return null;
    }
  }
  
  public static class d<C, T>
  {
    private final Field c;
    
    d(Class paramClass, String paramString, int paramInt)
    {
      Object localObject1 = null;
      Object localObject2 = null;
      if (paramClass == null)
      {
        c = null;
        return;
      }
      try
      {
        Field localField2 = paramClass.getDeclaredField(paramString);
        Field localField1 = localField2;
        if (paramInt > 0)
        {
          localObject2 = localField1;
          localObject1 = localField1;
          int i = localField2.getModifiers();
          if ((i & paramInt) != paramInt)
          {
            localObject2 = localField1;
            localObject1 = localField1;
            StringBuilder localStringBuilder = new StringBuilder();
            localObject2 = localField1;
            localObject1 = localField1;
            localStringBuilder.append(localField2);
            localObject2 = localField1;
            localObject1 = localField1;
            localStringBuilder.append(" does not match modifiers: ");
            localObject2 = localField1;
            localObject1 = localField1;
            localStringBuilder.append(paramInt);
            localObject2 = localField1;
            localObject1 = localField1;
            Hack.d(new Hack.HackDeclaration.HackAssertionException(localStringBuilder.toString()));
          }
        }
        localObject2 = localField1;
        localObject1 = localField1;
        localField2.setAccessible(true);
        localObject1 = localField1;
      }
      catch (Throwable paramClass) {}catch (Exception localException)
      {
        for (;;)
        {
          localObject2 = localObject1;
          Hack.HackDeclaration.HackAssertionException localHackAssertionException = new Hack.HackDeclaration.HackAssertionException(localException);
          localObject2 = localObject1;
          localHackAssertionException.setHackedClass(paramClass);
          localObject2 = localObject1;
          localHackAssertionException.setHackedFieldName(paramString);
          localObject2 = localObject1;
          Hack.d(localHackAssertionException);
        }
      }
      c = localObject1;
      return;
      c = localObject2;
      throw paramClass;
    }
    
    public void a(Object paramObject, StateMachineInvocationHandler paramStateMachineInvocationHandler)
    {
      Object localObject = get(paramObject);
      if (localObject != null)
      {
        get(paramObject, Type.create(localObject, paramStateMachineInvocationHandler, localObject.getClass().getInterfaces()));
        return;
      }
      throw new IllegalStateException("Cannot hijack null");
    }
    
    public d get(Class paramClass)
    {
      Object localObject = c;
      if ((localObject != null) && (!paramClass.isAssignableFrom(((Field)localObject).getType())))
      {
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append(c);
        ((StringBuilder)localObject).append(" is not of type ");
        ((StringBuilder)localObject).append(paramClass);
        Hack.d(new Hack.HackDeclaration.HackAssertionException(new ClassCastException(((StringBuilder)localObject).toString())));
      }
      return this;
    }
    
    public Object get(Object paramObject)
    {
      Field localField = c;
      try
      {
        paramObject = localField.get(paramObject);
        return paramObject;
      }
      catch (IllegalAccessException paramObject)
      {
        paramObject.printStackTrace();
      }
      return null;
    }
    
    public void get(Object paramObject1, Object paramObject2)
    {
      try
      {
        c.set(paramObject1, paramObject2);
        return;
      }
      catch (Throwable paramObject1)
      {
        paramObject1.printStackTrace();
        if (!(paramObject2 instanceof Label)) {
          return;
        }
        throw new RuntimeException("set DelegateClassLoader fail", paramObject1);
      }
    }
    
    public Field p()
    {
      return c;
    }
    
    public d read(Class paramClass)
    {
      Object localObject = c;
      if ((localObject != null) && (!paramClass.isAssignableFrom(((Field)localObject).getType())))
      {
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append(c);
        ((StringBuilder)localObject).append(" is not of type ");
        ((StringBuilder)localObject).append(paramClass);
        Hack.d(new Hack.HackDeclaration.HackAssertionException(new ClassCastException(((StringBuilder)localObject).toString())));
      }
      return this;
    }
  }
  
  public static class e
  {
    protected final Method d;
    
    e(Class paramClass, String paramString, Class[] paramArrayOfClass, int paramInt)
    {
      Class[] arrayOfClass1 = null;
      Class[] arrayOfClass2 = null;
      if (paramClass == null)
      {
        d = null;
        return;
      }
      try
      {
        Method localMethod = paramClass.getDeclaredMethod(paramString, paramArrayOfClass);
        paramArrayOfClass = localMethod;
        if (paramInt > 0)
        {
          arrayOfClass2 = paramArrayOfClass;
          arrayOfClass1 = paramArrayOfClass;
          int i = localMethod.getModifiers();
          if ((i & paramInt) != paramInt)
          {
            arrayOfClass2 = paramArrayOfClass;
            arrayOfClass1 = paramArrayOfClass;
            StringBuilder localStringBuilder = new StringBuilder();
            arrayOfClass2 = paramArrayOfClass;
            arrayOfClass1 = paramArrayOfClass;
            localStringBuilder.append(localMethod);
            arrayOfClass2 = paramArrayOfClass;
            arrayOfClass1 = paramArrayOfClass;
            localStringBuilder.append(" does not match modifiers: ");
            arrayOfClass2 = paramArrayOfClass;
            arrayOfClass1 = paramArrayOfClass;
            localStringBuilder.append(paramInt);
            arrayOfClass2 = paramArrayOfClass;
            arrayOfClass1 = paramArrayOfClass;
            Hack.d(new Hack.HackDeclaration.HackAssertionException(localStringBuilder.toString()));
          }
        }
        arrayOfClass2 = paramArrayOfClass;
        arrayOfClass1 = paramArrayOfClass;
        localMethod.setAccessible(true);
      }
      catch (Throwable paramClass) {}catch (Exception paramArrayOfClass)
      {
        for (;;)
        {
          arrayOfClass2 = arrayOfClass1;
          paramArrayOfClass = new Hack.HackDeclaration.HackAssertionException(paramArrayOfClass);
          arrayOfClass2 = arrayOfClass1;
          paramArrayOfClass.setHackedClass(paramClass);
          arrayOfClass2 = arrayOfClass1;
          paramArrayOfClass.setHackedMethodName(paramString);
          arrayOfClass2 = arrayOfClass1;
          Hack.d(paramArrayOfClass);
          paramArrayOfClass = arrayOfClass1;
        }
      }
      d = paramArrayOfClass;
      return;
      d = arrayOfClass2;
      throw paramClass;
    }
    
    public Object a(Object paramObject, Object... paramVarArgs)
    {
      Method localMethod = d;
      try
      {
        paramObject = localMethod.invoke(paramObject, paramVarArgs);
        return paramObject;
      }
      catch (IllegalAccessException paramObject)
      {
        paramObject.printStackTrace();
      }
      return null;
    }
  }
}
