package com.facebook.fresco.animation.backend;

import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import com.facebook.common.internal.VisibleForTesting;
import com.facebook.common.time.MonotonicClock;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

public class AnimationBackendDelegateWithInactivityCheck<T extends AnimationBackend>
  extends AnimationBackendDelegate<T>
{
  @VisibleForTesting
  static final long INACTIVITY_CHECK_POLLING_TIME_MS = 1000L;
  @VisibleForTesting
  static final long INACTIVITY_THRESHOLD_MS = 2000L;
  private long mInactivityCheckPollingTimeMs = 1000L;
  private boolean mInactivityCheckScheduled = false;
  @Nullable
  private InactivityListener mInactivityListener;
  private long mInactivityThresholdMs = 2000L;
  private final Runnable mIsInactiveCheck = new Runnable()
  {
    public void run()
    {
      AnimationBackendDelegateWithInactivityCheck localAnimationBackendDelegateWithInactivityCheck = AnimationBackendDelegateWithInactivityCheck.this;
      try
      {
        AnimationBackendDelegateWithInactivityCheck.access$002(AnimationBackendDelegateWithInactivityCheck.this, false);
        if (AnimationBackendDelegateWithInactivityCheck.this.isInactive())
        {
          if (mInactivityListener != null) {
            mInactivityListener.onInactive();
          }
        }
        else {
          AnimationBackendDelegateWithInactivityCheck.this.maybeScheduleInactivityCheck();
        }
        return;
      }
      catch (Throwable localThrowable)
      {
        throw localThrowable;
      }
    }
  };
  private long mLastDrawnTimeMs;
  private final MonotonicClock mMonotonicClock;
  private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
  
  private AnimationBackendDelegateWithInactivityCheck(AnimationBackend paramAnimationBackend, InactivityListener paramInactivityListener, MonotonicClock paramMonotonicClock, ScheduledExecutorService paramScheduledExecutorService)
  {
    super(paramAnimationBackend);
    mInactivityListener = paramInactivityListener;
    mMonotonicClock = paramMonotonicClock;
    mScheduledExecutorServiceForUiThread = paramScheduledExecutorService;
  }
  
  public static AnimationBackendDelegate createForBackend(AnimationBackend paramAnimationBackend, MonotonicClock paramMonotonicClock, ScheduledExecutorService paramScheduledExecutorService)
  {
    return createForBackend(paramAnimationBackend, (InactivityListener)paramAnimationBackend, paramMonotonicClock, paramScheduledExecutorService);
  }
  
  public static AnimationBackendDelegate createForBackend(AnimationBackend paramAnimationBackend, InactivityListener paramInactivityListener, MonotonicClock paramMonotonicClock, ScheduledExecutorService paramScheduledExecutorService)
  {
    return new AnimationBackendDelegateWithInactivityCheck(paramAnimationBackend, paramInactivityListener, paramMonotonicClock, paramScheduledExecutorService);
  }
  
  private boolean isInactive()
  {
    return mMonotonicClock.now() - mLastDrawnTimeMs > mInactivityThresholdMs;
  }
  
  private void maybeScheduleInactivityCheck()
  {
    try
    {
      if (!mInactivityCheckScheduled)
      {
        mInactivityCheckScheduled = true;
        mScheduledExecutorServiceForUiThread.schedule(mIsInactiveCheck, mInactivityCheckPollingTimeMs, TimeUnit.MILLISECONDS);
      }
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public boolean drawFrame(Drawable paramDrawable, Canvas paramCanvas, int paramInt)
  {
    mLastDrawnTimeMs = mMonotonicClock.now();
    boolean bool = super.drawFrame(paramDrawable, paramCanvas, paramInt);
    maybeScheduleInactivityCheck();
    return bool;
  }
  
  public long getInactivityCheckPollingTimeMs()
  {
    return mInactivityCheckPollingTimeMs;
  }
  
  public long getInactivityThresholdMs()
  {
    return mInactivityThresholdMs;
  }
  
  public void setInactivityCheckPollingTimeMs(long paramLong)
  {
    mInactivityCheckPollingTimeMs = paramLong;
  }
  
  public void setInactivityListener(InactivityListener paramInactivityListener)
  {
    mInactivityListener = paramInactivityListener;
  }
  
  public void setInactivityThresholdMs(long paramLong)
  {
    mInactivityThresholdMs = paramLong;
  }
  
  public static abstract interface InactivityListener
  {
    public abstract void onInactive();
  }
}
