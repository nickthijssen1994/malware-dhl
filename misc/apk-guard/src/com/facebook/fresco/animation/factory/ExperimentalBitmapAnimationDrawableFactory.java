package com.facebook.fresco.animation.factory;

import android.graphics.Bitmap.Config;
import android.graphics.Rect;
import com.facebook.cache.common.CacheKey;
import com.facebook.common.internal.Supplier;
import com.facebook.common.time.MonotonicClock;
import com.facebook.fresco.animation.backend.AnimationBackend;
import com.facebook.fresco.animation.backend.AnimationBackendDelegateWithInactivityCheck;
import com.facebook.fresco.animation.bitmap.BitmapAnimationBackend;
import com.facebook.fresco.animation.bitmap.BitmapFrameCache;
import com.facebook.fresco.animation.bitmap.BitmapFrameRenderer;
import com.facebook.fresco.animation.bitmap.cache.AnimationFrameCacheKey;
import com.facebook.fresco.animation.bitmap.cache.FrescoFrameCache;
import com.facebook.fresco.animation.bitmap.cache.KeepLastFrameCache;
import com.facebook.fresco.animation.bitmap.cache.NoOpCache;
import com.facebook.fresco.animation.bitmap.preparation.BitmapFramePreparer;
import com.facebook.fresco.animation.bitmap.preparation.DefaultBitmapFramePreparer;
import com.facebook.fresco.animation.bitmap.preparation.FixedNumberBitmapFramePreparationStrategy;
import com.facebook.fresco.animation.bitmap.wrapper.AnimatedDrawableBackendAnimationInformation;
import com.facebook.fresco.animation.bitmap.wrapper.AnimatedDrawableBackendFrameRenderer;
import com.facebook.fresco.animation.drawable.AnimatedDrawable2;
import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
import com.facebook.imagepipeline.animated.base.AnimatedImage;
import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
import com.facebook.imagepipeline.animated.impl.AnimatedFrameCache;
import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
import com.facebook.imagepipeline.cache.CountingMemoryCache;
import com.facebook.imagepipeline.drawable.DrawableFactory;
import com.facebook.imagepipeline.image.CloseableAnimatedImage;
import com.facebook.imagepipeline.image.CloseableImage;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;

public class ExperimentalBitmapAnimationDrawableFactory
  implements DrawableFactory
{
  public static final int CACHING_STRATEGY_FRESCO_CACHE = 1;
  public static final int CACHING_STRATEGY_FRESCO_CACHE_NO_REUSING = 2;
  public static final int CACHING_STRATEGY_KEEP_LAST_CACHE = 3;
  public static final int CACHING_STRATEGY_NO_CACHE = 0;
  private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
  private final CountingMemoryCache<CacheKey, CloseableImage> mBackingCache;
  private final Supplier<Integer> mCachingStrategySupplier;
  private final ExecutorService mExecutorServiceForFramePreparing;
  private final MonotonicClock mMonotonicClock;
  private final Supplier<Integer> mNumberOfFramesToPrepareSupplier;
  private final PlatformBitmapFactory mPlatformBitmapFactory;
  private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
  
  public ExperimentalBitmapAnimationDrawableFactory(AnimatedDrawableBackendProvider paramAnimatedDrawableBackendProvider, ScheduledExecutorService paramScheduledExecutorService, ExecutorService paramExecutorService, MonotonicClock paramMonotonicClock, PlatformBitmapFactory paramPlatformBitmapFactory, CountingMemoryCache paramCountingMemoryCache, Supplier paramSupplier1, Supplier paramSupplier2)
  {
    mAnimatedDrawableBackendProvider = paramAnimatedDrawableBackendProvider;
    mScheduledExecutorServiceForUiThread = paramScheduledExecutorService;
    mExecutorServiceForFramePreparing = paramExecutorService;
    mMonotonicClock = paramMonotonicClock;
    mPlatformBitmapFactory = paramPlatformBitmapFactory;
    mBackingCache = paramCountingMemoryCache;
    mCachingStrategySupplier = paramSupplier1;
    mNumberOfFramesToPrepareSupplier = paramSupplier2;
  }
  
  private AnimatedDrawableBackend createAnimatedDrawableBackend(AnimatedImageResult paramAnimatedImageResult)
  {
    Object localObject = paramAnimatedImageResult.getImage();
    localObject = new Rect(0, 0, ((AnimatedImage)localObject).getWidth(), ((AnimatedImage)localObject).getHeight());
    return mAnimatedDrawableBackendProvider.getMap(paramAnimatedImageResult, (Rect)localObject);
  }
  
  private AnimatedFrameCache createAnimatedFrameCache(AnimatedImageResult paramAnimatedImageResult)
  {
    return new AnimatedFrameCache(new AnimationFrameCacheKey(paramAnimatedImageResult.hashCode()), mBackingCache);
  }
  
  private AnimationBackend createAnimationBackend(AnimatedImageResult paramAnimatedImageResult)
  {
    AnimatedDrawableBackend localAnimatedDrawableBackend = createAnimatedDrawableBackend(paramAnimatedImageResult);
    BitmapFrameCache localBitmapFrameCache = createBitmapFrameCache(paramAnimatedImageResult);
    AnimatedDrawableBackendFrameRenderer localAnimatedDrawableBackendFrameRenderer = new AnimatedDrawableBackendFrameRenderer(localBitmapFrameCache, localAnimatedDrawableBackend);
    int i = ((Integer)mNumberOfFramesToPrepareSupplier.getFolder()).intValue();
    BitmapFramePreparer localBitmapFramePreparer;
    if (i > 0)
    {
      paramAnimatedImageResult = new FixedNumberBitmapFramePreparationStrategy(i);
      localBitmapFramePreparer = createBitmapFramePreparer(localAnimatedDrawableBackendFrameRenderer);
    }
    else
    {
      paramAnimatedImageResult = null;
      localBitmapFramePreparer = null;
    }
    return AnimationBackendDelegateWithInactivityCheck.createForBackend(new BitmapAnimationBackend(mPlatformBitmapFactory, localBitmapFrameCache, new AnimatedDrawableBackendAnimationInformation(localAnimatedDrawableBackend), localAnimatedDrawableBackendFrameRenderer, paramAnimatedImageResult, localBitmapFramePreparer), mMonotonicClock, mScheduledExecutorServiceForUiThread);
  }
  
  private BitmapFrameCache createBitmapFrameCache(AnimatedImageResult paramAnimatedImageResult)
  {
    switch (((Integer)mCachingStrategySupplier.getFolder()).intValue())
    {
    default: 
      return new NoOpCache();
    case 3: 
      return new KeepLastFrameCache();
    case 2: 
      return new FrescoFrameCache(createAnimatedFrameCache(paramAnimatedImageResult), false);
    }
    return new FrescoFrameCache(createAnimatedFrameCache(paramAnimatedImageResult), true);
  }
  
  private BitmapFramePreparer createBitmapFramePreparer(BitmapFrameRenderer paramBitmapFrameRenderer)
  {
    return new DefaultBitmapFramePreparer(mPlatformBitmapFactory, paramBitmapFrameRenderer, Bitmap.Config.ARGB_8888, mExecutorServiceForFramePreparing);
  }
  
  public AnimatedDrawable2 createDrawable(CloseableImage paramCloseableImage)
  {
    return new AnimatedDrawable2(createAnimationBackend(((CloseableAnimatedImage)paramCloseableImage).getImageResult()));
  }
  
  public boolean supportsImageType(CloseableImage paramCloseableImage)
  {
    return paramCloseableImage instanceof CloseableAnimatedImage;
  }
}
