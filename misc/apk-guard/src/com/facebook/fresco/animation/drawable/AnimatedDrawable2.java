package com.facebook.fresco.animation.drawable;

import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Rect;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;
import com.facebook.common.logging.FLog;
import com.facebook.drawable.base.DrawableWithCaches;
import com.facebook.drawee.drawable.DrawableProperties;
import com.facebook.fresco.animation.backend.AnimationBackend;
import com.facebook.fresco.animation.backend.AnimationInformation;
import com.facebook.fresco.animation.frame.DropFramesFrameScheduler;
import com.facebook.fresco.animation.frame.FrameScheduler;
import javax.annotation.Nullable;

public class AnimatedDrawable2
  extends Drawable
  implements Animatable, DrawableWithCaches
{
  private static final int DEFAULT_FRAME_SCHEDULING_DELAY_MS = 8;
  private static final int DEFAULT_FRAME_SCHEDULING_OFFSET_MS = 0;
  private static final AnimationListener NO_OP_LISTENER = new BaseAnimationListener();
  private static final Class<?> SHORT = AnimatedDrawable2.class;
  @Nullable
  private AnimationBackend mAnimationBackend;
  private volatile AnimationListener mAnimationListener = NO_OP_LISTENER;
  @Nullable
  private volatile DrawListener mDrawListener = null;
  @Nullable
  private DrawableProperties mDrawableProperties;
  private int mDroppedFrames;
  private long mExpectedRenderTimeMs;
  @Nullable
  private FrameScheduler mFrameScheduler;
  private long mFrameSchedulingDelayMs = 8L;
  private long mFrameSchedulingOffsetMs = 0L;
  private final Runnable mInvalidateRunnable = new Runnable()
  {
    public void run()
    {
      AnimatedDrawable2 localAnimatedDrawable2 = AnimatedDrawable2.this;
      localAnimatedDrawable2.unscheduleSelf(mInvalidateRunnable);
      invalidateSelf();
    }
  };
  private volatile boolean mIsRunning;
  private int mLastDrawnFrameNumber;
  private long mLastFrameAnimationTimeMs;
  private int mPausedLastDrawnFrameNumber;
  private long mPausedLastFrameAnimationTimeMsDifference;
  private long mPausedStartTimeMsDifference;
  private long mStartTimeMs;
  
  public AnimatedDrawable2()
  {
    this(null);
  }
  
  public AnimatedDrawable2(AnimationBackend paramAnimationBackend)
  {
    mAnimationBackend = paramAnimationBackend;
    mFrameScheduler = createSchedulerForBackendAndDelayMethod(mAnimationBackend);
  }
  
  private static FrameScheduler createSchedulerForBackendAndDelayMethod(AnimationBackend paramAnimationBackend)
  {
    if (paramAnimationBackend == null) {
      return null;
    }
    return new DropFramesFrameScheduler(paramAnimationBackend);
  }
  
  private long now()
  {
    return SystemClock.uptimeMillis();
  }
  
  private void onFrameDropped()
  {
    mDroppedFrames += 1;
    if (FLog.isLoggable(2)) {
      FLog.v(SHORT, "Dropped a frame. Count: %s", Integer.valueOf(mDroppedFrames));
    }
  }
  
  private void scheduleNextFrame(long paramLong)
  {
    mExpectedRenderTimeMs = (mStartTimeMs + paramLong);
    scheduleSelf(mInvalidateRunnable, mExpectedRenderTimeMs);
  }
  
  public void draw(Canvas paramCanvas)
  {
    if (mAnimationBackend != null)
    {
      if (mFrameScheduler == null) {
        return;
      }
      long l4 = now();
      long l2;
      if (mIsRunning) {
        l2 = l4 - mStartTimeMs + mFrameSchedulingOffsetMs;
      } else {
        l2 = Math.max(mLastFrameAnimationTimeMs, 0L);
      }
      int k = mFrameScheduler.getFrameNumberToRender(l2, mLastFrameAnimationTimeMs);
      int i = k;
      int j;
      if (k == -1)
      {
        j = mAnimationBackend.getFrameCount() - 1;
        mAnimationListener.onAnimationStop(this);
        mIsRunning = false;
      }
      else
      {
        j = i;
        if (k == 0)
        {
          j = i;
          if (mLastDrawnFrameNumber != -1)
          {
            j = i;
            if (l4 >= mExpectedRenderTimeMs)
            {
              mAnimationListener.onAnimationRepeat(this);
              j = i;
            }
          }
        }
      }
      boolean bool = mAnimationBackend.drawFrame(this, paramCanvas, j);
      if (bool)
      {
        mAnimationListener.onAnimationFrame(this, j);
        mLastDrawnFrameNumber = j;
      }
      if (!bool) {
        onFrameDropped();
      }
      long l5 = now();
      long l3;
      long l1;
      if (mIsRunning)
      {
        l3 = mFrameScheduler.getTargetRenderTimeForNextFrameMs(l5 - mStartTimeMs);
        if (l3 != -1L)
        {
          l1 = mFrameSchedulingDelayMs + l3;
          scheduleNextFrame(l1);
        }
        else
        {
          mAnimationListener.onAnimationStop(this);
          mIsRunning = false;
          l1 = -1L;
        }
      }
      else
      {
        l3 = -1L;
        l1 = -1L;
      }
      paramCanvas = mDrawListener;
      if (paramCanvas != null) {
        paramCanvas.onDraw(this, mFrameScheduler, j, bool, mIsRunning, mStartTimeMs, l2, mLastFrameAnimationTimeMs, l4, l5, l3, l1);
      }
      mLastFrameAnimationTimeMs = l2;
    }
  }
  
  public void dropCaches()
  {
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend != null) {
      localAnimationBackend.clear();
    }
  }
  
  public AnimationBackend getAnimationBackend()
  {
    return mAnimationBackend;
  }
  
  public long getDroppedFrames()
  {
    return mDroppedFrames;
  }
  
  public int getFrameCount()
  {
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend == null) {
      return 0;
    }
    return localAnimationBackend.getFrameCount();
  }
  
  public int getIntrinsicHeight()
  {
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend == null) {
      return super.getIntrinsicHeight();
    }
    return localAnimationBackend.getIntrinsicHeight();
  }
  
  public int getIntrinsicWidth()
  {
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend == null) {
      return super.getIntrinsicWidth();
    }
    return localAnimationBackend.getIntrinsicWidth();
  }
  
  public int getLoopCount()
  {
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend == null) {
      return 0;
    }
    return localAnimationBackend.getLoopCount();
  }
  
  public long getLoopDurationMs()
  {
    if (mAnimationBackend == null) {
      return 0L;
    }
    FrameScheduler localFrameScheduler = mFrameScheduler;
    if (localFrameScheduler != null) {
      return localFrameScheduler.getLoopDurationMs();
    }
    int i = 0;
    int j = 0;
    while (i < mAnimationBackend.getFrameCount())
    {
      j += mAnimationBackend.getFrameDurationMs(i);
      i += 1;
    }
    return j;
  }
  
  public int getOpacity()
  {
    return -3;
  }
  
  public long getStartTimeMs()
  {
    return mStartTimeMs;
  }
  
  public boolean isInfiniteAnimation()
  {
    FrameScheduler localFrameScheduler = mFrameScheduler;
    return (localFrameScheduler != null) && (localFrameScheduler.isInfiniteAnimation());
  }
  
  public boolean isRunning()
  {
    return mIsRunning;
  }
  
  public void jumpToFrame(int paramInt)
  {
    if (mAnimationBackend != null)
    {
      FrameScheduler localFrameScheduler = mFrameScheduler;
      if (localFrameScheduler == null) {
        return;
      }
      mLastFrameAnimationTimeMs = localFrameScheduler.getTargetRenderTimeMs(paramInt);
      mStartTimeMs = (now() - mLastFrameAnimationTimeMs);
      mExpectedRenderTimeMs = mStartTimeMs;
      invalidateSelf();
    }
  }
  
  protected void onBoundsChange(Rect paramRect)
  {
    super.onBoundsChange(paramRect);
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend != null) {
      localAnimationBackend.setBounds(paramRect);
    }
  }
  
  protected boolean onLevelChange(int paramInt)
  {
    if (mIsRunning) {
      return false;
    }
    long l1 = mLastFrameAnimationTimeMs;
    long l2 = paramInt;
    if (l1 != l2)
    {
      mLastFrameAnimationTimeMs = l2;
      invalidateSelf();
      return true;
    }
    return false;
  }
  
  public void setAlpha(int paramInt)
  {
    if (mDrawableProperties == null) {
      mDrawableProperties = new DrawableProperties();
    }
    mDrawableProperties.setAlpha(paramInt);
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend != null) {
      localAnimationBackend.setAlpha(paramInt);
    }
  }
  
  public void setAnimationBackend(AnimationBackend paramAnimationBackend)
  {
    mAnimationBackend = paramAnimationBackend;
    paramAnimationBackend = mAnimationBackend;
    if (paramAnimationBackend != null)
    {
      mFrameScheduler = new DropFramesFrameScheduler(paramAnimationBackend);
      mAnimationBackend.setBounds(getBounds());
      paramAnimationBackend = mDrawableProperties;
      if (paramAnimationBackend != null) {
        paramAnimationBackend.applyTo(this);
      }
    }
    mFrameScheduler = createSchedulerForBackendAndDelayMethod(mAnimationBackend);
    stop();
  }
  
  public void setAnimationListener(AnimationListener paramAnimationListener)
  {
    if (paramAnimationListener == null) {
      paramAnimationListener = NO_OP_LISTENER;
    }
    mAnimationListener = paramAnimationListener;
  }
  
  public void setColorFilter(ColorFilter paramColorFilter)
  {
    if (mDrawableProperties == null) {
      mDrawableProperties = new DrawableProperties();
    }
    mDrawableProperties.setColorFilter(paramColorFilter);
    AnimationBackend localAnimationBackend = mAnimationBackend;
    if (localAnimationBackend != null) {
      localAnimationBackend.setColorFilter(paramColorFilter);
    }
  }
  
  public void setDrawListener(DrawListener paramDrawListener)
  {
    mDrawListener = paramDrawListener;
  }
  
  public void setFrameSchedulingDelayMs(long paramLong)
  {
    mFrameSchedulingDelayMs = paramLong;
  }
  
  public void setFrameSchedulingOffsetMs(long paramLong)
  {
    mFrameSchedulingOffsetMs = paramLong;
  }
  
  public void start()
  {
    if (!mIsRunning)
    {
      AnimationBackend localAnimationBackend = mAnimationBackend;
      if (localAnimationBackend != null)
      {
        if (localAnimationBackend.getFrameCount() <= 1) {
          return;
        }
        mIsRunning = true;
        long l = now();
        mStartTimeMs = (l - mPausedStartTimeMsDifference);
        mExpectedRenderTimeMs = mStartTimeMs;
        mLastFrameAnimationTimeMs = (l - mPausedLastFrameAnimationTimeMsDifference);
        mLastDrawnFrameNumber = mPausedLastDrawnFrameNumber;
        invalidateSelf();
        mAnimationListener.onAnimationStart(this);
      }
    }
  }
  
  public void stop()
  {
    if (!mIsRunning) {
      return;
    }
    long l = now();
    mPausedStartTimeMsDifference = (l - mStartTimeMs);
    mPausedLastFrameAnimationTimeMsDifference = (l - mLastFrameAnimationTimeMs);
    mPausedLastDrawnFrameNumber = mLastDrawnFrameNumber;
    mIsRunning = false;
    mStartTimeMs = 0L;
    mExpectedRenderTimeMs = mStartTimeMs;
    mLastFrameAnimationTimeMs = -1L;
    mLastDrawnFrameNumber = -1;
    unscheduleSelf(mInvalidateRunnable);
    mAnimationListener.onAnimationStop(this);
  }
  
  public static abstract interface DrawListener
  {
    public abstract void onDraw(AnimatedDrawable2 paramAnimatedDrawable2, FrameScheduler paramFrameScheduler, int paramInt, boolean paramBoolean1, boolean paramBoolean2, long paramLong1, long paramLong2, long paramLong3, long paramLong4, long paramLong5, long paramLong6, long paramLong7);
  }
}
