package com.facebook.imageformat;

import com.facebook.common.internal.Ints;
import com.facebook.common.internal.Preconditions;
import com.facebook.common.webp.WebpSupportStatus;

public class DefaultImageFormatChecker
  implements ImageFormat.FormatChecker
{
  private static final byte[] BMP_HEADER;
  private static final int BMP_HEADER_LENGTH;
  private static final byte[] DNG_HEADER_II;
  private static final int DNG_HEADER_LENGTH = DNG_HEADER_II.length;
  private static final byte[] DNG_HEADER_MM;
  private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
  private static final byte[] GIF_HEADER_87A;
  private static final byte[] GIF_HEADER_89A;
  private static final int GIF_HEADER_LENGTH = 6;
  private static final int HEIF_HEADER_LENGTH = 12;
  private static final byte[] HEIF_HEADER_PREFIX;
  private static final byte[][] HEIF_HEADER_SUFFIXES;
  private static final byte[] ICO_HEADER;
  private static final int ICO_HEADER_LENGTH;
  private static final byte[] JPEG_HEADER = { -1, -40, -1 };
  private static final int JPEG_HEADER_LENGTH = JPEG_HEADER.length;
  private static final byte[] PNG_HEADER = { -119, 80, 78, 71, 13, 10, 26, 10 };
  private static final int PNG_HEADER_LENGTH = PNG_HEADER.length;
  private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
  final int MAX_HEADER_LENGTH = Ints.min(new int[] { 21, 20, JPEG_HEADER_LENGTH, PNG_HEADER_LENGTH, 6, BMP_HEADER_LENGTH, ICO_HEADER_LENGTH, 12 });
  
  static
  {
    GIF_HEADER_87A = ImageFormatCheckerUtils.asciiBytes("GIF87a");
    GIF_HEADER_89A = ImageFormatCheckerUtils.asciiBytes("GIF89a");
    BMP_HEADER = ImageFormatCheckerUtils.asciiBytes("BM");
    BMP_HEADER_LENGTH = BMP_HEADER.length;
    ICO_HEADER = new byte[] { 0, 0, 1, 0 };
    ICO_HEADER_LENGTH = ICO_HEADER.length;
    HEIF_HEADER_PREFIX = ImageFormatCheckerUtils.asciiBytes("ftyp");
    HEIF_HEADER_SUFFIXES = new byte[][] { ImageFormatCheckerUtils.asciiBytes("heic"), ImageFormatCheckerUtils.asciiBytes("heix"), ImageFormatCheckerUtils.asciiBytes("hevc"), ImageFormatCheckerUtils.asciiBytes("hevx"), ImageFormatCheckerUtils.asciiBytes("mif1"), ImageFormatCheckerUtils.asciiBytes("msf1") };
    DNG_HEADER_II = new byte[] { 73, 73, 42, 0 };
    DNG_HEADER_MM = new byte[] { 77, 77, 0, 42 };
  }
  
  public DefaultImageFormatChecker() {}
  
  private static ImageFormat getWebpFormat(byte[] paramArrayOfByte, int paramInt)
  {
    Preconditions.checkArgument(WebpSupportStatus.isWebpHeader(paramArrayOfByte, 0, paramInt));
    if (WebpSupportStatus.isSimpleWebpHeader(paramArrayOfByte, 0)) {
      return DefaultImageFormats.WEBP_SIMPLE;
    }
    if (WebpSupportStatus.isLosslessWebpHeader(paramArrayOfByte, 0)) {
      return DefaultImageFormats.WEBP_LOSSLESS;
    }
    if (WebpSupportStatus.isExtendedWebpHeader(paramArrayOfByte, 0, paramInt))
    {
      if (WebpSupportStatus.isAnimatedWebpHeader(paramArrayOfByte, 0)) {
        return DefaultImageFormats.WEBP_ANIMATED;
      }
      if (WebpSupportStatus.isExtendedWebpHeaderWithAlpha(paramArrayOfByte, 0)) {
        return DefaultImageFormats.WEBP_EXTENDED_WITH_ALPHA;
      }
      return DefaultImageFormats.WEBP_EXTENDED;
    }
    return ImageFormat.UNKNOWN;
  }
  
  private static boolean isBmpHeader(byte[] paramArrayOfByte, int paramInt)
  {
    byte[] arrayOfByte = BMP_HEADER;
    if (paramInt < arrayOfByte.length) {
      return false;
    }
    return ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, arrayOfByte);
  }
  
  private static boolean isDngHeader(byte[] paramArrayOfByte, int paramInt)
  {
    return (paramInt >= DNG_HEADER_LENGTH) && ((ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, DNG_HEADER_II)) || (ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, DNG_HEADER_MM)));
  }
  
  private static boolean isGifHeader(byte[] paramArrayOfByte, int paramInt)
  {
    if (paramInt < 6) {
      return false;
    }
    return (ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, GIF_HEADER_87A)) || (ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, GIF_HEADER_89A));
  }
  
  private static boolean isHeifHeader(byte[] paramArrayOfByte, int paramInt)
  {
    if (paramInt < 12) {
      return false;
    }
    if (paramArrayOfByte[3] < 8) {
      return false;
    }
    if (!ImageFormatCheckerUtils.hasPatternAt(paramArrayOfByte, HEIF_HEADER_PREFIX, 4)) {
      return false;
    }
    byte[][] arrayOfByte = HEIF_HEADER_SUFFIXES;
    int i = arrayOfByte.length;
    paramInt = 0;
    while (paramInt < i)
    {
      if (ImageFormatCheckerUtils.hasPatternAt(paramArrayOfByte, arrayOfByte[paramInt], 8)) {
        return true;
      }
      paramInt += 1;
    }
    return false;
  }
  
  private static boolean isIcoHeader(byte[] paramArrayOfByte, int paramInt)
  {
    byte[] arrayOfByte = ICO_HEADER;
    if (paramInt < arrayOfByte.length) {
      return false;
    }
    return ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, arrayOfByte);
  }
  
  private static boolean isJpegHeader(byte[] paramArrayOfByte, int paramInt)
  {
    byte[] arrayOfByte = JPEG_HEADER;
    return (paramInt >= arrayOfByte.length) && (ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, arrayOfByte));
  }
  
  private static boolean isPngHeader(byte[] paramArrayOfByte, int paramInt)
  {
    byte[] arrayOfByte = PNG_HEADER;
    return (paramInt >= arrayOfByte.length) && (ImageFormatCheckerUtils.startsWithPattern(paramArrayOfByte, arrayOfByte));
  }
  
  public final ImageFormat determineFormat(byte[] paramArrayOfByte, int paramInt)
  {
    Preconditions.checkNotNull(paramArrayOfByte);
    if (WebpSupportStatus.isWebpHeader(paramArrayOfByte, 0, paramInt)) {
      return getWebpFormat(paramArrayOfByte, paramInt);
    }
    if (isJpegHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.JPEG;
    }
    if (isPngHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.PNG;
    }
    if (isGifHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.UNKNOWN;
    }
    if (isBmpHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.BMP;
    }
    if (isIcoHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.GIF;
    }
    if (isHeifHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.HEIF;
    }
    if (isDngHeader(paramArrayOfByte, paramInt)) {
      return DefaultImageFormats.mServiceState;
    }
    return ImageFormat.UNKNOWN;
  }
  
  public int getHeaderSize()
  {
    return MAX_HEADER_LENGTH;
  }
}
