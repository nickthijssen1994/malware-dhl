package com.facebook.imagepipeline.cache;

import android.graphics.Bitmap;
import com.facebook.common.internal.Preconditions;
import com.facebook.common.references.CloseableReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class CountingMemoryCacheInspector<K, V>
{
  private final CountingMemoryCache<K, V> mCountingBitmapCache;
  
  public CountingMemoryCacheInspector(CountingMemoryCache paramCountingMemoryCache)
  {
    mCountingBitmapCache = paramCountingMemoryCache;
  }
  
  public DumpInfo dumpCacheContent()
  {
    CountingMemoryCache localCountingMemoryCache = mCountingBitmapCache;
    try
    {
      DumpInfo localDumpInfo = new DumpInfo(mCountingBitmapCache.getSizeInBytes(), mCountingBitmapCache.getEvictionQueueSizeInBytes(), mCountingBitmapCache.mMemoryCacheParams);
      Object localObject2 = mCountingBitmapCache.mCachedEntries.getMatchingEntries(null).iterator();
      if (((Iterator)localObject2).hasNext())
      {
        localObject1 = (CountingMemoryCache.Entry)((Map.Entry)((Iterator)localObject2).next()).getValue();
        DumpInfoEntry localDumpInfoEntry = new DumpInfoEntry(choice, valueRef);
        if (clientCount > 0) {}
        for (localObject1 = sharedEntries;; localObject1 = lruEntries)
        {
          ((List)localObject1).add(localDumpInfoEntry);
          break;
        }
      }
      Object localObject1 = mCountingBitmapCache.mOtherEntries.entrySet().iterator();
      while (((Iterator)localObject1).hasNext())
      {
        localObject2 = (Map.Entry)((Iterator)localObject1).next();
        if ((localObject2 != null) && (!((Bitmap)((Map.Entry)localObject2).getKey()).isRecycled())) {
          otherEntries.put(((Map.Entry)localObject2).getKey(), ((Map.Entry)localObject2).getValue());
        }
      }
      return localDumpInfo;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public static class DumpInfo<K, V>
  {
    public final List<CountingMemoryCacheInspector.DumpInfoEntry<K, V>> lruEntries;
    public final int lruSize;
    public final int maxEntriesCount;
    public final int maxEntrySize;
    public final int maxSize;
    public final Map<Bitmap, Object> otherEntries;
    public final List<CountingMemoryCacheInspector.DumpInfoEntry<K, V>> sharedEntries;
    public final int size;
    
    public DumpInfo(int paramInt1, int paramInt2, MemoryCacheParams paramMemoryCacheParams)
    {
      maxSize = maxCacheSize;
      maxEntriesCount = maxCacheEntries;
      maxEntrySize = maxCacheEntrySize;
      size = paramInt1;
      lruSize = paramInt2;
      lruEntries = new ArrayList();
      sharedEntries = new ArrayList();
      otherEntries = new HashMap();
    }
    
    public void release()
    {
      Iterator localIterator = lruEntries.iterator();
      while (localIterator.hasNext()) {
        ((CountingMemoryCacheInspector.DumpInfoEntry)localIterator.next()).release();
      }
      localIterator = sharedEntries.iterator();
      while (localIterator.hasNext()) {
        ((CountingMemoryCacheInspector.DumpInfoEntry)localIterator.next()).release();
      }
    }
  }
  
  public static class DumpInfoEntry<K, V>
  {
    public final K columnKey;
    public final CloseableReference<V> value;
    
    public DumpInfoEntry(Object paramObject, CloseableReference paramCloseableReference)
    {
      columnKey = Preconditions.checkNotNull(paramObject);
      value = CloseableReference.cloneOrNull(paramCloseableReference);
    }
    
    public void release()
    {
      CloseableReference.closeSafely(value);
    }
  }
}
