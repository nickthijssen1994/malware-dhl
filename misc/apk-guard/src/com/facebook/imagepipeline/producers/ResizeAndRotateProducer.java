package com.facebook.imagepipeline.producers;

import com.facebook.common.internal.ImmutableMap;
import com.facebook.common.internal.Preconditions;
import com.facebook.common.internal.VisibleForTesting;
import com.facebook.common.memory.PooledByteBufferFactory;
import com.facebook.common.memory.PooledByteBufferOutputStream;
import com.facebook.common.references.CloseableReference;
import com.facebook.common.util.TriState;
import com.facebook.imageformat.DefaultImageFormats;
import com.facebook.imageformat.ImageFormat;
import com.facebook.imagepipeline.common.ResizeOptions;
import com.facebook.imagepipeline.common.RotationOptions;
import com.facebook.imagepipeline.image.EncodedImage;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.transcoder.ImageTranscodeResult;
import com.facebook.imagepipeline.transcoder.ImageTranscoder;
import com.facebook.imagepipeline.transcoder.ImageTranscoderFactory;
import com.facebook.imagepipeline.transcoder.JpegTranscoderUtils;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executor;

public class ResizeAndRotateProducer
  implements Producer<EncodedImage>
{
  private static final String INPUT_IMAGE_FORMAT = "Image format";
  @VisibleForTesting
  static final int MIN_TRANSFORM_INTERVAL_MS = 100;
  private static final String ORIGINAL_SIZE_KEY = "Original size";
  private static final String PRODUCER_NAME = "ResizeAndRotateProducer";
  private static final String REQUESTED_SIZE_KEY = "Requested size";
  private static final String TRANSCODER_ID = "Transcoder id";
  private static final String TRANSCODING_RESULT = "Transcoding result";
  private final Executor mExecutor;
  private final ImageTranscoderFactory mImageTranscoderFactory;
  private final Producer<EncodedImage> mInputProducer;
  private final boolean mIsResizingEnabled;
  private final PooledByteBufferFactory mPooledByteBufferFactory;
  
  public ResizeAndRotateProducer(Executor paramExecutor, PooledByteBufferFactory paramPooledByteBufferFactory, Producer paramProducer, boolean paramBoolean, ImageTranscoderFactory paramImageTranscoderFactory)
  {
    mExecutor = ((Executor)Preconditions.checkNotNull(paramExecutor));
    mPooledByteBufferFactory = ((PooledByteBufferFactory)Preconditions.checkNotNull(paramPooledByteBufferFactory));
    mInputProducer = ((Producer)Preconditions.checkNotNull(paramProducer));
    mImageTranscoderFactory = ((ImageTranscoderFactory)Preconditions.checkNotNull(paramImageTranscoderFactory));
    mIsResizingEnabled = paramBoolean;
  }
  
  private static boolean shouldRotate(RotationOptions paramRotationOptions, EncodedImage paramEncodedImage)
  {
    return (!paramRotationOptions.canDeferUntilRendered()) && ((JpegTranscoderUtils.getRotationAngle(paramRotationOptions, paramEncodedImage) != 0) || (shouldRotateUsingExifOrientation(paramRotationOptions, paramEncodedImage)));
  }
  
  private static boolean shouldRotateUsingExifOrientation(RotationOptions paramRotationOptions, EncodedImage paramEncodedImage)
  {
    if ((paramRotationOptions.rotationEnabled()) && (!paramRotationOptions.canDeferUntilRendered())) {
      return JpegTranscoderUtils.INVERTED_EXIF_ORIENTATIONS.contains(Integer.valueOf(paramEncodedImage.getExifOrientation()));
    }
    paramEncodedImage.setExifOrientation(0);
    return false;
  }
  
  private static TriState shouldTransform(ImageRequest paramImageRequest, EncodedImage paramEncodedImage, ImageTranscoder paramImageTranscoder)
  {
    if ((paramEncodedImage != null) && (paramEncodedImage.getImageFormat() != ImageFormat.UNKNOWN))
    {
      if (!paramImageTranscoder.canTranscode(paramEncodedImage.getImageFormat())) {
        return TriState.NO;
      }
      boolean bool;
      if ((!shouldRotate(paramImageRequest.getRotationOptions(), paramEncodedImage)) && (!paramImageTranscoder.canResize(paramEncodedImage, paramImageRequest.getRotationOptions(), paramImageRequest.getResizeOptions()))) {
        bool = false;
      } else {
        bool = true;
      }
      return TriState.valueOf(bool);
    }
    return TriState.UNSET;
  }
  
  public void produceResults(Consumer paramConsumer, ProducerContext paramProducerContext)
  {
    mInputProducer.produceResults(new TransformingConsumer(paramConsumer, paramProducerContext, mIsResizingEnabled, mImageTranscoderFactory), paramProducerContext);
  }
  
  private class TransformingConsumer
    extends DelegatingConsumer<EncodedImage, EncodedImage>
  {
    private final ImageTranscoderFactory mImageTranscoderFactory;
    private boolean mIsCancelled = false;
    private final boolean mIsResizingEnabled;
    private final JobScheduler mJobScheduler;
    private final ProducerContext mProducerContext;
    
    TransformingConsumer(final Consumer paramConsumer, ProducerContext paramProducerContext, boolean paramBoolean, ImageTranscoderFactory paramImageTranscoderFactory)
    {
      super();
      mProducerContext = paramProducerContext;
      paramProducerContext = mProducerContext.getImageRequest().getResizingAllowedOverride();
      if (paramProducerContext != null) {
        paramBoolean = paramProducerContext.booleanValue();
      }
      mIsResizingEnabled = paramBoolean;
      mImageTranscoderFactory = paramImageTranscoderFactory;
      paramProducerContext = new JobScheduler.JobRunnable()
      {
        public void remainder(EncodedImage paramAnonymousEncodedImage, int paramAnonymousInt)
        {
          ResizeAndRotateProducer.TransformingConsumer localTransformingConsumer = ResizeAndRotateProducer.TransformingConsumer.this;
          localTransformingConsumer.doTransform(paramAnonymousEncodedImage, paramAnonymousInt, (ImageTranscoder)Preconditions.checkNotNull(mImageTranscoderFactory.createImageTranscoder(paramAnonymousEncodedImage.getImageFormat(), mIsResizingEnabled)));
        }
      };
      mJobScheduler = new JobScheduler(mExecutor, paramProducerContext, 100);
      mProducerContext.addCallbacks(new BaseProducerContextCallbacks()
      {
        public void onCancellationRequested()
        {
          mJobScheduler.clearJob();
          ResizeAndRotateProducer.TransformingConsumer.access$602(ResizeAndRotateProducer.TransformingConsumer.this, true);
          paramConsumer.onCancellation();
        }
        
        public void onIsIntermediateResultExpectedChanged()
        {
          if (mProducerContext.isIntermediateResultExpected()) {
            mJobScheduler.scheduleJob();
          }
        }
      });
    }
    
    private void doTransform(EncodedImage paramEncodedImage, int paramInt, ImageTranscoder paramImageTranscoder)
    {
      mProducerContext.getProducerListener().onProducerStart(mProducerContext, "ResizeAndRotateProducer");
      ImageRequest localImageRequest = mProducerContext.getImageRequest();
      PooledByteBufferOutputStream localPooledByteBufferOutputStream = mPooledByteBufferFactory.newOutputStream();
      CloseableReference localCloseableReference = null;
      Object localObject = localCloseableReference;
      int i = paramInt;
      try
      {
        ImageTranscodeResult localImageTranscodeResult = paramImageTranscoder.transcode(paramEncodedImage, localPooledByteBufferOutputStream, localImageRequest.getRotationOptions(), localImageRequest.getResizeOptions(), null, Integer.valueOf(85));
        localObject = localCloseableReference;
        i = paramInt;
        int j = localImageTranscodeResult.getTranscodeStatus();
        if (j != 2)
        {
          localObject = localCloseableReference;
          i = paramInt;
          paramImageTranscoder = getExtraMap(paramEncodedImage, localImageRequest.getResizeOptions(), localImageTranscodeResult, paramImageTranscoder.getIdentifier());
          paramEncodedImage = paramImageTranscoder;
          localObject = paramEncodedImage;
          i = paramInt;
          localCloseableReference = CloseableReference.of(localPooledByteBufferOutputStream.toByteBuffer());
          j = paramInt;
          try
          {
            localObject = new EncodedImage(localCloseableReference);
            j = paramInt;
            ((EncodedImage)localObject).setImageFormat(DefaultImageFormats.JPEG);
            int k = paramInt;
            try
            {
              ((EncodedImage)localObject).parseMetaData();
              k = paramInt;
              mProducerContext.getProducerListener().onProducerFinishWithSuccess(mProducerContext, "ResizeAndRotateProducer", paramImageTranscoder);
              k = paramInt;
              j = localImageTranscodeResult.getTranscodeStatus();
              i = paramInt;
              if (j != 1) {
                i = paramInt | 0x10;
              }
              k = i;
              getConsumer().onNewResult(localObject, i);
              j = i;
              EncodedImage.closeSafely((EncodedImage)localObject);
              localObject = paramEncodedImage;
              CloseableReference.closeSafely(localCloseableReference);
              localPooledByteBufferOutputStream.close();
              return;
            }
            catch (Throwable paramImageTranscoder)
            {
              j = k;
              EncodedImage.closeSafely((EncodedImage)localObject);
              j = k;
              throw paramImageTranscoder;
            }
            localObject = localCloseableReference;
          }
          catch (Throwable paramImageTranscoder)
          {
            localObject = paramEncodedImage;
            i = j;
            CloseableReference.closeSafely(localCloseableReference);
            localObject = paramEncodedImage;
            i = j;
            throw paramImageTranscoder;
          }
        }
        i = paramInt;
        paramEncodedImage = new RuntimeException("Error while transcoding the image");
        throw paramEncodedImage;
      }
      catch (Throwable paramEncodedImage) {}catch (Exception paramEncodedImage)
      {
        mProducerContext.getProducerListener().onProducerFinishWithFailure(mProducerContext, "ResizeAndRotateProducer", paramEncodedImage, (Map)localObject);
        boolean bool = BaseConsumer.isLast(i);
        if (bool) {
          getConsumer().onFailure(paramEncodedImage);
        }
        localPooledByteBufferOutputStream.close();
        return;
      }
      localPooledByteBufferOutputStream.close();
      throw paramEncodedImage;
    }
    
    private void forwardNewResult(EncodedImage paramEncodedImage, int paramInt, ImageFormat paramImageFormat)
    {
      if ((paramImageFormat != DefaultImageFormats.JPEG) && (paramImageFormat != DefaultImageFormats.HEIF)) {
        paramEncodedImage = getNewResultForImagesWithoutExifData(paramEncodedImage);
      } else {
        paramEncodedImage = getNewResultsForJpegOrHeif(paramEncodedImage);
      }
      getConsumer().onNewResult(paramEncodedImage, paramInt);
    }
    
    private EncodedImage getCloneWithRotationApplied(EncodedImage paramEncodedImage, int paramInt)
    {
      paramEncodedImage = EncodedImage.cloneOrNull(paramEncodedImage);
      if (paramEncodedImage != null) {
        paramEncodedImage.setRotationAngle(paramInt);
      }
      return paramEncodedImage;
    }
    
    private Map getExtraMap(EncodedImage paramEncodedImage, ResizeOptions paramResizeOptions, ImageTranscodeResult paramImageTranscodeResult, String paramString)
    {
      if (!mProducerContext.getProducerListener().requiresExtraMap(mProducerContext, "ResizeAndRotateProducer")) {
        return null;
      }
      Object localObject1 = new StringBuilder();
      ((StringBuilder)localObject1).append(paramEncodedImage.getWidth());
      ((StringBuilder)localObject1).append("x");
      ((StringBuilder)localObject1).append(paramEncodedImage.getHeight());
      localObject1 = ((StringBuilder)localObject1).toString();
      if (paramResizeOptions != null)
      {
        localObject2 = new StringBuilder();
        ((StringBuilder)localObject2).append(width);
        ((StringBuilder)localObject2).append("x");
        ((StringBuilder)localObject2).append(height);
        paramResizeOptions = ((StringBuilder)localObject2).toString();
      }
      else
      {
        paramResizeOptions = "Unspecified";
      }
      Object localObject2 = new HashMap();
      ((Map)localObject2).put("Image format", String.valueOf(paramEncodedImage.getImageFormat()));
      ((Map)localObject2).put("Original size", localObject1);
      ((Map)localObject2).put("Requested size", paramResizeOptions);
      ((Map)localObject2).put("queueTime", String.valueOf(mJobScheduler.getQueuedTime()));
      ((Map)localObject2).put("Transcoder id", paramString);
      ((Map)localObject2).put("Transcoding result", String.valueOf(paramImageTranscodeResult));
      return ImmutableMap.copyOf((Map)localObject2);
    }
    
    private EncodedImage getNewResultForImagesWithoutExifData(EncodedImage paramEncodedImage)
    {
      RotationOptions localRotationOptions = mProducerContext.getImageRequest().getRotationOptions();
      EncodedImage localEncodedImage = paramEncodedImage;
      if (!localRotationOptions.useImageMetadata())
      {
        localEncodedImage = paramEncodedImage;
        if (localRotationOptions.rotationEnabled()) {
          localEncodedImage = getCloneWithRotationApplied(paramEncodedImage, localRotationOptions.getForcedAngle());
        }
      }
      return localEncodedImage;
    }
    
    private EncodedImage getNewResultsForJpegOrHeif(EncodedImage paramEncodedImage)
    {
      EncodedImage localEncodedImage = paramEncodedImage;
      if (!mProducerContext.getImageRequest().getRotationOptions().canDeferUntilRendered())
      {
        localEncodedImage = paramEncodedImage;
        if (paramEncodedImage.getRotationAngle() != 0)
        {
          localEncodedImage = paramEncodedImage;
          if (paramEncodedImage.getRotationAngle() != -1) {
            localEncodedImage = getCloneWithRotationApplied(paramEncodedImage, 0);
          }
        }
      }
      return localEncodedImage;
    }
    
    protected void onNewResultImpl(EncodedImage paramEncodedImage, int paramInt)
    {
      if (mIsCancelled) {
        return;
      }
      boolean bool = BaseConsumer.isLast(paramInt);
      if (paramEncodedImage == null)
      {
        if (bool) {
          getConsumer().onNewResult(null, 1);
        }
      }
      else
      {
        ImageFormat localImageFormat = paramEncodedImage.getImageFormat();
        TriState localTriState = ResizeAndRotateProducer.shouldTransform(mProducerContext.getImageRequest(), paramEncodedImage, (ImageTranscoder)Preconditions.checkNotNull(mImageTranscoderFactory.createImageTranscoder(localImageFormat, mIsResizingEnabled)));
        if ((!bool) && (localTriState == TriState.UNSET)) {
          return;
        }
        if (localTriState != TriState.YES)
        {
          forwardNewResult(paramEncodedImage, paramInt, localImageFormat);
          return;
        }
        if (!mJobScheduler.updateJob(paramEncodedImage, paramInt)) {
          return;
        }
        if ((bool) || (mProducerContext.isIntermediateResultExpected())) {
          mJobScheduler.scheduleJob();
        }
      }
    }
  }
}
