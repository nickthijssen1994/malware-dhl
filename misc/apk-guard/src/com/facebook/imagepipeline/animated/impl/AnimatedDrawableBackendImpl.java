package com.facebook.imagepipeline.animated.impl;

import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Canvas;
import android.graphics.Rect;
import com.facebook.common.internal.Preconditions;
import com.facebook.common.references.CloseableReference;
import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
import com.facebook.imagepipeline.animated.base.AnimatedDrawableFrameInfo;
import com.facebook.imagepipeline.animated.base.AnimatedImage;
import com.facebook.imagepipeline.animated.base.AnimatedImageFrame;
import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
import javax.annotation.Nullable;
import javax.annotation.concurrent.GuardedBy;

public class AnimatedDrawableBackendImpl
  implements AnimatedDrawableBackend
{
  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
  private final AnimatedImage mAnimatedImage;
  private final AnimatedImageResult mAnimatedImageResult;
  private final boolean mDownscaleFrameToDrawableDimensions;
  private final int mDurationMs;
  private final int[] mFrameDurationsMs;
  private final AnimatedDrawableFrameInfo[] mFrameInfos;
  private final int[] mFrameTimestampsMs;
  private final Rect mRenderDstRect = new Rect();
  private final Rect mRenderSrcRect = new Rect();
  private final Rect mRenderedBounds;
  @Nullable
  @GuardedBy("this")
  private Bitmap mTempBitmap;
  
  public AnimatedDrawableBackendImpl(AnimatedDrawableUtil paramAnimatedDrawableUtil, AnimatedImageResult paramAnimatedImageResult, Rect paramRect, boolean paramBoolean)
  {
    mAnimatedDrawableUtil = paramAnimatedDrawableUtil;
    mAnimatedImageResult = paramAnimatedImageResult;
    mAnimatedImage = paramAnimatedImageResult.getImage();
    mFrameDurationsMs = mAnimatedImage.getFrameDurations();
    mAnimatedDrawableUtil.fixFrameDurations(mFrameDurationsMs);
    mDurationMs = mAnimatedDrawableUtil.getTotalDurationFromFrameDurations(mFrameDurationsMs);
    mFrameTimestampsMs = mAnimatedDrawableUtil.getFrameTimeStampsFromDurations(mFrameDurationsMs);
    mRenderedBounds = getBoundsToUse(mAnimatedImage, paramRect);
    mDownscaleFrameToDrawableDimensions = paramBoolean;
    mFrameInfos = new AnimatedDrawableFrameInfo[mAnimatedImage.getFrameCount()];
    int i = 0;
    while (i < mAnimatedImage.getFrameCount())
    {
      mFrameInfos[i] = mAnimatedImage.getFrameInfo(i);
      i += 1;
    }
  }
  
  private void clearTempBitmap()
  {
    try
    {
      if (mTempBitmap != null)
      {
        mTempBitmap.recycle();
        mTempBitmap = null;
      }
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private static Rect getBoundsToUse(AnimatedImage paramAnimatedImage, Rect paramRect)
  {
    if (paramRect == null) {
      return new Rect(0, 0, paramAnimatedImage.getWidth(), paramAnimatedImage.getHeight());
    }
    return new Rect(0, 0, Math.min(paramRect.width(), paramAnimatedImage.getWidth()), Math.min(paramRect.height(), paramAnimatedImage.getHeight()));
  }
  
  private void prepareTempBitmapForThisSize(int paramInt1, int paramInt2)
  {
    try
    {
      if ((mTempBitmap != null) && ((mTempBitmap.getWidth() < paramInt1) || (mTempBitmap.getHeight() < paramInt2))) {
        clearTempBitmap();
      }
      if (mTempBitmap == null) {
        mTempBitmap = Bitmap.createBitmap(paramInt1, paramInt2, Bitmap.Config.ARGB_8888);
      }
      mTempBitmap.eraseColor(0);
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private void renderImageDoesNotSupportScaling(Canvas paramCanvas, AnimatedImageFrame paramAnimatedImageFrame)
  {
    int i;
    int j;
    int k;
    int m;
    if (mDownscaleFrameToDrawableDimensions)
    {
      i = Math.min(paramAnimatedImageFrame.getWidth(), paramCanvas.getWidth());
      j = Math.min(paramAnimatedImageFrame.getHeight(), paramCanvas.getHeight());
      float f = Math.max(paramAnimatedImageFrame.getWidth() / i, paramAnimatedImageFrame.getHeight() / j);
      i = (int)(paramAnimatedImageFrame.getWidth() / f);
      j = (int)(paramAnimatedImageFrame.getHeight() / f);
      k = (int)(paramAnimatedImageFrame.getXOffset() / f);
      m = (int)(paramAnimatedImageFrame.getYOffset() / f);
    }
    else
    {
      i = paramAnimatedImageFrame.getWidth();
      j = paramAnimatedImageFrame.getHeight();
      k = paramAnimatedImageFrame.getXOffset();
      m = paramAnimatedImageFrame.getYOffset();
    }
    try
    {
      prepareTempBitmapForThisSize(i, j);
      paramAnimatedImageFrame.renderFrame(i, j, mTempBitmap);
      paramCanvas.save();
      paramCanvas.translate(k, m);
      paramCanvas.drawBitmap(mTempBitmap, 0.0F, 0.0F, null);
      paramCanvas.restore();
      return;
    }
    catch (Throwable paramCanvas)
    {
      throw paramCanvas;
    }
  }
  
  private void renderImageSupportsScaling(Canvas paramCanvas, AnimatedImageFrame paramAnimatedImageFrame)
  {
    double d1 = mRenderedBounds.width();
    double d2 = mAnimatedImage.getWidth();
    Double.isNaN(d1);
    Double.isNaN(d2);
    d1 /= d2;
    d2 = mRenderedBounds.height();
    double d3 = mAnimatedImage.getHeight();
    Double.isNaN(d2);
    Double.isNaN(d3);
    d2 /= d3;
    d3 = paramAnimatedImageFrame.getWidth();
    Double.isNaN(d3);
    int i = (int)Math.round(d3 * d1);
    d3 = paramAnimatedImageFrame.getHeight();
    Double.isNaN(d3);
    int j = (int)Math.round(d3 * d2);
    d3 = paramAnimatedImageFrame.getXOffset();
    Double.isNaN(d3);
    int k = (int)(d3 * d1);
    d1 = paramAnimatedImageFrame.getYOffset();
    Double.isNaN(d1);
    int m = (int)(d1 * d2);
    try
    {
      int n = mRenderedBounds.width();
      int i1 = mRenderedBounds.height();
      prepareTempBitmapForThisSize(n, i1);
      paramAnimatedImageFrame.renderFrame(i, j, mTempBitmap);
      mRenderSrcRect.set(0, 0, n, i1);
      mRenderDstRect.set(k, m, n + k, i1 + m);
      paramCanvas.drawBitmap(mTempBitmap, mRenderSrcRect, mRenderDstRect, null);
      return;
    }
    catch (Throwable paramCanvas)
    {
      throw paramCanvas;
    }
  }
  
  public void dropCaches()
  {
    try
    {
      clearTempBitmap();
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public AnimatedDrawableBackend forNewBounds(Rect paramRect)
  {
    if (getBoundsToUse(mAnimatedImage, paramRect).equals(mRenderedBounds)) {
      return this;
    }
    return new AnimatedDrawableBackendImpl(mAnimatedDrawableUtil, mAnimatedImageResult, paramRect, mDownscaleFrameToDrawableDimensions);
  }
  
  public AnimatedImageResult getAnimatedImageResult()
  {
    return mAnimatedImageResult;
  }
  
  public int getDurationMs()
  {
    return mDurationMs;
  }
  
  public int getDurationMsForFrame(int paramInt)
  {
    return mFrameDurationsMs[paramInt];
  }
  
  public int getFrameCount()
  {
    return mAnimatedImage.getFrameCount();
  }
  
  public int getFrameForPreview()
  {
    return mAnimatedImageResult.getFrameForPreview();
  }
  
  public int getFrameForTimestampMs(int paramInt)
  {
    return mAnimatedDrawableUtil.getFrameForTimestampMs(mFrameTimestampsMs, paramInt);
  }
  
  public AnimatedDrawableFrameInfo getFrameInfo(int paramInt)
  {
    return mFrameInfos[paramInt];
  }
  
  public int getHeight()
  {
    return mAnimatedImage.getHeight();
  }
  
  public int getLoopCount()
  {
    return mAnimatedImage.getLoopCount();
  }
  
  public int getMemoryUsage()
  {
    int i = 0;
    try
    {
      if (mTempBitmap != null) {
        i = 0 + mAnimatedDrawableUtil.getSizeOfBitmap(mTempBitmap);
      }
      int j = mAnimatedImage.getSizeInBytes();
      return i + j;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public CloseableReference getPreDecodedFrame(int paramInt)
  {
    return mAnimatedImageResult.getDecodedFrame(paramInt);
  }
  
  public int getRenderedHeight()
  {
    return mRenderedBounds.height();
  }
  
  public int getRenderedWidth()
  {
    return mRenderedBounds.width();
  }
  
  public int getTimestampMsForFrame(int paramInt)
  {
    Preconditions.checkElementIndex(paramInt, mFrameTimestampsMs.length);
    return mFrameTimestampsMs[paramInt];
  }
  
  public int getWidth()
  {
    return mAnimatedImage.getWidth();
  }
  
  public boolean hasPreDecodedFrame(int paramInt)
  {
    return mAnimatedImageResult.hasDecodedFrame(paramInt);
  }
  
  public void renderFrame(int paramInt, Canvas paramCanvas)
  {
    AnimatedImageFrame localAnimatedImageFrame = mAnimatedImage.getFrame(paramInt);
    try
    {
      boolean bool = mAnimatedImage.doesRenderSupportScaling();
      if (bool) {
        renderImageSupportsScaling(paramCanvas, localAnimatedImageFrame);
      } else {
        renderImageDoesNotSupportScaling(paramCanvas, localAnimatedImageFrame);
      }
      localAnimatedImageFrame.dispose();
      return;
    }
    catch (Throwable paramCanvas)
    {
      localAnimatedImageFrame.dispose();
      throw paramCanvas;
    }
  }
}
