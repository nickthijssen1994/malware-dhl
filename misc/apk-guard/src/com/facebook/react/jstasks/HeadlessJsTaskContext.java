package com.facebook.react.jstasks;

import android.os.Handler;
import android.util.SparseArray;
import com.facebook.infer.annotation.Assertions;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.UiThreadUtil;
import com.facebook.react.common.LifecycleState;
import com.facebook.react.modules.appregistry.AppRegistry;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.atomic.AtomicInteger;

public class HeadlessJsTaskContext
{
  private static final WeakHashMap<ReactContext, HeadlessJsTaskContext> INSTANCES = new WeakHashMap();
  private final Set<Integer> mActiveTasks = new CopyOnWriteArraySet();
  private final Handler mHandler = new Handler();
  private final Set<HeadlessJsTaskEventListener> mHeadlessJsTaskEventListeners = new CopyOnWriteArraySet();
  private final AtomicInteger mLastTaskId = new AtomicInteger(0);
  private final WeakReference<ReactContext> mReactContext;
  private final SparseArray<Runnable> mTaskTimeouts = new SparseArray();
  
  private HeadlessJsTaskContext(ReactContext paramReactContext)
  {
    mReactContext = new WeakReference(paramReactContext);
  }
  
  public static HeadlessJsTaskContext getInstance(ReactContext paramReactContext)
  {
    HeadlessJsTaskContext localHeadlessJsTaskContext2 = (HeadlessJsTaskContext)INSTANCES.get(paramReactContext);
    HeadlessJsTaskContext localHeadlessJsTaskContext1 = localHeadlessJsTaskContext2;
    if (localHeadlessJsTaskContext2 == null)
    {
      localHeadlessJsTaskContext1 = new HeadlessJsTaskContext(paramReactContext);
      INSTANCES.put(paramReactContext, localHeadlessJsTaskContext1);
    }
    return localHeadlessJsTaskContext1;
  }
  
  private void scheduleTaskTimeout(final int paramInt, long paramLong)
  {
    Runnable local2 = new Runnable()
    {
      public void run()
      {
        finishTask(paramInt);
      }
    };
    mTaskTimeouts.append(paramInt, local2);
    mHandler.postDelayed(local2, paramLong);
  }
  
  public void addTaskEventListener(HeadlessJsTaskEventListener paramHeadlessJsTaskEventListener)
  {
    mHeadlessJsTaskEventListeners.add(paramHeadlessJsTaskEventListener);
  }
  
  public void finishTask(final int paramInt)
  {
    try
    {
      boolean bool = mActiveTasks.remove(Integer.valueOf(paramInt));
      Object localObject = new StringBuilder();
      ((StringBuilder)localObject).append("Tried to finish non-existent task with id ");
      ((StringBuilder)localObject).append(paramInt);
      ((StringBuilder)localObject).append(".");
      Assertions.assertCondition(bool, ((StringBuilder)localObject).toString());
      localObject = (Runnable)mTaskTimeouts.get(paramInt);
      if (localObject != null)
      {
        mHandler.removeCallbacks((Runnable)localObject);
        mTaskTimeouts.remove(paramInt);
      }
      UiThreadUtil.runOnUiThread(new Runnable()
      {
        public void run()
        {
          Iterator localIterator = mHeadlessJsTaskEventListeners.iterator();
          while (localIterator.hasNext()) {
            ((HeadlessJsTaskEventListener)localIterator.next()).onHeadlessJsTaskFinish(paramInt);
          }
        }
      });
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public boolean hasActiveTasks()
  {
    return mActiveTasks.size() > 0;
  }
  
  public boolean isTaskRunning(int paramInt)
  {
    try
    {
      boolean bool = mActiveTasks.contains(Integer.valueOf(paramInt));
      return bool;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public void removeTaskEventListener(HeadlessJsTaskEventListener paramHeadlessJsTaskEventListener)
  {
    mHeadlessJsTaskEventListeners.remove(paramHeadlessJsTaskEventListener);
  }
  
  public int startTask(HeadlessJsTaskConfig paramHeadlessJsTaskConfig)
  {
    try
    {
      UiThreadUtil.assertOnUiThread();
      Object localObject = (ReactContext)Assertions.assertNotNull(mReactContext.get(), "Tried to start a task on a react context that has already been destroyed");
      if ((((ReactContext)localObject).getLifecycleState() == LifecycleState.RESUMED) && (!paramHeadlessJsTaskConfig.isAllowedInForeground()))
      {
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append("Tried to start task ");
        ((StringBuilder)localObject).append(paramHeadlessJsTaskConfig.getTaskKey());
        ((StringBuilder)localObject).append(" while in foreground, but this is not allowed.");
        throw new IllegalStateException(((StringBuilder)localObject).toString());
      }
      int i = mLastTaskId.incrementAndGet();
      mActiveTasks.add(Integer.valueOf(i));
      ((AppRegistry)((ReactContext)localObject).getJSModule(AppRegistry.class)).startHeadlessTask(i, paramHeadlessJsTaskConfig.getTaskKey(), paramHeadlessJsTaskConfig.getData());
      if (paramHeadlessJsTaskConfig.getTimeout() > 0L) {
        scheduleTaskTimeout(i, paramHeadlessJsTaskConfig.getTimeout());
      }
      paramHeadlessJsTaskConfig = mHeadlessJsTaskEventListeners.iterator();
      while (paramHeadlessJsTaskConfig.hasNext()) {
        ((HeadlessJsTaskEventListener)paramHeadlessJsTaskConfig.next()).onHeadlessJsTaskStart(i);
      }
      return i;
    }
    catch (Throwable paramHeadlessJsTaskConfig)
    {
      throw paramHeadlessJsTaskConfig;
    }
  }
}
