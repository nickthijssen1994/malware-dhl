package com.facebook.react.animated;

import com.facebook.react.bridge.JSApplicationIllegalArgumentException;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import javax.annotation.Nullable;

class InterpolationAnimatedNode
  extends ValueAnimatedNode
{
  public static final String EXTRAPOLATE_TYPE_CLAMP = "clamp";
  public static final String EXTRAPOLATE_TYPE_EXTEND = "extend";
  public static final String EXTRAPOLATE_TYPE_IDENTITY = "identity";
  private final String mExtrapolateLeft;
  private final String mExtrapolateRight;
  private final double[] mInputRange;
  private final double[] mOutputRange;
  @Nullable
  private ValueAnimatedNode mParent;
  
  public InterpolationAnimatedNode(ReadableMap paramReadableMap)
  {
    mInputRange = fromDoubleArray(paramReadableMap.getArray("inputRange"));
    mOutputRange = fromDoubleArray(paramReadableMap.getArray("outputRange"));
    mExtrapolateLeft = paramReadableMap.getString("extrapolateLeft");
    mExtrapolateRight = paramReadableMap.getString("extrapolateRight");
  }
  
  private static int findRangeIndex(double paramDouble, double[] paramArrayOfDouble)
  {
    int i = 1;
    while ((i < paramArrayOfDouble.length - 1) && (paramArrayOfDouble[i] < paramDouble)) {
      i += 1;
    }
    return i - 1;
  }
  
  private static double[] fromDoubleArray(ReadableArray paramReadableArray)
  {
    double[] arrayOfDouble = new double[paramReadableArray.size()];
    int i = 0;
    while (i < arrayOfDouble.length)
    {
      arrayOfDouble[i] = paramReadableArray.getDouble(i);
      i += 1;
    }
    return arrayOfDouble;
  }
  
  private static double interpolate(double paramDouble1, double paramDouble2, double paramDouble3, double paramDouble4, double paramDouble5, String paramString1, String paramString2)
  {
    int j = 2;
    double d = paramDouble1;
    int i;
    if (paramDouble1 < paramDouble2)
    {
      i = paramString1.hashCode();
      if (i != -1289044198)
      {
        if (i != -135761730)
        {
          if ((i == 94742715) && (paramString1.equals("clamp")))
          {
            i = 1;
            break label94;
          }
        }
        else if (paramString1.equals("identity"))
        {
          i = 0;
          break label94;
        }
      }
      else if (paramString1.equals("extend"))
      {
        i = 2;
        break label94;
      }
      i = -1;
      label94:
      d = paramDouble1;
      switch (i)
      {
      default: 
        paramString2 = new StringBuilder();
        paramString2.append("Invalid extrapolation type ");
        paramString2.append(paramString1);
        paramString2.append("for left extrapolation");
        throw new JSApplicationIllegalArgumentException(paramString2.toString());
      case 1: 
        d = paramDouble2;
        break;
      case 0: 
        return paramDouble1;
      }
    }
    paramDouble1 = d;
    if (d > paramDouble3)
    {
      i = paramString2.hashCode();
      if (i != -1289044198)
      {
        if (i != -135761730)
        {
          if ((i == 94742715) && (paramString2.equals("clamp")))
          {
            i = 1;
            break label283;
          }
        }
        else if (paramString2.equals("identity"))
        {
          i = 0;
          break label283;
        }
      }
      else if (paramString2.equals("extend"))
      {
        i = j;
        break label283;
      }
      i = -1;
      label283:
      paramDouble1 = d;
      switch (i)
      {
      default: 
        paramString1 = new StringBuilder();
        paramString1.append("Invalid extrapolation type ");
        paramString1.append(paramString2);
        paramString1.append("for right extrapolation");
        throw new JSApplicationIllegalArgumentException(paramString1.toString());
      case 1: 
        paramDouble1 = paramDouble3;
        break;
      case 0: 
        return d;
      }
    }
    return paramDouble4 + (paramDouble5 - paramDouble4) * (paramDouble1 - paramDouble2) / (paramDouble3 - paramDouble2);
  }
  
  static double interpolate(double paramDouble, double[] paramArrayOfDouble1, double[] paramArrayOfDouble2, String paramString1, String paramString2)
  {
    int i = findRangeIndex(paramDouble, paramArrayOfDouble1);
    double d = paramArrayOfDouble1[i];
    int j = i + 1;
    return interpolate(paramDouble, d, paramArrayOfDouble1[j], paramArrayOfDouble2[i], paramArrayOfDouble2[j], paramString1, paramString2);
  }
  
  public void onAttachedToNode(AnimatedNode paramAnimatedNode)
  {
    if (mParent == null)
    {
      if ((paramAnimatedNode instanceof ValueAnimatedNode))
      {
        mParent = ((ValueAnimatedNode)paramAnimatedNode);
        return;
      }
      throw new IllegalArgumentException("Parent is of an invalid type");
    }
    throw new IllegalStateException("Parent already attached");
  }
  
  public void onDetachedFromNode(AnimatedNode paramAnimatedNode)
  {
    if (paramAnimatedNode == mParent)
    {
      mParent = null;
      return;
    }
    throw new IllegalArgumentException("Invalid parent node provided");
  }
  
  public void update()
  {
    ValueAnimatedNode localValueAnimatedNode = mParent;
    if (localValueAnimatedNode == null) {
      return;
    }
    mValue = interpolate(localValueAnimatedNode.getValue(), mInputRange, mOutputRange, mExtrapolateLeft, mExtrapolateRight);
  }
}
