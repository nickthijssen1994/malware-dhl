package com.facebook.react.bridge;

import com.facebook.infer.annotation.Assertions;
import com.facebook.proguard.annotations.DoNotStrip;
import com.facebook.react.config.ReactFeatureFlags;
import com.facebook.upgrade.HybridData;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import javax.annotation.Nullable;

@DoNotStrip
public class ReadableNativeMap
  extends NativeMap
  implements ReadableMap
{
  private static int mJniCallCounter;
  @Nullable
  private String[] mKeys;
  @Nullable
  private HashMap<String, Object> mLocalMap;
  @Nullable
  private HashMap<String, ReadableType> mLocalTypeMap;
  
  static {}
  
  protected ReadableNativeMap(HybridData paramHybridData)
  {
    super(paramHybridData);
  }
  
  private void checkInstance(String paramString, Object paramObject, Class paramClass)
  {
    if (paramObject != null)
    {
      if (paramClass.isInstance(paramObject)) {
        return;
      }
      StringBuilder localStringBuilder = new StringBuilder();
      localStringBuilder.append("Value for ");
      localStringBuilder.append(paramString);
      localStringBuilder.append(" cannot be cast from ");
      localStringBuilder.append(paramObject.getClass().getSimpleName());
      localStringBuilder.append(" to ");
      localStringBuilder.append(paramClass.getSimpleName());
      throw new ClassCastException(localStringBuilder.toString());
    }
  }
  
  private native ReadableNativeArray getArrayNative(String paramString);
  
  private native boolean getBooleanNative(String paramString);
  
  private native double getDoubleNative(String paramString);
  
  private native int getIntNative(String paramString);
  
  public static int getJNIPassCounter()
  {
    return mJniCallCounter;
  }
  
  private HashMap getLocalMap()
  {
    Object localObject = mLocalMap;
    if (localObject != null) {
      return localObject;
    }
    try
    {
      if (mKeys == null)
      {
        mKeys = ((String[])Assertions.assertNotNull(importKeys()));
        mJniCallCounter += 1;
      }
      if (mLocalMap == null)
      {
        localObject = (Object[])Assertions.assertNotNull(importValues());
        mJniCallCounter += 1;
        int j = mKeys.length;
        mLocalMap = new HashMap(j);
        int i = 0;
        while (i < j)
        {
          mLocalMap.put(mKeys[i], localObject[i]);
          i += 1;
        }
      }
      return mLocalMap;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private HashMap getLocalTypeMap()
  {
    Object localObject = mLocalTypeMap;
    if (localObject != null) {
      return localObject;
    }
    try
    {
      if (mKeys == null)
      {
        mKeys = ((String[])Assertions.assertNotNull(importKeys()));
        mJniCallCounter += 1;
      }
      if (mLocalTypeMap == null)
      {
        localObject = (Object[])Assertions.assertNotNull(importTypes());
        mJniCallCounter += 1;
        int j = mKeys.length;
        mLocalTypeMap = new HashMap(j);
        int i = 0;
        while (i < j)
        {
          mLocalTypeMap.put(mKeys[i], (ReadableType)localObject[i]);
          i += 1;
        }
      }
      return mLocalTypeMap;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private native ReadableNativeMap getMapNative(String paramString);
  
  private Object getNullableValue(String paramString)
  {
    if (hasKey(paramString)) {
      return getLocalMap().get(paramString);
    }
    throw new NoSuchKeyException(paramString);
  }
  
  private Object getNullableValue(String paramString, Class paramClass)
  {
    Object localObject = getNullableValue(paramString);
    checkInstance(paramString, localObject, paramClass);
    return localObject;
  }
  
  private native String getStringNative(String paramString);
  
  private native ReadableType getTypeNative(String paramString);
  
  private Object getValue(String paramString)
  {
    if ((hasKey(paramString)) && (!isNull(paramString))) {
      return Assertions.assertNotNull(getLocalMap().get(paramString));
    }
    throw new NoSuchKeyException(paramString);
  }
  
  private Object getValue(String paramString, Class paramClass)
  {
    Object localObject = getValue(paramString);
    checkInstance(paramString, localObject, paramClass);
    return localObject;
  }
  
  private native boolean hasKeyNative(String paramString);
  
  private native String[] importKeys();
  
  private native Object[] importTypes();
  
  private native Object[] importValues();
  
  private native boolean isNullNative(String paramString);
  
  public static void setUseNativeAccessor(boolean paramBoolean)
  {
    ReactFeatureFlags.useMapNativeAccessor = paramBoolean;
  }
  
  public ReadableArray getArray(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getArrayNative(paramString);
    }
    return (ReadableArray)getNullableValue(paramString, ReadableArray.class);
  }
  
  public boolean getBoolean(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getBooleanNative(paramString);
    }
    return ((Boolean)getValue(paramString, Boolean.class)).booleanValue();
  }
  
  public double getDouble(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getDoubleNative(paramString);
    }
    return ((Double)getValue(paramString, Double.class)).doubleValue();
  }
  
  public Dynamic getDynamic(String paramString)
  {
    return DynamicFromMap.create(this, paramString);
  }
  
  public int getInt(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getIntNative(paramString);
    }
    return ((Double)getValue(paramString, Double.class)).intValue();
  }
  
  public ReadableNativeMap getMap(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getMapNative(paramString);
    }
    return (ReadableNativeMap)getNullableValue(paramString, ReadableNativeMap.class);
  }
  
  public String getString(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getStringNative(paramString);
    }
    return (String)getNullableValue(paramString, String.class);
  }
  
  public ReadableType getType(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return getTypeNative(paramString);
    }
    if (getLocalTypeMap().containsKey(paramString)) {
      return (ReadableType)Assertions.assertNotNull(getLocalTypeMap().get(paramString));
    }
    throw new NoSuchKeyException(paramString);
  }
  
  public boolean hasKey(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return hasKeyNative(paramString);
    }
    return getLocalMap().containsKey(paramString);
  }
  
  public boolean isNull(String paramString)
  {
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      mJniCallCounter += 1;
      return isNullNative(paramString);
    }
    if (getLocalMap().containsKey(paramString)) {
      return getLocalMap().get(paramString) == null;
    }
    throw new NoSuchKeyException(paramString);
  }
  
  public ReadableMapKeySetIterator keySetIterator()
  {
    return new ReadableNativeMapKeySetIterator(this);
  }
  
  public HashMap toHashMap()
  {
    String str;
    if (ReactFeatureFlags.useMapNativeAccessor)
    {
      localObject1 = keySetIterator();
      localObject2 = new HashMap();
      while (((ReadableMapKeySetIterator)localObject1).hasNextKey())
      {
        mJniCallCounter += 1;
        str = ((ReadableMapKeySetIterator)localObject1).nextKey();
        mJniCallCounter += 1;
        switch (1.$SwitchMap$com$facebook$react$bridge$ReadableType[getType(str).ordinal()])
        {
        default: 
          localObject1 = new StringBuilder();
          ((StringBuilder)localObject1).append("Could not convert object with key: ");
          ((StringBuilder)localObject1).append(str);
          ((StringBuilder)localObject1).append(".");
          throw new IllegalArgumentException(((StringBuilder)localObject1).toString());
        case 6: 
          ((HashMap)localObject2).put(str, ((ReadableArray)Assertions.assertNotNull(getArray(str))).toArrayList());
          break;
        case 5: 
          ((HashMap)localObject2).put(str, ((ReadableNativeMap)Assertions.assertNotNull(getMap(str))).toHashMap());
          break;
        case 4: 
          ((HashMap)localObject2).put(str, getString(str));
          break;
        case 3: 
          ((HashMap)localObject2).put(str, Double.valueOf(getDouble(str)));
          break;
        case 2: 
          ((HashMap)localObject2).put(str, Boolean.valueOf(getBoolean(str)));
          break;
        case 1: 
          ((HashMap)localObject2).put(str, null);
        }
      }
      return localObject2;
    }
    Object localObject1 = new HashMap(getLocalMap());
    Object localObject2 = ((HashMap)localObject1).keySet().iterator();
    while (((Iterator)localObject2).hasNext())
    {
      str = (String)((Iterator)localObject2).next();
      switch (1.$SwitchMap$com$facebook$react$bridge$ReadableType[getType(str).ordinal()])
      {
      case 1: 
      case 2: 
      case 3: 
      case 4: 
      default: 
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append("Could not convert object with key: ");
        ((StringBuilder)localObject1).append(str);
        ((StringBuilder)localObject1).append(".");
        throw new IllegalArgumentException(((StringBuilder)localObject1).toString());
      case 6: 
        ((HashMap)localObject1).put(str, ((ReadableArray)Assertions.assertNotNull(getArray(str))).toArrayList());
        break;
      case 5: 
        ((HashMap)localObject1).put(str, ((ReadableNativeMap)Assertions.assertNotNull(getMap(str))).toHashMap());
      }
    }
    return localObject1;
  }
  
  @DoNotStrip
  private static class ReadableNativeMapKeySetIterator
    implements ReadableMapKeySetIterator
  {
    @DoNotStrip
    private final HybridData mHybridData;
    @DoNotStrip
    private final ReadableNativeMap mMap;
    
    public ReadableNativeMapKeySetIterator(ReadableNativeMap paramReadableNativeMap)
    {
      mMap = paramReadableNativeMap;
      mHybridData = initHybrid(paramReadableNativeMap);
    }
    
    private static native HybridData initHybrid(ReadableNativeMap paramReadableNativeMap);
    
    public native boolean hasNextKey();
    
    public native String nextKey();
  }
}
