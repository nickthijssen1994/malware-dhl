package com.facebook.react.modules.netinfo;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import androidx.core.net.ConnectivityManagerCompat;
import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.modules.core.DeviceEventManagerModule.RCTDeviceEventEmitter;

@ReactModule(name="NetInfo")
@SuppressLint({"MissingPermission"})
public class NetInfoModule
  extends ReactContextBaseJavaModule
  implements LifecycleEventListener
{
  private static final String CONNECTION_TYPE_BLUETOOTH = "bluetooth";
  private static final String CONNECTION_TYPE_CELLULAR = "cellular";
  private static final String CONNECTION_TYPE_ETHERNET = "ethernet";
  private static final String CONNECTION_TYPE_NONE = "none";
  private static final String CONNECTION_TYPE_NONE_DEPRECATED = "NONE";
  private static final String CONNECTION_TYPE_UNKNOWN = "unknown";
  private static final String CONNECTION_TYPE_UNKNOWN_DEPRECATED = "UNKNOWN";
  private static final String CONNECTION_TYPE_WIFI = "wifi";
  private static final String CONNECTION_TYPE_WIMAX = "wimax";
  private static final String EFFECTIVE_CONNECTION_TYPE_2G = "2g";
  private static final String EFFECTIVE_CONNECTION_TYPE_3G = "3g";
  private static final String EFFECTIVE_CONNECTION_TYPE_4G = "4g";
  private static final String EFFECTIVE_CONNECTION_TYPE_UNKNOWN = "unknown";
  private static final String ERROR_MISSING_PERMISSION = "E_MISSING_PERMISSION";
  private static final String MISSING_PERMISSION_MESSAGE = "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />";
  public static final String NAME = "NetInfo";
  private String mConnectionType = "unknown";
  private final ConnectivityBroadcastReceiver mConnectivityBroadcastReceiver;
  private String mConnectivityDeprecated = "UNKNOWN";
  private final ConnectivityManager mConnectivityManager;
  private String mEffectiveConnectionType = "unknown";
  private boolean mNoNetworkPermission = false;
  
  public NetInfoModule(ReactApplicationContext paramReactApplicationContext)
  {
    super(paramReactApplicationContext);
    mConnectivityManager = ((ConnectivityManager)paramReactApplicationContext.getSystemService("connectivity"));
    mConnectivityBroadcastReceiver = new ConnectivityBroadcastReceiver(null);
  }
  
  private WritableMap createConnectivityEventMap()
  {
    WritableNativeMap localWritableNativeMap = new WritableNativeMap();
    localWritableNativeMap.putString("network_info", mConnectivityDeprecated);
    localWritableNativeMap.putString("connectionType", mConnectionType);
    localWritableNativeMap.putString("effectiveConnectionType", mEffectiveConnectionType);
    return localWritableNativeMap;
  }
  
  private String getCurrentConnectionType()
  {
    Object localObject = mConnectivityManager;
    try
    {
      localObject = ((ConnectivityManager)localObject).getActiveNetworkInfo();
      if (localObject != null)
      {
        boolean bool = ((NetworkInfo)localObject).isConnected();
        if (bool)
        {
          bool = ConnectivityManager.isNetworkTypeValid(((NetworkInfo)localObject).getType());
          if (bool)
          {
            localObject = ((NetworkInfo)localObject).getTypeName().toUpperCase();
            return localObject;
          }
          return "UNKNOWN";
        }
      }
      return "NONE";
    }
    catch (SecurityException localSecurityException)
    {
      for (;;) {}
    }
    mNoNetworkPermission = true;
    return "UNKNOWN";
  }
  
  private String getEffectiveConnectionType(NetworkInfo paramNetworkInfo)
  {
    switch (paramNetworkInfo.getSubtype())
    {
    default: 
      return "unknown";
    case 13: 
    case 15: 
      return "4g";
    case 3: 
    case 5: 
    case 6: 
    case 8: 
    case 9: 
    case 10: 
    case 12: 
    case 14: 
      return "3g";
    }
    return "2g";
  }
  
  private void registerReceiver()
  {
    Object localObject = new IntentFilter();
    ((IntentFilter)localObject).addAction("android.net.conn.CONNECTIVITY_CHANGE");
    try
    {
      ReactApplicationContext localReactApplicationContext = getReactApplicationContext();
      ConnectivityBroadcastReceiver localConnectivityBroadcastReceiver = mConnectivityBroadcastReceiver;
      localReactApplicationContext.registerReceiver(localConnectivityBroadcastReceiver, (IntentFilter)localObject);
      localObject = mConnectivityBroadcastReceiver;
      ((ConnectivityBroadcastReceiver)localObject).setRegistered(true);
    }
    catch (Exception localException)
    {
      for (;;) {}
    }
    mConnectivityBroadcastReceiver.setRegistered(false);
    updateAndSendConnectionType();
  }
  
  private void sendConnectivityChangedEvent()
  {
    ((DeviceEventManagerModule.RCTDeviceEventEmitter)getReactApplicationContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("networkStatusDidChange", createConnectivityEventMap());
  }
  
  private void unregisterReceiver()
  {
    if (mConnectivityBroadcastReceiver.isRegistered())
    {
      getReactApplicationContext().unregisterReceiver(mConnectivityBroadcastReceiver);
      mConnectivityBroadcastReceiver.setRegistered(false);
    }
  }
  
  private void updateAndSendConnectionType()
  {
    Object localObject2 = "unknown";
    Object localObject1 = mConnectivityManager;
    try
    {
      localObject1 = ((ConnectivityManager)localObject1).getActiveNetworkInfo();
      if (localObject1 != null)
      {
        boolean bool = ((NetworkInfo)localObject1).isConnected();
        if (bool)
        {
          int i = ((NetworkInfo)localObject1).getType();
          switch (i)
          {
          default: 
            break;
          case 2: 
          case 3: 
          case 5: 
          case 8: 
            localObject1 = "unknown";
            break;
          case 9: 
            localObject1 = "ethernet";
            break;
          case 7: 
            localObject1 = "bluetooth";
            break;
          case 6: 
            localObject1 = "wimax";
            break;
          case 1: 
            localObject1 = "wifi";
            break;
          }
          localObject1 = getEffectiveConnectionType((NetworkInfo)localObject1);
          str = "cellular";
          localObject2 = localObject1;
          localObject1 = str;
          break label194;
        }
      }
      localObject1 = "none";
    }
    catch (SecurityException localSecurityException)
    {
      String str;
      for (;;) {}
    }
    mNoNetworkPermission = true;
    localObject1 = "unknown";
    label194:
    str = getCurrentConnectionType();
    if ((!((String)localObject1).equalsIgnoreCase(mConnectionType)) || (!((String)localObject2).equalsIgnoreCase(mEffectiveConnectionType)) || (!str.equalsIgnoreCase(mConnectivityDeprecated)))
    {
      mConnectionType = ((String)localObject1);
      mEffectiveConnectionType = ((String)localObject2);
      mConnectivityDeprecated = str;
      sendConnectivityChangedEvent();
      return;
    }
  }
  
  public void getCurrentConnectivity(Promise paramPromise)
  {
    if (mNoNetworkPermission)
    {
      paramPromise.reject("E_MISSING_PERMISSION", "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />");
      return;
    }
    paramPromise.resolve(createConnectivityEventMap());
  }
  
  public String getName()
  {
    return "NetInfo";
  }
  
  public void initialize()
  {
    getReactApplicationContext().addLifecycleEventListener(this);
  }
  
  public void isConnectionMetered(Promise paramPromise)
  {
    if (mNoNetworkPermission)
    {
      paramPromise.reject("E_MISSING_PERMISSION", "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />");
      return;
    }
    paramPromise.resolve(Boolean.valueOf(ConnectivityManagerCompat.isActiveNetworkMetered(mConnectivityManager)));
  }
  
  public void onHostDestroy() {}
  
  public void onHostPause()
  {
    unregisterReceiver();
  }
  
  public void onHostResume()
  {
    registerReceiver();
  }
  
  private class ConnectivityBroadcastReceiver
    extends BroadcastReceiver
  {
    private boolean isRegistered = false;
    
    private ConnectivityBroadcastReceiver() {}
    
    public boolean isRegistered()
    {
      return isRegistered;
    }
    
    public void onReceive(Context paramContext, Intent paramIntent)
    {
      if (paramIntent.getAction().equals("android.net.conn.CONNECTIVITY_CHANGE")) {
        NetInfoModule.this.updateAndSendConnectionType();
      }
    }
    
    public void setRegistered(boolean paramBoolean)
    {
      isRegistered = paramBoolean;
    }
  }
}
