package com.facebook.react.modules.location;

import android.annotation.SuppressLint;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build.VERSION;
import android.os.Bundle;
import android.os.Handler;
import androidx.core.content.ContextCompat;
import com.facebook.common.logging.FLog;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.common.SystemClock;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.modules.core.DeviceEventManagerModule.RCTDeviceEventEmitter;
import javax.annotation.Nullable;

@ReactModule(name="LocationObserver")
@SuppressLint({"MissingPermission"})
public class LocationModule
  extends ReactContextBaseJavaModule
{
  public static final String NAME = "LocationObserver";
  private static final float RCT_DEFAULT_LOCATION_ACCURACY = 100.0F;
  private final LocationListener mLocationListener = new LocationListener()
  {
    public void onLocationChanged(Location paramAnonymousLocation)
    {
      ((DeviceEventManagerModule.RCTDeviceEventEmitter)getReactApplicationContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("geolocationDidChange", LocationModule.locationToMap(paramAnonymousLocation));
    }
    
    public void onProviderDisabled(String paramAnonymousString) {}
    
    public void onProviderEnabled(String paramAnonymousString) {}
    
    public void onStatusChanged(String paramAnonymousString, int paramAnonymousInt, Bundle paramAnonymousBundle)
    {
      StringBuilder localStringBuilder;
      if (paramAnonymousInt == 0)
      {
        paramAnonymousBundle = LocationModule.this;
        paramAnonymousInt = PositionError.POSITION_UNAVAILABLE;
        localStringBuilder = new StringBuilder();
        localStringBuilder.append("Provider ");
        localStringBuilder.append(paramAnonymousString);
        localStringBuilder.append(" is out of service.");
        paramAnonymousBundle.emitError(paramAnonymousInt, localStringBuilder.toString());
        return;
      }
      if (paramAnonymousInt == 1)
      {
        paramAnonymousBundle = LocationModule.this;
        paramAnonymousInt = PositionError.TIMEOUT;
        localStringBuilder = new StringBuilder();
        localStringBuilder.append("Provider ");
        localStringBuilder.append(paramAnonymousString);
        localStringBuilder.append(" is temporarily unavailable.");
        paramAnonymousBundle.emitError(paramAnonymousInt, localStringBuilder.toString());
      }
    }
  };
  @Nullable
  private String mWatchedProvider;
  
  public LocationModule(ReactApplicationContext paramReactApplicationContext)
  {
    super(paramReactApplicationContext);
  }
  
  private void emitError(int paramInt, String paramString)
  {
    ((DeviceEventManagerModule.RCTDeviceEventEmitter)getReactApplicationContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("geolocationError", PositionError.buildError(paramInt, paramString));
  }
  
  private String getValidProvider(LocationManager paramLocationManager, boolean paramBoolean)
  {
    String str1;
    if (paramBoolean) {
      str1 = "gps";
    } else {
      str1 = "network";
    }
    String str2 = str1;
    if (!paramLocationManager.isProviderEnabled(str1))
    {
      if (str1.equals("gps")) {
        str1 = "network";
      } else {
        str1 = "gps";
      }
      str2 = str1;
      if (!paramLocationManager.isProviderEnabled(str1)) {
        return null;
      }
    }
    int i = ContextCompat.checkSelfPermission(getReactApplicationContext(), "android.permission.ACCESS_FINE_LOCATION");
    if ((str2.equals("gps")) && (i != 0)) {
      return null;
    }
    return str2;
  }
  
  private static WritableMap locationToMap(Location paramLocation)
  {
    WritableMap localWritableMap1 = Arguments.createMap();
    WritableMap localWritableMap2 = Arguments.createMap();
    localWritableMap2.putDouble("latitude", paramLocation.getLatitude());
    localWritableMap2.putDouble("longitude", paramLocation.getLongitude());
    localWritableMap2.putDouble("altitude", paramLocation.getAltitude());
    localWritableMap2.putDouble("accuracy", paramLocation.getAccuracy());
    localWritableMap2.putDouble("heading", paramLocation.getBearing());
    localWritableMap2.putDouble("speed", paramLocation.getSpeed());
    localWritableMap1.putMap("coords", localWritableMap2);
    localWritableMap1.putDouble("timestamp", paramLocation.getTime());
    if (Build.VERSION.SDK_INT >= 18) {
      localWritableMap1.putBoolean("mocked", paramLocation.isFromMockProvider());
    }
    return localWritableMap1;
  }
  
  private static void throwLocationPermissionMissing(SecurityException paramSecurityException)
  {
    throw new SecurityException("Looks like the app doesn't have the permission to access location.\nAdd the following line to your app's AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />", paramSecurityException);
  }
  
  public void getCurrentPosition(ReadableMap paramReadableMap, Callback paramCallback1, Callback paramCallback2)
  {
    paramReadableMap = LocationOptions.fromReactMap(paramReadableMap);
    try
    {
      Object localObject = getReactApplicationContext().getSystemService("location");
      localObject = (LocationManager)localObject;
      String str = getValidProvider((LocationManager)localObject, highAccuracy);
      if (str == null)
      {
        int i = PositionError.POSITION_UNAVAILABLE;
        paramReadableMap = PositionError.buildError(i, "No location provider available.");
        paramCallback2.invoke(new Object[] { paramReadableMap });
        return;
      }
      Location localLocation = ((LocationManager)localObject).getLastKnownLocation(str);
      if (localLocation != null)
      {
        long l1 = SystemClock.currentTimeMillis();
        long l2 = localLocation.getTime();
        double d1 = l1 - l2;
        double d2 = maximumAge;
        if (d1 < d2)
        {
          paramReadableMap = locationToMap(localLocation);
          paramCallback1.invoke(new Object[] { paramReadableMap });
          return;
        }
      }
      new SingleUpdateRequest((LocationManager)localObject, str, timeout, paramCallback1, paramCallback2, null).invoke(localLocation);
      return;
    }
    catch (SecurityException paramReadableMap)
    {
      throwLocationPermissionMissing(paramReadableMap);
    }
  }
  
  public String getName()
  {
    return "LocationObserver";
  }
  
  public void startObserving(ReadableMap paramReadableMap)
  {
    if ("gps".equals(mWatchedProvider)) {
      return;
    }
    paramReadableMap = LocationOptions.fromReactMap(paramReadableMap);
    try
    {
      Object localObject1 = getReactApplicationContext().getSystemService("location");
      localObject1 = (LocationManager)localObject1;
      String str = getValidProvider((LocationManager)localObject1, highAccuracy);
      if (str == null)
      {
        int i = PositionError.POSITION_UNAVAILABLE;
        emitError(i, "No location provider available.");
        return;
      }
      Object localObject2 = mWatchedProvider;
      boolean bool = str.equals(localObject2);
      if (!bool)
      {
        localObject2 = mLocationListener;
        ((LocationManager)localObject1).removeUpdates((LocationListener)localObject2);
        float f = distanceFilter;
        paramReadableMap = mLocationListener;
        ((LocationManager)localObject1).requestLocationUpdates(str, 1000L, f, paramReadableMap);
      }
      mWatchedProvider = str;
      return;
    }
    catch (SecurityException paramReadableMap)
    {
      throwLocationPermissionMissing(paramReadableMap);
    }
  }
  
  public void stopObserving()
  {
    ((LocationManager)getReactApplicationContext().getSystemService("location")).removeUpdates(mLocationListener);
    mWatchedProvider = null;
  }
  
  private static class LocationOptions
  {
    private final float distanceFilter;
    private final boolean highAccuracy;
    private final double maximumAge;
    private final long timeout;
    
    private LocationOptions(long paramLong, double paramDouble, boolean paramBoolean, float paramFloat)
    {
      timeout = paramLong;
      maximumAge = paramDouble;
      highAccuracy = paramBoolean;
      distanceFilter = paramFloat;
    }
    
    private static LocationOptions fromReactMap(ReadableMap paramReadableMap)
    {
      long l;
      if (paramReadableMap.hasKey("timeout")) {
        l = paramReadableMap.getDouble("timeout");
      } else {
        l = Long.MAX_VALUE;
      }
      double d;
      if (paramReadableMap.hasKey("maximumAge")) {
        d = paramReadableMap.getDouble("maximumAge");
      } else {
        d = Double.POSITIVE_INFINITY;
      }
      boolean bool;
      if ((paramReadableMap.hasKey("enableHighAccuracy")) && (paramReadableMap.getBoolean("enableHighAccuracy"))) {
        bool = true;
      } else {
        bool = false;
      }
      float f;
      if (paramReadableMap.hasKey("distanceFilter")) {
        f = (float)paramReadableMap.getDouble("distanceFilter");
      } else {
        f = 100.0F;
      }
      return new LocationOptions(l, d, bool, f);
    }
  }
  
  private static class SingleUpdateRequest
  {
    private static final int TWO_MINUTES = 120000;
    private final Callback mError;
    private final Handler mHandler = new Handler();
    private final LocationListener mLocationListener = new LocationListener()
    {
      public void onLocationChanged(Location paramAnonymousLocation)
      {
        LocationModule.SingleUpdateRequest localSingleUpdateRequest = LocationModule.SingleUpdateRequest.this;
        try
        {
          if ((!mTriggered) && (LocationModule.SingleUpdateRequest.this.isBetterLocation(paramAnonymousLocation, mOldLocation)))
          {
            mSuccess.invoke(new Object[] { LocationModule.locationToMap(paramAnonymousLocation) });
            mHandler.removeCallbacks(mTimeoutRunnable);
            LocationModule.SingleUpdateRequest.access$902(LocationModule.SingleUpdateRequest.this, true);
            mLocationManager.removeUpdates(mLocationListener);
          }
          LocationModule.SingleUpdateRequest.access$1302(LocationModule.SingleUpdateRequest.this, paramAnonymousLocation);
          return;
        }
        catch (Throwable paramAnonymousLocation)
        {
          throw paramAnonymousLocation;
        }
      }
      
      public void onProviderDisabled(String paramAnonymousString) {}
      
      public void onProviderEnabled(String paramAnonymousString) {}
      
      public void onStatusChanged(String paramAnonymousString, int paramAnonymousInt, Bundle paramAnonymousBundle) {}
    };
    private final LocationManager mLocationManager;
    private Location mOldLocation;
    private final String mProvider;
    private final Callback mSuccess;
    private final long mTimeout;
    private final Runnable mTimeoutRunnable = new Runnable()
    {
      public void run()
      {
        LocationModule.SingleUpdateRequest localSingleUpdateRequest = LocationModule.SingleUpdateRequest.this;
        try
        {
          if (!mTriggered)
          {
            mError.invoke(new Object[] { PositionError.buildError(PositionError.TIMEOUT, "Location request timed out") });
            mLocationManager.removeUpdates(mLocationListener);
            FLog.i("ReactNative", "LocationModule: Location request timed out");
            LocationModule.SingleUpdateRequest.access$902(LocationModule.SingleUpdateRequest.this, true);
          }
          return;
        }
        catch (Throwable localThrowable)
        {
          throw localThrowable;
        }
      }
    };
    private boolean mTriggered;
    
    private SingleUpdateRequest(LocationManager paramLocationManager, String paramString, long paramLong, Callback paramCallback1, Callback paramCallback2)
    {
      mLocationManager = paramLocationManager;
      mProvider = paramString;
      mTimeout = paramLong;
      mSuccess = paramCallback1;
      mError = paramCallback2;
    }
    
    private boolean isBetterLocation(Location paramLocation1, Location paramLocation2)
    {
      if (paramLocation2 == null) {
        return true;
      }
      long l = paramLocation1.getTime() - paramLocation2.getTime();
      int j;
      if (l > 120000L) {
        j = 1;
      } else {
        j = 0;
      }
      int k;
      if (l < -120000L) {
        k = 1;
      } else {
        k = 0;
      }
      int i;
      if (l > 0L) {
        i = 1;
      } else {
        i = 0;
      }
      if (j != 0) {
        return true;
      }
      if (k != 0) {
        return false;
      }
      int m = (int)(paramLocation1.getAccuracy() - paramLocation2.getAccuracy());
      if (m > 0) {
        j = 1;
      } else {
        j = 0;
      }
      if (m < 0) {
        k = 1;
      } else {
        k = 0;
      }
      if (m > 200) {
        m = 1;
      } else {
        m = 0;
      }
      boolean bool = isSameProvider(paramLocation1.getProvider(), paramLocation2.getProvider());
      if (k != 0) {
        return true;
      }
      if ((i != 0) && (j == 0)) {
        return true;
      }
      return (i != 0) && (m == 0) && (bool);
    }
    
    private boolean isSameProvider(String paramString1, String paramString2)
    {
      if (paramString1 == null) {
        return paramString2 == null;
      }
      return paramString1.equals(paramString2);
    }
    
    public void invoke(Location paramLocation)
    {
      mOldLocation = paramLocation;
      mLocationManager.requestLocationUpdates(mProvider, 100L, 1.0F, mLocationListener);
      mHandler.postDelayed(mTimeoutRunnable, mTimeout);
    }
  }
}
