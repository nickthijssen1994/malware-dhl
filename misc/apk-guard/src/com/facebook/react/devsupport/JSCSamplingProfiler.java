package com.facebook.react.devsupport;

import com.facebook.react.bridge.BaseJavaModule;
import com.facebook.react.bridge.JavaScriptModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.module.annotations.ReactModule;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import javax.annotation.Nullable;

@ReactModule(name="JSCSamplingProfiler", needsEagerInit=true)
public class JSCSamplingProfiler
  extends ReactContextBaseJavaModule
{
  private static final HashSet<JSCSamplingProfiler> sRegisteredDumpers = new HashSet();
  @Nullable
  private String mOperationError = null;
  private boolean mOperationInProgress = false;
  private int mOperationToken = 0;
  @Nullable
  private SamplingProfiler mSamplingProfiler = null;
  @Nullable
  private String mSamplingProfilerResult = null;
  
  public JSCSamplingProfiler(ReactApplicationContext paramReactApplicationContext)
  {
    super(paramReactApplicationContext);
  }
  
  private int getOperationToken()
    throws JSCSamplingProfiler.ProfilerException
  {
    if (!mOperationInProgress)
    {
      mOperationInProgress = true;
      int i = mOperationToken + 1;
      mOperationToken = i;
      return i;
    }
    throw new ProfilerException("Another operation already in progress.");
  }
  
  public static List poke(long paramLong)
    throws JSCSamplingProfiler.ProfilerException
  {
    try
    {
      LinkedList localLinkedList = new LinkedList();
      if (!sRegisteredDumpers.isEmpty())
      {
        Iterator localIterator = sRegisteredDumpers.iterator();
        while (localIterator.hasNext())
        {
          JSCSamplingProfiler localJSCSamplingProfiler = (JSCSamplingProfiler)localIterator.next();
          localJSCSamplingProfiler.pokeHelper(paramLong);
          localLinkedList.add(mSamplingProfilerResult);
        }
        return localLinkedList;
      }
      throw new ProfilerException("No JSC registered");
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private void pokeHelper(long paramLong)
    throws JSCSamplingProfiler.ProfilerException
  {
    try
    {
      if (mSamplingProfiler != null)
      {
        mSamplingProfiler.poke(getOperationToken());
        waitForOperation(paramLong);
        return;
      }
      throw new ProfilerException("SamplingProfiler.js module not connected");
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private static void registerSamplingProfiler(JSCSamplingProfiler paramJSCSamplingProfiler)
  {
    try
    {
      if (!sRegisteredDumpers.contains(paramJSCSamplingProfiler))
      {
        sRegisteredDumpers.add(paramJSCSamplingProfiler);
        return;
      }
      throw new RuntimeException("a JSCSamplingProfiler registered more than once");
    }
    catch (Throwable paramJSCSamplingProfiler)
    {
      throw paramJSCSamplingProfiler;
    }
  }
  
  private static void unregisterSamplingProfiler(JSCSamplingProfiler paramJSCSamplingProfiler)
  {
    try
    {
      sRegisteredDumpers.remove(paramJSCSamplingProfiler);
      return;
    }
    catch (Throwable paramJSCSamplingProfiler)
    {
      throw paramJSCSamplingProfiler;
    }
  }
  
  private void waitForOperation(long paramLong)
    throws JSCSamplingProfiler.ProfilerException
  {
    try
    {
      wait(paramLong);
      if (!mOperationInProgress)
      {
        String str = mOperationError;
        if (str == null) {
          return;
        }
        throw new ProfilerException(str);
      }
      mOperationInProgress = false;
      throw new ProfilerException("heap capture timed out.");
    }
    catch (InterruptedException localInterruptedException)
    {
      StringBuilder localStringBuilder = new StringBuilder();
      localStringBuilder.append("Waiting for heap capture failed: ");
      localStringBuilder.append(localInterruptedException.getMessage());
      throw new ProfilerException(localStringBuilder.toString());
    }
  }
  
  public String getName()
  {
    return "JSCSamplingProfiler";
  }
  
  public void initialize()
  {
    super.initialize();
    mSamplingProfiler = ((SamplingProfiler)getReactApplicationContext().getJSModule(SamplingProfiler.class));
    registerSamplingProfiler(this);
  }
  
  public void onCatalystInstanceDestroy()
  {
    super.onCatalystInstanceDestroy();
    unregisterSamplingProfiler(this);
    mSamplingProfiler = null;
  }
  
  public void operationComplete(int paramInt, String paramString1, String paramString2)
  {
    try
    {
      if (paramInt == mOperationToken)
      {
        mOperationInProgress = false;
        mSamplingProfilerResult = paramString1;
        mOperationError = paramString2;
        notify();
        return;
      }
      throw new RuntimeException("Completed operation is not in progress.");
    }
    catch (Throwable paramString1)
    {
      throw paramString1;
    }
  }
  
  public static class ProfilerException
    extends Exception
  {
    ProfilerException(String paramString)
    {
      super();
    }
  }
  
  public static abstract interface SamplingProfiler
    extends JavaScriptModule
  {
    public abstract void poke(int paramInt);
  }
}
