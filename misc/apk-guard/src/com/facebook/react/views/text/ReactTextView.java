package com.facebook.react.views.text;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.os.Build.VERSION;
import android.text.Layout;
import android.text.Spannable;
import android.text.Spanned;
import android.text.TextUtils.TruncateAt;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.widget.TextView;
import com.facebook.common.logging.FLog;
import com.facebook.react.uimanager.ReactCompoundView;
import com.facebook.react.views.view.ReactViewBackgroundManager;

public class ReactTextView
  extends TextView
  implements ReactCompoundView
{
  private static final ViewGroup.LayoutParams EMPTY_LAYOUT_PARAMS = new ViewGroup.LayoutParams(0, 0);
  private boolean mContainsImages;
  private int mDefaultGravityHorizontal = getGravity() & 0x800007;
  private int mDefaultGravityVertical = getGravity() & 0x70;
  private TextUtils.TruncateAt mEllipsizeLocation = TextUtils.TruncateAt.END;
  private int mNumberOfLines = Integer.MAX_VALUE;
  private ReactViewBackgroundManager mReactBackgroundManager = new ReactViewBackgroundManager(this);
  private Spannable mSpanned;
  private int mTextAlign = 0;
  
  public ReactTextView(Context paramContext)
  {
    super(paramContext);
  }
  
  public int getJustificationMode()
  {
    throw new Error("Unresolved compilation error: Method <com.facebook.react.views.text.ReactTextView: int getJustificationMode()> does not exist!");
  }
  
  public Spannable getSpanned()
  {
    return mSpanned;
  }
  
  public boolean hasOverlappingRendering()
  {
    return false;
  }
  
  public void invalidateDrawable(Drawable paramDrawable)
  {
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        if (localObject[i].getDrawable() == paramDrawable) {
          invalidate();
        }
        i += 1;
      }
    }
    super.invalidateDrawable(paramDrawable);
  }
  
  public void onAttachedToWindow()
  {
    super.onAttachedToWindow();
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        localObject[i].onAttachedToWindow();
        i += 1;
      }
    }
  }
  
  public void onDetachedFromWindow()
  {
    super.onDetachedFromWindow();
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        localObject[i].onDetachedFromWindow();
        i += 1;
      }
    }
  }
  
  public void onFinishTemporaryDetach()
  {
    super.onFinishTemporaryDetach();
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        localObject[i].onFinishTemporaryDetach();
        i += 1;
      }
    }
  }
  
  public void onStartTemporaryDetach()
  {
    super.onStartTemporaryDetach();
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        localObject[i].onStartTemporaryDetach();
        i += 1;
      }
    }
  }
  
  public int reactTagForTouch(float paramFloat1, float paramFloat2)
  {
    CharSequence localCharSequence = getText();
    int j = getId();
    int i = j;
    int k = (int)paramFloat1;
    int m = (int)paramFloat2;
    Object localObject2 = getLayout();
    if (localObject2 == null) {
      return j;
    }
    m = ((Layout)localObject2).getLineForVertical(m);
    int n = (int)((Layout)localObject2).getLineLeft(m);
    int i1 = (int)((Layout)localObject2).getLineRight(m);
    if (((localCharSequence instanceof Spanned)) && (k >= n) && (k <= i1))
    {
      Object localObject1 = (Spanned)localCharSequence;
      paramFloat1 = k;
      try
      {
        int i2 = ((Layout)localObject2).getOffsetForHorizontal(m, paramFloat1);
        localObject2 = (ReactTagSpan[])((Spanned)localObject1).getSpans(i2, i2, ReactTagSpan.class);
        if (localObject2 != null)
        {
          j = localCharSequence.length();
          k = 0;
          m = i;
          i = k;
          while (i < localObject2.length)
          {
            i1 = ((Spanned)localObject1).getSpanStart(localObject2[i]);
            int i3 = ((Spanned)localObject1).getSpanEnd(localObject2[i]);
            n = m;
            k = j;
            if (i3 > i2)
            {
              i1 = i3 - i1;
              n = m;
              k = j;
              if (i1 <= j)
              {
                n = localObject2[i].getReactTag();
                k = i1;
              }
            }
            i += 1;
            m = n;
            j = k;
          }
        }
        return j;
      }
      catch (ArrayIndexOutOfBoundsException localArrayIndexOutOfBoundsException)
      {
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append("Crash in HorizontalMeasurementProvider: ");
        ((StringBuilder)localObject1).append(localArrayIndexOutOfBoundsException.getMessage());
        FLog.e("ReactNative", ((StringBuilder)localObject1).toString());
      }
    }
    return m;
  }
  
  public void setBackgroundColor(int paramInt)
  {
    mReactBackgroundManager.setBackgroundColor(paramInt);
  }
  
  public void setBorderColor(int paramInt, float paramFloat1, float paramFloat2)
  {
    mReactBackgroundManager.setBorderColor(paramInt, paramFloat1, paramFloat2);
  }
  
  public void setBorderRadius(float paramFloat)
  {
    mReactBackgroundManager.setBorderRadius(paramFloat);
  }
  
  public void setBorderRadius(float paramFloat, int paramInt)
  {
    mReactBackgroundManager.setBorderRadius(paramFloat, paramInt);
  }
  
  public void setBorderStyle(String paramString)
  {
    mReactBackgroundManager.setBorderStyle(paramString);
  }
  
  public void setBorderWidth(int paramInt, float paramFloat)
  {
    mReactBackgroundManager.setBorderWidth(paramInt, paramFloat);
  }
  
  public void setEllipsizeLocation(TextUtils.TruncateAt paramTruncateAt)
  {
    mEllipsizeLocation = paramTruncateAt;
  }
  
  void setGravityHorizontal(int paramInt)
  {
    int i = paramInt;
    if (paramInt == 0) {
      i = mDefaultGravityHorizontal;
    }
    setGravity(i | getGravity() & 0xFFFFFFF8 & 0xFF7FFFF8);
  }
  
  void setGravityVertical(int paramInt)
  {
    int i = paramInt;
    if (paramInt == 0) {
      i = mDefaultGravityVertical;
    }
    setGravity(i | getGravity() & 0xFFFFFF8F);
  }
  
  public void setJustificationMode(int paramInt)
  {
    throw new Error("Unresolved compilation error: Method <com.facebook.react.views.text.ReactTextView: void setJustificationMode(int)> does not exist!");
  }
  
  public void setNumberOfLines(int paramInt)
  {
    boolean bool = false;
    int i = paramInt;
    if (paramInt < 0) {
      i = 0;
    }
    paramInt = i;
    if (i == 0) {
      paramInt = Integer.MAX_VALUE;
    }
    mNumberOfLines = paramInt;
    if (mNumberOfLines == 1) {
      bool = true;
    }
    setSingleLine(bool);
    setMaxLines(mNumberOfLines);
  }
  
  public void setSpanned(Spannable paramSpannable)
  {
    mSpanned = paramSpannable;
  }
  
  public void setText(ReactTextUpdate paramReactTextUpdate)
  {
    mContainsImages = paramReactTextUpdate.containsImages();
    if (getLayoutParams() == null) {
      setLayoutParams(EMPTY_LAYOUT_PARAMS);
    }
    setText(paramReactTextUpdate.getText());
    setPadding((int)Math.floor(paramReactTextUpdate.getPaddingLeft()), (int)Math.floor(paramReactTextUpdate.getPaddingTop()), (int)Math.floor(paramReactTextUpdate.getPaddingRight()), (int)Math.floor(paramReactTextUpdate.getPaddingBottom()));
    int i = paramReactTextUpdate.getTextAlign();
    if (mTextAlign != i) {
      mTextAlign = i;
    }
    setGravityHorizontal(mTextAlign);
    if ((Build.VERSION.SDK_INT >= 23) && (getBreakStrategy() != paramReactTextUpdate.getTextBreakStrategy())) {
      setBreakStrategy(paramReactTextUpdate.getTextBreakStrategy());
    }
    if ((Build.VERSION.SDK_INT >= 26) && (getJustificationMode() != paramReactTextUpdate.getJustificationMode())) {
      setJustificationMode(paramReactTextUpdate.getJustificationMode());
    }
  }
  
  public void updateView()
  {
    TextUtils.TruncateAt localTruncateAt;
    if (mNumberOfLines == Integer.MAX_VALUE) {
      localTruncateAt = null;
    } else {
      localTruncateAt = mEllipsizeLocation;
    }
    setEllipsize(localTruncateAt);
  }
  
  protected boolean verifyDrawable(Drawable paramDrawable)
  {
    if ((mContainsImages) && ((getText() instanceof Spanned)))
    {
      Object localObject = (Spanned)getText();
      int j = ((CharSequence)localObject).length();
      int i = 0;
      localObject = (TextInlineImageSpan[])((Spanned)localObject).getSpans(0, j, TextInlineImageSpan.class);
      j = localObject.length;
      while (i < j)
      {
        if (localObject[i].getDrawable() == paramDrawable) {
          return true;
        }
        i += 1;
      }
    }
    return super.verifyDrawable(paramDrawable);
  }
}
