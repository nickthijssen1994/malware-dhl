package com.facebook.react.views.scroll;

import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.View.OnLayoutChangeListener;
import android.view.ViewGroup;
import android.view.ViewGroup.OnHierarchyChangeListener;
import android.widget.OverScroller;
import android.widget.ScrollView;
import androidx.core.view.ViewCompat;
import com.facebook.infer.annotation.Assertions;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.uimanager.MeasureSpecAssertions;
import com.facebook.react.uimanager.ReactClippingViewGroup;
import com.facebook.react.uimanager.ReactClippingViewGroupHelper;
import com.facebook.react.uimanager.events.NativeGestureUtil;
import com.facebook.react.views.view.ReactViewBackgroundManager;
import java.lang.reflect.Field;
import java.util.List;
import javax.annotation.Nullable;

public class ReactScrollView
  extends ScrollView
  implements View.OnLayoutChangeListener, ViewGroup.OnHierarchyChangeListener, ReactClippingViewGroup
{
  @Nullable
  private static Field sScrollerField;
  private static boolean sTriedToGetScrollerField;
  int currentX;
  int currentY;
  int currentY_position = 0;
  private int delta = 0;
  ViewGroup isDragging;
  private boolean isScrolling = false;
  private boolean mActivelyScrolling;
  private boolean mBlcok = false;
  private ReactScrollView mChildReactScrollView;
  @Nullable
  private Rect mClippingRect;
  private View mContentView;
  private float mDecelerationRate = 0.985F;
  private boolean mDoneFlinging;
  private boolean mDragging;
  @Nullable
  private Drawable mEndBackground;
  private int mEndFillColor = 0;
  private boolean mFlinging;
  @Nullable
  private FpsListener mFpsListener = null;
  boolean mInterceptScrollEnabled = false;
  boolean mOnInterceptTouchEvent = false;
  private final OnScrollDispatchHelper mOnScrollDispatchHelper = new OnScrollDispatchHelper();
  @Nullable
  private String mOverflow = "hidden";
  private boolean mPagingEnabled = false;
  boolean mPassToChildren = false;
  @Nullable
  private Runnable mPostTouchRunnable;
  private ReactViewBackgroundManager mReactBackgroundManager;
  private final Rect mRect = new Rect();
  private boolean mRemoveClippedSubviews;
  private boolean mScrollEnabled = true;
  @Nullable
  private String mScrollPerfTag;
  @Nullable
  private final OverScroller mScroller;
  private boolean mSendMomentumEvents;
  private int mSnapInterval = 0;
  @Nullable
  private List<Integer> mSnapOffsets;
  private boolean mSnapToEnd = true;
  private boolean mSnapToStart = true;
  boolean mTouchEventEnable = false;
  private final VelocityHelper mVelocityHelper = new VelocityHelper();
  int scrollY_P;
  int scroll_postion = 0;
  private ViewGroup viewGroupH;
  
  public ReactScrollView(ReactContext paramReactContext)
  {
    this(paramReactContext, null);
  }
  
  public ReactScrollView(ReactContext paramReactContext, FpsListener paramFpsListener)
  {
    super(paramReactContext);
    mFpsListener = paramFpsListener;
    mReactBackgroundManager = new ReactViewBackgroundManager(this);
    mScroller = getOverScrollerFromParent();
    setOnHierarchyChangeListener(this);
    setScrollBarStyle(33554432);
  }
  
  private boolean bolckevent(MotionEvent paramMotionEvent)
  {
    if (getChildCount() > 0)
    {
      Object localObject = mChildReactScrollView;
      if ((localObject != null) && (((ViewGroup)localObject).getChildCount() <= 0)) {
        return true;
      }
      int i;
      int j;
      int k;
      if ((mChildReactScrollView != null) && ((paramMotionEvent.getAction() == 2) || (paramMotionEvent.getAction() == 1)))
      {
        i = getChildAt(0).getMeasuredHeight();
        j = getMeasuredHeight();
        k = getScrollY();
        int m = (int)paramMotionEvent.getY();
        float f;
        if ((scrollY_P > m) && ((paramMotionEvent.getAction() != 1) || (delta >= 0)))
        {
          if (((scrollY_P > m) || ((paramMotionEvent.getAction() == 1) && (delta > 0))) && (k >= i - j))
          {
            if (paramMotionEvent.getAction() != 1)
            {
              requestDisallowInterceptTouchEvent(true);
              mChildReactScrollView.smoothScrollBy(0, scrollY_P - m);
            }
            else
            {
              f = delta / 0.02F;
              mChildReactScrollView.fling((int)f);
              delta = 0;
            }
            scrollY_P = m;
            return false;
          }
        }
        else
        {
          localObject = mChildReactScrollView.getChildAt(0);
          if (localObject != null)
          {
            ((View)localObject).getMeasuredHeight();
            getMeasuredHeight();
            if (mChildReactScrollView.getScrollY() > 0)
            {
              if (paramMotionEvent.getAction() != 1)
              {
                mChildReactScrollView.smoothScrollBy(0, scrollY_P - m);
                requestDisallowInterceptTouchEvent(true);
              }
              else
              {
                f = delta / 0.02F;
                mChildReactScrollView.fling((int)f);
                delta = 0;
              }
              delta = (scrollY_P - m);
              scrollY_P = m;
              return false;
            }
          }
        }
        scrollY_P = m;
      }
      if ((mPassToChildren) && ((paramMotionEvent.getAction() == 2) || (paramMotionEvent.getAction() == 1)))
      {
        if (!mDragging)
        {
          mScroller.getStartX();
          mScroller.getStartY();
          mScroller.getCurrX();
          mScroller.getCurrY();
          if (scroll_postion != getScrollY())
          {
            NativeGestureUtil.notifyNativeGestureStarted(this, paramMotionEvent);
            ReactScrollViewHelper.emitScrollBeginDragEvent(this);
            mDragging = true;
          }
          if (Math.abs(paramMotionEvent.getY() - currentY_position) >= 20.0F)
          {
            NativeGestureUtil.notifyNativeGestureStarted(this, paramMotionEvent);
            ReactScrollViewHelper.emitScrollBeginDragEvent(this);
            mDragging = true;
          }
        }
        getChildAt(0).getMeasuredHeight();
        getMeasuredHeight();
        j = getScrollY();
        i = (int)paramMotionEvent.getY();
        if (viewGroupH == null) {
          viewGroupH = getScrollViewH();
        }
        k = scrollY_P;
        if (k < i)
        {
          if (j <= 0)
          {
            paramMotionEvent = viewGroupH;
            if (paramMotionEvent != null) {
              paramMotionEvent.requestDisallowInterceptTouchEvent(false);
            }
            scrollY_P = i;
            return false;
          }
          paramMotionEvent = viewGroupH;
          if (paramMotionEvent != null) {
            paramMotionEvent.requestDisallowInterceptTouchEvent(true);
          }
        }
        else if (k > i)
        {
          paramMotionEvent = viewGroupH;
          if ((paramMotionEvent != null) && (paramMotionEvent.getChildCount() > 0))
          {
            j = viewGroupH.getChildAt(0).getMeasuredHeight();
            k = viewGroupH.getMeasuredHeight();
            if (viewGroupH.getScrollY() < j - k)
            {
              viewGroupH.requestDisallowInterceptTouchEvent(false);
              return false;
            }
            viewGroupH.requestDisallowInterceptTouchEvent(true);
          }
        }
        scrollY_P = i;
      }
    }
    return true;
  }
  
  private void disableFpsListener()
  {
    if (isScrollPerfLoggingEnabled())
    {
      Assertions.assertNotNull(mFpsListener);
      Assertions.assertNotNull(mScrollPerfTag);
      mFpsListener.disable(mScrollPerfTag);
    }
  }
  
  private void enableFpsListener()
  {
    if (isScrollPerfLoggingEnabled())
    {
      Assertions.assertNotNull(mFpsListener);
      Assertions.assertNotNull(mScrollPerfTag);
      mFpsListener.enable(mScrollPerfTag);
    }
  }
  
  private void flingAndSnap(int paramInt)
  {
    if (getChildCount() <= 0) {
      return;
    }
    if ((mSnapInterval == 0) && (mSnapOffsets == null))
    {
      smoothScrollAndSnap(paramInt);
      return;
    }
    int i1 = getMaxScrollY();
    int i4 = predictFinalScrollPosition(paramInt);
    int i2 = i4;
    int i7 = getHeight();
    int i8 = getPaddingBottom();
    int i9 = getPaddingTop();
    Object localObject = mSnapOffsets;
    int k;
    int n;
    int m;
    double d1;
    if (localObject != null)
    {
      int i6 = ((Integer)((List)localObject).get(0)).intValue();
      localObject = mSnapOffsets;
      i5 = ((Integer)((List)localObject).get(((List)localObject).size() - 1)).intValue();
      j = i1;
      k = 0;
      i = 0;
      while (k < mSnapOffsets.size())
      {
        n = ((Integer)mSnapOffsets.get(k)).intValue();
        m = i;
        if (n <= i4)
        {
          m = i;
          if (i4 - n < i4 - i) {
            m = n;
          }
        }
        i3 = j;
        if (n >= i4)
        {
          i3 = j;
          if (n - i4 < j - i4) {
            i3 = n;
          }
        }
        k += 1;
        i = m;
        j = i3;
      }
      m = i6;
      k = i5;
    }
    else
    {
      d1 = getSnapInterval();
      double d2 = i4;
      Double.isNaN(d2);
      Double.isNaN(d1);
      d2 /= d1;
      double d3 = Math.floor(d2);
      Double.isNaN(d1);
      i = (int)(d3 * d1);
      d2 = Math.ceil(d2);
      Double.isNaN(d1);
      j = Math.min((int)(d2 * d1), i1);
      k = i1;
      m = 0;
    }
    int i3 = i4 - i;
    int i5 = j - i4;
    if (i3 < i5) {
      n = i;
    } else {
      n = j;
    }
    if ((!mSnapToEnd) && (i4 >= k))
    {
      if (getScrollY() < k)
      {
        i = k;
        break label493;
      }
    }
    else
    {
      if ((mSnapToStart) || (i4 > m)) {
        break label435;
      }
      if (getScrollY() > m) {
        break label428;
      }
    }
    int i = i2;
    break label493;
    label428:
    i = m;
    break label493;
    label435:
    if (paramInt > 0)
    {
      d1 = i5;
      Double.isNaN(d1);
      paramInt += (int)(d1 * 10.0D);
      i = j;
    }
    else if (paramInt < 0)
    {
      d1 = i3;
      Double.isNaN(d1);
      paramInt -= (int)(d1 * 10.0D);
    }
    else
    {
      i = n;
    }
    label493:
    int j = Math.min(Math.max(0, i), i1);
    localObject = mScroller;
    if (localObject != null)
    {
      mActivelyScrolling = true;
      k = getScrollX();
      m = getScrollY();
      if (paramInt == 0) {
        paramInt = j - getScrollY();
      }
      if ((j != 0) && (j != i1)) {
        i = 0;
      } else {
        i = (i7 - i8 - i9) / 2;
      }
      ((OverScroller)localObject).fling(k, m, 0, paramInt, 0, 0, j, j, 0, i);
      postInvalidateOnAnimation();
      return;
    }
    smoothScrollTo(getScrollX(), j);
  }
  
  private int getMaxScrollY()
  {
    return Math.max(0, mContentView.getHeight() - (getHeight() - getPaddingBottom() - getPaddingTop()));
  }
  
  private OverScroller getOverScrollerFromParent()
  {
    if (!sTriedToGetScrollerField) {
      sTriedToGetScrollerField = true;
    }
    try
    {
      localObject = ScrollView.class.getDeclaredField("mScroller");
      sScrollerField = (Field)localObject;
      localObject = sScrollerField;
      ((Field)localObject).setAccessible(true);
    }
    catch (NoSuchFieldException localNoSuchFieldException)
    {
      Object localObject;
      for (;;) {}
    }
    Log.w("ReactNative", "Failed to get mScroller field for ScrollView! This app will exhibit the bounce-back scrolling bug :(");
    localObject = sScrollerField;
    if (localObject != null) {
      try
      {
        localObject = ((Field)localObject).get(this);
        if ((localObject instanceof OverScroller)) {
          return (OverScroller)localObject;
        }
        Log.w("ReactNative", "Failed to cast mScroller field in ScrollView (probably due to OEM changes to AOSP)! This app will exhibit the bounce-back scrolling bug :(");
        return null;
      }
      catch (IllegalAccessException localIllegalAccessException)
      {
        throw new RuntimeException("Failed to get mScroller from ScrollView!", localIllegalAccessException);
      }
    }
    return null;
  }
  
  private ViewGroup getScrollView()
  {
    for (Object localObject = this; (localObject != null) && (((View)localObject).getParent() != null) && (!(((View)localObject).getParent() instanceof ReactHorizontalScrollView)); localObject = (View)((View)localObject).getParent()) {
      if (!(((View)localObject).getParent() instanceof View)) {
        return null;
      }
    }
    if ((localObject != null) && ((((View)localObject).getParent() instanceof ReactHorizontalScrollView))) {
      return (ViewGroup)((View)localObject).getParent();
    }
    return null;
  }
  
  private ViewGroup getScrollViewH()
  {
    for (Object localObject = this; (localObject != null) && (((View)localObject).getParent() != null) && (!(((View)localObject).getParent() instanceof ReactScrollView)); localObject = (View)((View)localObject).getParent()) {}
    if ((localObject != null) && ((((View)localObject).getParent() instanceof ReactScrollView))) {
      return (ViewGroup)((View)localObject).getParent();
    }
    return null;
  }
  
  private int getSnapInterval()
  {
    int i = mSnapInterval;
    if (i != 0) {
      return i;
    }
    return getHeight();
  }
  
  private void handlePostTouchScrolling(int paramInt1, int paramInt2)
  {
    if ((!mSendMomentumEvents) && (!mPagingEnabled) && (!isScrollPerfLoggingEnabled())) {
      return;
    }
    if (mPostTouchRunnable != null) {
      return;
    }
    if (mSendMomentumEvents)
    {
      enableFpsListener();
      ReactScrollViewHelper.emitScrollMomentumBeginEvent(this, paramInt1, paramInt2);
    }
    mActivelyScrolling = false;
    mPostTouchRunnable = new Runnable()
    {
      private boolean mSnappingToPage = false;
      
      public void run()
      {
        if (mActivelyScrolling)
        {
          ReactScrollView.access$002(ReactScrollView.this, false);
          ViewCompat.postOnAnimationDelayed(ReactScrollView.this, this, 20L);
          return;
        }
        if ((mPagingEnabled) && (!mSnappingToPage))
        {
          mSnappingToPage = true;
          ReactScrollView.this.flingAndSnap(0);
          ViewCompat.postOnAnimationDelayed(ReactScrollView.this, this, 20L);
          return;
        }
        if (mSendMomentumEvents) {
          ReactScrollViewHelper.emitScrollMomentumEndEvent(ReactScrollView.this);
        }
        ReactScrollView.access$402(ReactScrollView.this, null);
        ReactScrollView.this.disableFpsListener();
      }
    };
    ViewCompat.postOnAnimationDelayed(this, mPostTouchRunnable, 20L);
  }
  
  private boolean isScrollPerfLoggingEnabled()
  {
    if (mFpsListener != null)
    {
      String str = mScrollPerfTag;
      if ((str != null) && (!str.isEmpty())) {
        return true;
      }
    }
    return false;
  }
  
  private int predictFinalScrollPosition(int paramInt)
  {
    OverScroller localOverScroller = new OverScroller(getContext());
    localOverScroller.setFriction(1.0F - mDecelerationRate);
    int i = getMaxScrollY();
    int j = getHeight();
    int k = getPaddingBottom();
    int m = getPaddingTop();
    localOverScroller.fling(getScrollX(), getScrollY(), 0, paramInt, 0, 0, 0, i, 0, (j - k - m) / 2);
    return localOverScroller.getFinalY();
  }
  
  private void smoothScrollAndSnap(int paramInt)
  {
    double d2 = getSnapInterval();
    double d1 = getScrollY();
    double d3 = predictFinalScrollPosition(paramInt);
    Double.isNaN(d1);
    Double.isNaN(d2);
    double d4 = d1 / d2;
    int k = (int)Math.floor(d4);
    int n = (int)Math.ceil(d4);
    int m = (int)Math.round(d4);
    Double.isNaN(d3);
    Double.isNaN(d2);
    int i1 = (int)Math.round(d3 / d2);
    int j;
    int i;
    if ((paramInt > 0) && (n == k))
    {
      j = n + 1;
      i = k;
    }
    else
    {
      i = k;
      j = n;
      if (paramInt < 0)
      {
        i = k;
        j = n;
        if (k == n)
        {
          i = k - 1;
          j = n;
        }
      }
    }
    if ((paramInt > 0) && (m < j) && (i1 > i))
    {
      k = j;
    }
    else
    {
      k = m;
      if (paramInt < 0)
      {
        k = m;
        if (m > i)
        {
          k = m;
          if (i1 < j) {
            k = i;
          }
        }
      }
    }
    d3 = k;
    Double.isNaN(d3);
    Double.isNaN(d2);
    d2 = d3 * d2;
    if (d2 != d1)
    {
      mActivelyScrolling = true;
      smoothScrollTo(getScrollX(), (int)d2);
    }
  }
  
  public void computeScroll()
  {
    super.computeScroll();
    if ((mChildReactScrollView != null) || (mPassToChildren)) {
      if (mScroller.computeScrollOffset())
      {
        int i = getScrollX();
        int j = getScrollY();
        int k = mScroller.getCurrX();
        int m = mScroller.getCurrY();
        if (i == k)
        {
          if (j != m) {
            return;
          }
          mBlcok = false;
          isScrolling = false;
        }
      }
      else
      {
        mBlcok = false;
        isScrolling = false;
      }
    }
  }
  
  public void draw(Canvas paramCanvas)
  {
    int j = mEndFillColor;
    int i = 0;
    if (j != 0)
    {
      localObject = getChildAt(0);
      if ((mEndBackground != null) && (localObject != null) && (((View)localObject).getBottom() < getHeight()))
      {
        mEndBackground.setBounds(0, ((View)localObject).getBottom(), getWidth(), getHeight());
        mEndBackground.draw(paramCanvas);
      }
    }
    getDrawingRect(mRect);
    Object localObject = mOverflow;
    if ((((String)localObject).hashCode() != 466743410) || (!((String)localObject).equals("visible"))) {
      i = -1;
    }
    if (i != 0) {
      paramCanvas.clipRect(mRect);
    }
    super.draw(paramCanvas);
  }
  
  public void flashScrollIndicators()
  {
    awakenScrollBars();
  }
  
  public void fling(int paramInt)
  {
    float f2 = Math.signum(mOnScrollDispatchHelper.getYFlingVelocity());
    float f1 = f2;
    if (f2 == 0.0F) {
      f1 = Math.signum(paramInt);
    }
    int i = (int)(Math.abs(paramInt) * f1);
    if (mPagingEnabled)
    {
      paramInt = (int)(Math.abs(paramInt) * Math.signum(mOnScrollDispatchHelper.getYFlingVelocity()));
      flingAndSnap(paramInt);
    }
    else if (mScroller != null)
    {
      paramInt = getHeight();
      int j = getPaddingBottom();
      int k = getPaddingTop();
      mScroller.fling(getScrollX(), getScrollY(), 0, i, 0, 0, 0, Integer.MAX_VALUE, 0, (paramInt - j - k) / 2);
      ViewCompat.postInvalidateOnAnimation(this);
      paramInt = i;
    }
    else
    {
      super.fling(i);
      paramInt = i;
    }
    handlePostTouchScrolling(0, paramInt);
  }
  
  public void getClippingRect(Rect paramRect)
  {
    paramRect.set((Rect)Assertions.assertNotNull(mClippingRect));
  }
  
  public boolean getRemoveClippedSubviews()
  {
    return mRemoveClippedSubviews;
  }
  
  protected void onAttachedToWindow()
  {
    super.onAttachedToWindow();
    if (mRemoveClippedSubviews) {
      updateClippingRect();
    }
  }
  
  public void onChildViewAdded(View paramView1, View paramView2)
  {
    mContentView = paramView2;
    mContentView.addOnLayoutChangeListener(this);
  }
  
  public void onChildViewRemoved(View paramView1, View paramView2)
  {
    mContentView.removeOnLayoutChangeListener(this);
    mContentView = null;
  }
  
  public boolean onInterceptTouchEvent(MotionEvent paramMotionEvent)
  {
    if (!mScrollEnabled) {
      return false;
    }
    if (mInterceptScrollEnabled) {
      return false;
    }
    mBlcok = false;
    if (((mPassToChildren) || (mOnInterceptTouchEvent)) && (mPassToChildren))
    {
      viewGroupH = getScrollViewH();
      if (paramMotionEvent.getAction() == 1) {
        viewGroupH.requestDisallowInterceptTouchEvent(false);
      } else {
        ((ReactScrollView)viewGroupH).setScollView(this);
      }
    }
    if ((mChildReactScrollView != null) && ((paramMotionEvent.getAction() == 1) || (paramMotionEvent.getAction() == 0)))
    {
      scrollY_P = ((int)paramMotionEvent.getY());
      requestDisallowInterceptTouchEvent(false);
    }
    int i;
    int j;
    ViewGroup localViewGroup;
    if ((mOnInterceptTouchEvent) || (mPassToChildren)) {
      if (paramMotionEvent.getAction() == 0)
      {
        scrollY_P = ((int)paramMotionEvent.getY());
        viewGroupH = getScrollViewH();
        i = viewGroupH.getScrollY();
        scroll_postion = getScrollY();
        currentY_position = ((int)paramMotionEvent.getY());
        if ((getChildCount() > 0) && (viewGroupH.getChildCount() > 0))
        {
          j = viewGroupH.getChildAt(0).getMeasuredHeight();
          int k = viewGroupH.getMeasuredHeight();
          int m = getChildAt(0).getMeasuredHeight();
          int n = getMeasuredHeight();
          if ((i >= j - k) && (m - n > getHeight()))
          {
            if (mFlinging)
            {
              NativeGestureUtil.notifyNativeGestureStarted(this, paramMotionEvent);
              ReactScrollViewHelper.emitScrollBeginDragEvent(this);
              mDragging = true;
            }
            localViewGroup = viewGroupH;
            if (localViewGroup != null) {
              localViewGroup.requestDisallowInterceptTouchEvent(true);
            }
          }
        }
      }
      else if (paramMotionEvent.getAction() == 1)
      {
        scroll_postion = 0;
        viewGroupH = getScrollViewH();
        localViewGroup = viewGroupH;
        if (localViewGroup != null)
        {
          ((ReactScrollView)localViewGroup).setScollView(null);
          viewGroupH.requestDisallowInterceptTouchEvent(false);
        }
      }
    }
    if (mTouchEventEnable)
    {
      i = (int)paramMotionEvent.getX();
      j = (int)paramMotionEvent.getY();
      if (paramMotionEvent.getAction() == 0)
      {
        currentX = ((int)paramMotionEvent.getX());
        currentY = ((int)paramMotionEvent.getY());
        if (isDragging == null) {
          isDragging = getScrollView();
        }
        localViewGroup = isDragging;
        if (localViewGroup != null) {
          localViewGroup.requestDisallowInterceptTouchEvent(true);
        }
      }
      else if (paramMotionEvent.getAction() == 2)
      {
        if (Math.abs(currentX - i) > Math.abs(currentY - j) * 2)
        {
          if (isDragging == null) {
            isDragging = getScrollView();
          }
          localViewGroup = isDragging;
          if (localViewGroup != null) {
            localViewGroup.requestDisallowInterceptTouchEvent(false);
          }
          return super.onInterceptTouchEvent(paramMotionEvent);
        }
      }
      else if (paramMotionEvent.getAction() == 1)
      {
        if (isDragging == null) {
          isDragging = getScrollView();
        }
        paramMotionEvent = isDragging;
        if (paramMotionEvent == null) {
          break label576;
        }
        paramMotionEvent.requestDisallowInterceptTouchEvent(false);
        return false;
      }
    }
    try
    {
      boolean bool = super.onInterceptTouchEvent(paramMotionEvent);
      if (bool)
      {
        NativeGestureUtil.notifyNativeGestureStarted(this, paramMotionEvent);
        ReactScrollViewHelper.emitScrollBeginDragEvent(this);
        mDragging = true;
        enableFpsListener();
        return true;
      }
    }
    catch (IllegalArgumentException paramMotionEvent)
    {
      Log.w("ReactNative", "Error intercepting touch event.", paramMotionEvent);
    }
    label576:
    return false;
  }
  
  protected void onLayout(boolean paramBoolean, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    scrollTo(getScrollX(), getScrollY());
  }
  
  public void onLayoutChange(View paramView, int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
  {
    if (mContentView == null) {
      return;
    }
    paramInt1 = getScrollY();
    paramInt2 = getMaxScrollY();
    if (paramInt1 > paramInt2) {
      scrollTo(getScrollX(), paramInt2);
    }
  }
  
  protected void onMeasure(int paramInt1, int paramInt2)
  {
    MeasureSpecAssertions.assertExplicitMeasureSpec(paramInt1, paramInt2);
    setMeasuredDimension(View.MeasureSpec.getSize(paramInt1), View.MeasureSpec.getSize(paramInt2));
  }
  
  protected void onOverScrolled(int paramInt1, int paramInt2, boolean paramBoolean1, boolean paramBoolean2)
  {
    OverScroller localOverScroller = mScroller;
    int i = paramInt2;
    if (localOverScroller != null)
    {
      i = paramInt2;
      if (!localOverScroller.isFinished())
      {
        i = paramInt2;
        if (mScroller.getCurrY() != mScroller.getFinalY())
        {
          int j = getMaxScrollY();
          i = paramInt2;
          if (paramInt2 >= j)
          {
            mScroller.abortAnimation();
            i = j;
          }
        }
      }
    }
    super.onOverScrolled(paramInt1, i, paramBoolean1, paramBoolean2);
  }
  
  protected void onScrollChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    super.onScrollChanged(paramInt1, paramInt2, paramInt3, paramInt4);
    if (!mBlcok) {
      if (mChildReactScrollView != null)
      {
        if (getChildCount() >= 1)
        {
          View localView = getChildAt(0);
          if (localView != null)
          {
            paramInt3 = localView.getMeasuredHeight();
            paramInt4 = getMeasuredHeight();
            if (getScrollY() >= paramInt3 - paramInt4)
            {
              mChildReactScrollView.fling((int)mScroller.getCurrVelocity() / 5);
              mDoneFlinging = true;
            }
          }
        }
      }
      else if (mPassToChildren)
      {
        isScrolling = true;
        if ((getScrollY() <= 0) && (paramInt2 != paramInt4))
        {
          scrollTo(0, 0);
          ((ReactScrollView)getScrollViewH()).fling(-(int)mScroller.getCurrVelocity() / 5);
          mDoneFlinging = true;
        }
      }
    }
    mActivelyScrolling = true;
    if (mOnScrollDispatchHelper.onScrollChanged(paramInt1, paramInt2))
    {
      if (mRemoveClippedSubviews) {
        updateClippingRect();
      }
      ReactScrollViewHelper.emitScrollEvent(this, mOnScrollDispatchHelper.getXFlingVelocity(), mOnScrollDispatchHelper.getYFlingVelocity());
    }
  }
  
  protected void onSizeChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    super.onSizeChanged(paramInt1, paramInt2, paramInt3, paramInt4);
    if (mRemoveClippedSubviews) {
      updateClippingRect();
    }
  }
  
  public boolean onTouchEvent(MotionEvent paramMotionEvent)
  {
    if (!mScrollEnabled) {
      return false;
    }
    mVelocityHelper.calculateVelocity(paramMotionEvent);
    if ((mOnInterceptTouchEvent) && (paramMotionEvent.getAction() == 2))
    {
      Object localObject = getChildAt(0);
      int i;
      if (localObject != null) {
        i = ((View)localObject).getMeasuredHeight();
      } else {
        i = 0;
      }
      int j = getMeasuredHeight();
      int k = getScrollY();
      int m = (int)paramMotionEvent.getY();
      if (viewGroupH == null) {
        viewGroupH = getScrollViewH();
      }
      int n = scrollY_P;
      if (n < m)
      {
        if (k <= 0)
        {
          if (viewGroupH == null) {
            viewGroupH = getScrollViewH();
          }
          paramMotionEvent = viewGroupH;
          if (paramMotionEvent != null) {
            paramMotionEvent.requestDisallowInterceptTouchEvent(false);
          }
          scrollY_P = m;
          return false;
        }
        if (viewGroupH == null) {
          viewGroupH = getScrollView();
        }
        localObject = viewGroupH;
        if (localObject != null) {
          ((ViewGroup)localObject).requestDisallowInterceptTouchEvent(true);
        }
      }
      else if (n > m)
      {
        if (viewGroupH == null) {
          viewGroupH = getScrollViewH();
        }
        if (k >= i - j)
        {
          paramMotionEvent = viewGroupH;
          if (paramMotionEvent != null) {
            paramMotionEvent.requestDisallowInterceptTouchEvent(false);
          }
          scrollY_P = m;
          return false;
        }
        localObject = viewGroupH;
        if (localObject != null) {
          ((ViewGroup)localObject).requestDisallowInterceptTouchEvent(true);
        }
      }
      scrollY_P = m;
    }
    if (!bolckevent(paramMotionEvent)) {
      return false;
    }
    if (((paramMotionEvent.getAction() & 0xFF) == 1) && (mDragging))
    {
      float f1 = mVelocityHelper.getXVelocity();
      float f2 = mVelocityHelper.getYVelocity();
      ReactScrollViewHelper.emitScrollEndDragEvent(this, f1, f2);
      mDragging = false;
      handlePostTouchScrolling(Math.round(f1), Math.round(f2));
    }
    return super.onTouchEvent(paramMotionEvent);
  }
  
  public void scrollToPostion(int paramInt1, int paramInt2, boolean paramBoolean)
  {
    mBlcok = paramBoolean;
    scrollTo(paramInt1, paramInt2);
  }
  
  public void setBackgroundColor(int paramInt)
  {
    mReactBackgroundManager.setBackgroundColor(paramInt);
  }
  
  public void setBorderColor(int paramInt, float paramFloat1, float paramFloat2)
  {
    mReactBackgroundManager.setBorderColor(paramInt, paramFloat1, paramFloat2);
  }
  
  public void setBorderRadius(float paramFloat)
  {
    mReactBackgroundManager.setBorderRadius(paramFloat);
  }
  
  public void setBorderRadius(float paramFloat, int paramInt)
  {
    mReactBackgroundManager.setBorderRadius(paramFloat, paramInt);
  }
  
  public void setBorderStyle(String paramString)
  {
    mReactBackgroundManager.setBorderStyle(paramString);
  }
  
  public void setBorderWidth(int paramInt, float paramFloat)
  {
    mReactBackgroundManager.setBorderWidth(paramInt, paramFloat);
  }
  
  public void setDecelerationRate(float paramFloat)
  {
    mDecelerationRate = paramFloat;
    OverScroller localOverScroller = mScroller;
    if (localOverScroller != null) {
      localOverScroller.setFriction(1.0F - mDecelerationRate);
    }
  }
  
  public void setEndFillColor(int paramInt)
  {
    if (paramInt != mEndFillColor)
    {
      mEndFillColor = paramInt;
      mEndBackground = new ColorDrawable(mEndFillColor);
    }
  }
  
  public void setInterceptScrollEnabled(boolean paramBoolean)
  {
    mInterceptScrollEnabled = paramBoolean;
  }
  
  public void setOnInterceptEvent(boolean paramBoolean)
  {
    mOnInterceptTouchEvent = paramBoolean;
  }
  
  public void setOnTouchEventEnable(boolean paramBoolean)
  {
    mTouchEventEnable = paramBoolean;
    if (isDragging == null) {
      isDragging = getScrollView();
    }
    ViewGroup localViewGroup = isDragging;
    if (localViewGroup != null) {
      ((ReactHorizontalScrollView)localViewGroup).setOnTouchEvent(paramBoolean);
    }
  }
  
  public void setOverflow(String paramString)
  {
    mOverflow = paramString;
    invalidate();
  }
  
  public void setPagingEnabled(boolean paramBoolean)
  {
    mPagingEnabled = paramBoolean;
  }
  
  public void setPassToChildren(boolean paramBoolean)
  {
    mPassToChildren = paramBoolean;
    if (paramBoolean)
    {
      viewGroupH = getScrollViewH();
      ViewGroup localViewGroup = viewGroupH;
      if (localViewGroup != null) {
        ((ReactScrollView)localViewGroup).setScollView(this);
      }
    }
  }
  
  public void setRemoveClippedSubviews(boolean paramBoolean)
  {
    if ((paramBoolean) && (mClippingRect == null)) {
      mClippingRect = new Rect();
    }
    mRemoveClippedSubviews = paramBoolean;
    updateClippingRect();
  }
  
  public void setScollView(ReactScrollView paramReactScrollView)
  {
    mChildReactScrollView = paramReactScrollView;
  }
  
  public void setScrollEnabled(boolean paramBoolean)
  {
    mScrollEnabled = paramBoolean;
  }
  
  public void setScrollPerfTag(String paramString)
  {
    mScrollPerfTag = paramString;
  }
  
  public void setSendMomentumEvents(boolean paramBoolean)
  {
    mSendMomentumEvents = paramBoolean;
  }
  
  public void setSnapInterval(int paramInt)
  {
    mSnapInterval = paramInt;
  }
  
  public void setSnapOffsets(List paramList)
  {
    mSnapOffsets = paramList;
  }
  
  public void setSnapToEnd(boolean paramBoolean)
  {
    mSnapToEnd = paramBoolean;
  }
  
  public void setSnapToStart(boolean paramBoolean)
  {
    mSnapToStart = paramBoolean;
  }
  
  public void smoothScrollPostion(int paramInt1, int paramInt2, boolean paramBoolean)
  {
    mBlcok = paramBoolean;
    smoothScrollTo(paramInt1, paramInt2);
  }
  
  public void updateClippingRect()
  {
    if (!mRemoveClippedSubviews) {
      return;
    }
    Assertions.assertNotNull(mClippingRect);
    ReactClippingViewGroupHelper.calculateClippingRect(this, mClippingRect);
    View localView = getChildAt(0);
    if ((localView instanceof ReactClippingViewGroup)) {
      ((ReactClippingViewGroup)localView).updateClippingRect();
    }
  }
}
