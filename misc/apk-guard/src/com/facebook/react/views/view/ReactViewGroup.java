package com.facebook.react.views.view;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Path;
import android.graphics.Path.Direction;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.os.Build.VERSION;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.View.OnLayoutChangeListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ViewStructure;
import android.view.animation.Animation;
import androidx.viewpager.widget.ViewPager;
import com.facebook.common.logging.FLog;
import com.facebook.infer.annotation.Assertions;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.modules.i18nmanager.I18nUtil;
import com.facebook.react.touch.OnInterceptTouchEventListener;
import com.facebook.react.touch.ReactHitSlopView;
import com.facebook.react.touch.ReactInterceptingViewGroup;
import com.facebook.react.uimanager.IllegalViewOperationException;
import com.facebook.react.uimanager.MeasureSpecAssertions;
import com.facebook.react.uimanager.PointerEvents;
import com.facebook.react.uimanager.ReactClippingViewGroup;
import com.facebook.react.uimanager.ReactClippingViewGroupHelper;
import com.facebook.react.uimanager.ReactPointerEventsView;
import com.facebook.react.uimanager.ReactZIndexedViewGroup;
import com.facebook.react.uimanager.RootView;
import com.facebook.react.uimanager.RootViewUtil;
import com.facebook.react.uimanager.ViewGroupDrawingOrderHelper;
import com.facebook.react.views.scroll.ReactHorizontalScrollView;
import com.facebook.react.views.scroll.ReactScrollView;
import com.facebook.yoga.YogaConstants;
import javax.annotation.Nullable;

public class ReactViewGroup
  extends ViewGroup
  implements ReactHitSlopView, ReactInterceptingViewGroup, ReactClippingViewGroup, ReactPointerEventsView, ReactZIndexedViewGroup
{
  private static final int ARRAY_CAPACITY_INCREMENT = 12;
  private static final int DEFAULT_BACKGROUND_COLOR = 0;
  private static final ViewGroup.LayoutParams sDefaultLayoutParam = new ViewGroup.LayoutParams(0, 0);
  private static final Rect sHelperRect = new Rect();
  @Nullable
  private View[] mAllChildren = null;
  private int mAllChildrenCount;
  private float mBackfaceOpacity = 1.0F;
  private String mBackfaceVisibility = "visible";
  @Nullable
  private ChildrenLayoutChangeListener mChildrenLayoutChangeListener;
  @Nullable
  private Rect mClippingRect;
  private final ViewGroupDrawingOrderHelper mDrawingOrderHelper;
  boolean mEnableZindex = false;
  @Nullable
  private Rect mHitSlopRect;
  private int mLayoutDirection;
  private boolean mNeedsOffscreenAlphaCompositing = false;
  int mOnInterceptTouchEvent = 0;
  @Nullable
  private OnInterceptTouchEventListener mOnInterceptTouchEventListener;
  @Nullable
  private String mOverflow;
  @Nullable
  private Path mPath;
  private PointerEvents mPointerEvents = PointerEvents.AUTO;
  @Nullable
  private ReactViewBackgroundDrawable mReactBackgroundDrawable;
  private boolean mRemoveClippedSubviews = false;
  private int point_x = 0;
  private int point_y = 0;
  ViewGroup previewFrame;
  
  public ReactViewGroup(Context paramContext)
  {
    super(paramContext);
    setClipChildren(false);
    mDrawingOrderHelper = new ViewGroupDrawingOrderHelper(this);
  }
  
  private void addInArray(View paramView, int paramInt)
  {
    View[] arrayOfView1 = (View[])Assertions.assertNotNull(mAllChildren);
    int i = mAllChildrenCount;
    int j = arrayOfView1.length;
    if (paramInt == i)
    {
      View[] arrayOfView2 = arrayOfView1;
      if (j == i)
      {
        mAllChildren = new View[j + 12];
        System.arraycopy(arrayOfView1, 0, mAllChildren, 0, j);
        arrayOfView2 = mAllChildren;
      }
      paramInt = mAllChildrenCount;
      mAllChildrenCount = (paramInt + 1);
      arrayOfView2[paramInt] = paramView;
      return;
    }
    if (paramInt < i)
    {
      if (j == i)
      {
        mAllChildren = new View[j + 12];
        System.arraycopy(arrayOfView1, 0, mAllChildren, 0, paramInt);
        System.arraycopy(arrayOfView1, paramInt, mAllChildren, paramInt + 1, i - paramInt);
        arrayOfView1 = mAllChildren;
      }
      else
      {
        System.arraycopy(arrayOfView1, paramInt, arrayOfView1, paramInt + 1, i - paramInt);
      }
      arrayOfView1[paramInt] = paramView;
      mAllChildrenCount += 1;
      return;
    }
    paramView = new StringBuilder();
    paramView.append("index=");
    paramView.append(paramInt);
    paramView.append(" count=");
    paramView.append(i);
    throw new IndexOutOfBoundsException(paramView.toString());
  }
  
  private void dispatchOverflowDraw(Canvas paramCanvas)
  {
    Object localObject1 = mOverflow;
    if (localObject1 != null)
    {
      int i = -1;
      int j = ((String)localObject1).hashCode();
      if (j != -1217487446)
      {
        if ((j == 466743410) && (((String)localObject1).equals("visible"))) {
          i = 0;
        }
      }
      else if (((String)localObject1).equals("hidden")) {
        i = 1;
      }
      switch (i)
      {
      default: 
        
      case 1: 
        float f8 = getWidth();
        float f7 = getHeight();
        localObject1 = mReactBackgroundDrawable;
        float f6;
        float f5;
        if (localObject1 != null)
        {
          localObject1 = ((ReactViewBackgroundDrawable)localObject1).getDirectionAwareBorderInsets();
          if ((top <= 0.0F) && (left <= 0.0F) && (bottom <= 0.0F) && (right <= 0.0F))
          {
            f6 = 0.0F;
            f5 = 0.0F;
          }
          else
          {
            f6 = left + 0.0F;
            f5 = top + 0.0F;
            f8 -= right;
            f7 -= bottom;
          }
          float f4 = mReactBackgroundDrawable.getFullBorderRadius();
          float f3 = mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(f4, ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_LEFT);
          float f10 = f3;
          float f14 = mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(f4, ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_RIGHT);
          float f2 = f14;
          float f12 = mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(f4, ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_LEFT);
          float f1 = f12;
          float f13 = mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(f4, ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_RIGHT);
          f4 = f1;
          float f9 = f13;
          float f11 = f2;
          Object localObject2;
          if (Build.VERSION.SDK_INT >= 17)
          {
            if (mLayoutDirection == 1) {
              i = 1;
            } else {
              i = 0;
            }
            f11 = mReactBackgroundDrawable.getBorderRadius(ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_START);
            float f17 = mReactBackgroundDrawable.getBorderRadius(ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_END);
            f10 = f17;
            f4 = mReactBackgroundDrawable.getBorderRadius(ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_START);
            float f16 = f4;
            f9 = mReactBackgroundDrawable.getBorderRadius(ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_END);
            float f15 = f9;
            localObject2 = I18nUtil.getInstance();
            float f18 = f3;
            if (((I18nUtil)localObject2).doLeftAndRightSwapInRTL(getContext()))
            {
              if (YogaConstants.isUndefined(f11)) {
                f2 = f18;
              } else {
                f2 = f11;
              }
              f3 = f10;
              if (YogaConstants.isUndefined(f17)) {
                f3 = f14;
              }
              f1 = f16;
              if (YogaConstants.isUndefined(f4)) {
                f1 = f12;
              }
              if (YogaConstants.isUndefined(f9)) {
                f4 = f13;
              } else {
                f4 = f9;
              }
              if (i != 0) {
                f10 = f3;
              } else {
                f10 = f2;
              }
              if (i != 0) {
                f11 = f2;
              } else {
                f11 = f3;
              }
              if (i != 0) {
                f2 = f4;
              } else {
                f2 = f1;
              }
              f9 = f4;
              if (i != 0) {
                f9 = f1;
              }
              f4 = f2;
            }
            else
            {
              if (i != 0) {
                f12 = f17;
              } else {
                f12 = f11;
              }
              if (i != 0) {
                f10 = f11;
              }
              if (i == 0) {
                f9 = f4;
              }
              f11 = f15;
              if (i != 0) {
                f11 = f4;
              }
              if (YogaConstants.isUndefined(f12)) {
                f12 = f3;
              }
              if (!YogaConstants.isUndefined(f10)) {
                f2 = f10;
              }
              if (!YogaConstants.isUndefined(f9)) {
                f1 = f9;
              }
              if (!YogaConstants.isUndefined(f11))
              {
                f9 = f11;
                f4 = f1;
                f10 = f12;
                f11 = f2;
              }
              else
              {
                f4 = f1;
                f9 = f13;
                f10 = f12;
                f11 = f2;
              }
            }
          }
          if ((f10 <= 0.0F) && (f11 <= 0.0F) && (f9 <= 0.0F) && (f4 <= 0.0F))
          {
            i = 0;
          }
          else
          {
            if (mPath == null) {
              mPath = new Path();
            }
            mPath.rewind();
            localObject2 = mPath;
            RectF localRectF = new RectF(f6, f5, f8, f7);
            f1 = Math.max(f10 - left, 0.0F);
            f2 = Math.max(f10 - top, 0.0F);
            i = 1;
            f3 = Math.max(f11 - right, 0.0F);
            f10 = Math.max(f11 - top, 0.0F);
            f11 = Math.max(f9 - right, 0.0F);
            f9 = Math.max(f9 - bottom, 0.0F);
            f12 = Math.max(f4 - left, 0.0F);
            f4 = Math.max(f4 - bottom, 0.0F);
            localObject1 = Path.Direction.CW;
            ((Path)localObject2).addRoundRect(localRectF, new float[] { f1, f2, f3, f10, f11, f9, f12, f4 }, (Path.Direction)localObject1);
            paramCanvas.clipPath(mPath);
          }
        }
        else
        {
          f6 = 0.0F;
          f5 = 0.0F;
          i = 0;
        }
        if (i == 0)
        {
          paramCanvas.clipRect(new RectF(f6, f5, f8, f7));
          return;
        }
        break;
      case 0: 
        paramCanvas = mPath;
        if (paramCanvas != null) {
          paramCanvas.rewind();
        }
        break;
      }
    }
  }
  
  private ReactViewBackgroundDrawable getOrCreateReactViewBackground()
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
  }
  
  private ViewGroup getScrollView()
  {
    int i = mOnInterceptTouchEvent;
    if ((i != 1) && (i != 3))
    {
      if ((i != 2) && (i != 5)) {
        return null;
      }
      return getScrollViewH();
    }
    return getScrollViewV();
  }
  
  private ViewGroup getScrollViewH()
  {
    for (Object localObject = this; (localObject != null) && (((View)localObject).getParent() != null) && (!(((View)localObject).getParent() instanceof ReactHorizontalScrollView)) && (!(((View)localObject).getParent() instanceof ViewPager)); localObject = (View)((View)localObject).getParent()) {
      if (!(((View)localObject).getParent() instanceof View)) {
        return null;
      }
    }
    if ((localObject != null) && (((((View)localObject).getParent() instanceof ReactHorizontalScrollView)) || ((((View)localObject).getParent() instanceof ViewPager)))) {
      return (ViewGroup)((View)localObject).getParent();
    }
    return null;
  }
  
  private ViewGroup getScrollViewV()
  {
    for (Object localObject = this; (localObject != null) && (((View)localObject).getParent() != null) && (!(((View)localObject).getParent() instanceof ReactScrollView)); localObject = (View)((View)localObject).getParent()) {
      if (!(((View)localObject).getParent() instanceof View)) {
        return null;
      }
    }
    if ((localObject != null) && ((((View)localObject).getParent() instanceof ReactScrollView))) {
      return (ViewGroup)((View)localObject).getParent();
    }
    return null;
  }
  
  private int indexOfChildInAllChildren(View paramView)
  {
    int j = mAllChildrenCount;
    View[] arrayOfView = (View[])Assertions.assertNotNull(mAllChildren);
    int i = 0;
    while (i < j)
    {
      if (arrayOfView[i] == paramView) {
        return i;
      }
      i += 1;
    }
    return -1;
  }
  
  private void removeFromArray(int paramInt)
  {
    View[] arrayOfView = (View[])Assertions.assertNotNull(mAllChildren);
    int i = mAllChildrenCount;
    if (paramInt == i - 1)
    {
      paramInt = i - 1;
      mAllChildrenCount = paramInt;
      arrayOfView[paramInt] = null;
      return;
    }
    if ((paramInt >= 0) && (paramInt < i))
    {
      System.arraycopy(arrayOfView, paramInt + 1, arrayOfView, paramInt, i - paramInt - 1);
      paramInt = mAllChildrenCount - 1;
      mAllChildrenCount = paramInt;
      arrayOfView[paramInt] = null;
      return;
    }
    throw new IndexOutOfBoundsException();
  }
  
  private void updateBackgroundDrawable(Drawable paramDrawable)
  {
    super.setBackground(paramDrawable);
  }
  
  private void updateClippingToRect(Rect paramRect)
  {
    Assertions.assertNotNull(mAllChildren);
    int i = 0;
    int k;
    for (int j = 0; i < mAllChildrenCount; j = k)
    {
      updateSubviewClipStatus(paramRect, i, j);
      k = j;
      if (mAllChildren[i].getParent() == null) {
        k = j + 1;
      }
      i += 1;
    }
  }
  
  private void updateSubviewClipStatus(Rect paramRect, int paramInt1, int paramInt2)
  {
    View localView = ((View[])Assertions.assertNotNull(mAllChildren))[paramInt1];
    sHelperRect.set(localView.getLeft(), localView.getTop(), localView.getRight(), localView.getBottom());
    boolean bool = paramRect.intersects(sHelperRectleft, sHelperRecttop, sHelperRectright, sHelperRectbottom);
    paramRect = localView.getAnimation();
    int j = 1;
    int i;
    if ((paramRect != null) && (!paramRect.hasEnded())) {
      i = 1;
    } else {
      i = 0;
    }
    if ((!bool) && (localView.getParent() != null) && (i == 0))
    {
      super.removeViewsInLayout(paramInt1 - paramInt2, 1);
      paramInt1 = j;
    }
    else if ((bool) && (localView.getParent() == null))
    {
      super.addViewInLayout(localView, paramInt1 - paramInt2, sDefaultLayoutParam, true);
      invalidate();
      paramInt1 = j;
    }
    else if (bool)
    {
      paramInt1 = j;
    }
    else
    {
      paramInt1 = 0;
    }
    if ((paramInt1 != 0) && ((localView instanceof ReactClippingViewGroup)))
    {
      paramRect = (ReactClippingViewGroup)localView;
      if (paramRect.getRemoveClippedSubviews()) {
        paramRect.updateClippingRect();
      }
    }
  }
  
  private void updateSubviewClipStatus(View paramView)
  {
    if (mRemoveClippedSubviews)
    {
      if (getParent() == null) {
        return;
      }
      Assertions.assertNotNull(mClippingRect);
      Assertions.assertNotNull(mAllChildren);
      sHelperRect.set(paramView.getLeft(), paramView.getTop(), paramView.getRight(), paramView.getBottom());
      boolean bool2 = mClippingRect.intersects(sHelperRectleft, sHelperRecttop, sHelperRectright, sHelperRectbottom);
      Object localObject = paramView.getParent();
      int i = 0;
      boolean bool1;
      if (localObject != null) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      if (bool2 != bool1)
      {
        int k;
        for (int j = 0; i < mAllChildrenCount; j = k)
        {
          localObject = mAllChildren;
          if (localObject[i] == paramView)
          {
            updateSubviewClipStatus(mClippingRect, i, j);
            return;
          }
          k = j;
          if (localObject[i].getParent() == null) {
            k = j + 1;
          }
          i += 1;
        }
      }
    }
  }
  
  public void addView(View paramView, int paramInt, ViewGroup.LayoutParams paramLayoutParams)
  {
    mDrawingOrderHelper.handleAddView(paramView);
    setChildrenDrawingOrderEnabled(mDrawingOrderHelper.shouldEnableCustomDrawingOrder());
    try
    {
      super.addView(paramView, paramInt, paramLayoutParams);
      return;
    }
    catch (Exception paramView)
    {
      paramLayoutParams = new StringBuilder();
      paramLayoutParams.append("addView Exception:");
      paramLayoutParams.append(paramView);
      FLog.e("ReactViewGroup", paramLayoutParams.toString());
    }
  }
  
  void addViewWithSubviewClippingEnabled(View paramView, int paramInt)
  {
    addViewWithSubviewClippingEnabled(paramView, paramInt, sDefaultLayoutParam);
  }
  
  void addViewWithSubviewClippingEnabled(View paramView, int paramInt, ViewGroup.LayoutParams paramLayoutParams)
  {
    Assertions.assertCondition(mRemoveClippedSubviews);
    Assertions.assertNotNull(mClippingRect);
    Assertions.assertNotNull(mAllChildren);
    addInArray(paramView, paramInt);
    int i = 0;
    int k;
    for (int j = 0; i < paramInt; j = k)
    {
      k = j;
      if (mAllChildren[i].getParent() == null) {
        k = j + 1;
      }
      i += 1;
    }
    updateSubviewClipStatus(mClippingRect, paramInt, j);
    paramView.addOnLayoutChangeListener(mChildrenLayoutChangeListener);
  }
  
  protected void dispatchDraw(Canvas paramCanvas)
  {
    try
    {
      dispatchOverflowDraw(paramCanvas);
      super.dispatchDraw(paramCanvas);
      return;
    }
    catch (StackOverflowError paramCanvas)
    {
      RootView localRootView = RootViewUtil.getRootView(this);
      if (localRootView != null)
      {
        localRootView.handleException(paramCanvas);
        return;
      }
      if ((getContext() instanceof ReactContext))
      {
        ((ReactContext)getContext()).handleException(new IllegalViewOperationException("StackOverflowException", this, paramCanvas));
        return;
      }
      throw paramCanvas;
    }
    catch (NullPointerException paramCanvas)
    {
      FLog.e("ReactNative", "NullPointerException when executing ViewGroup.dispatchDraw method", paramCanvas);
    }
  }
  
  public void dispatchProvideStructure(ViewStructure paramViewStructure)
  {
    try
    {
      super.dispatchProvideStructure(paramViewStructure);
      return;
    }
    catch (NullPointerException paramViewStructure)
    {
      FLog.e("ReactNative", "NullPointerException when executing dispatchProvideStructure", paramViewStructure);
    }
  }
  
  protected void dispatchSetPressed(boolean paramBoolean) {}
  
  public void enableInterceptTouchEvent(boolean paramBoolean)
  {
    ViewGroup localViewGroup = getScrollView();
    if (localViewGroup != null) {
      localViewGroup.requestDisallowInterceptTouchEvent(paramBoolean);
    }
  }
  
  public void enableZindex(boolean paramBoolean)
  {
    mEnableZindex = paramBoolean;
  }
  
  int getAllChildrenCount()
  {
    return mAllChildrenCount;
  }
  
  public int getBackgroundColor()
  {
    if (getBackground() != null) {
      return ((ReactViewBackgroundDrawable)getBackground()).getColor();
    }
    return 0;
  }
  
  View getChildAtWithSubviewClippingEnabled(int paramInt)
  {
    return ((View[])Assertions.assertNotNull(mAllChildren))[paramInt];
  }
  
  protected int getChildDrawingOrder(int paramInt1, int paramInt2)
  {
    return mDrawingOrderHelper.getChildDrawingOrder(paramInt1, paramInt2);
  }
  
  public void getClippingRect(Rect paramRect)
  {
    paramRect.set(mClippingRect);
  }
  
  public Rect getHitSlopRect()
  {
    return mHitSlopRect;
  }
  
  public String getOverflow()
  {
    return mOverflow;
  }
  
  public PointerEvents getPointerEvents()
  {
    return mPointerEvents;
  }
  
  public boolean getRemoveClippedSubviews()
  {
    return mRemoveClippedSubviews;
  }
  
  public int getZIndexMappedChildIndex(int paramInt)
  {
    int i = paramInt;
    if (mDrawingOrderHelper.shouldEnableCustomDrawingOrder()) {
      i = mDrawingOrderHelper.getChildDrawingOrder(getChildCount(), paramInt);
    }
    return i;
  }
  
  public boolean getZindexflag()
  {
    return mEnableZindex;
  }
  
  public boolean hasOverlappingRendering()
  {
    return mNeedsOffscreenAlphaCompositing;
  }
  
  protected void onAttachedToWindow()
  {
    super.onAttachedToWindow();
    if (mRemoveClippedSubviews) {
      updateClippingRect();
    }
  }
  
  public boolean onInterceptTouchEvent(MotionEvent paramMotionEvent)
  {
    int i;
    if (paramMotionEvent.getAction() == 0)
    {
      point_x = ((int)paramMotionEvent.getX());
      point_y = ((int)paramMotionEvent.getY());
      localObject = getScrollView();
      if (localObject != null)
      {
        i = mOnInterceptTouchEvent;
        if (i == 3) {
          ((ReactScrollView)localObject).setInterceptScrollEnabled(true);
        } else if (i == 5) {
          ((ReactHorizontalScrollView)localObject).setInterceptScrollEnabled(true);
        } else {
          requestDisallowInterceptTouchEvent(true);
        }
        return super.onInterceptTouchEvent(paramMotionEvent);
      }
    }
    else if (paramMotionEvent.getAction() == 2)
    {
      if (getScrollView() != null)
      {
        int j = (int)paramMotionEvent.getX();
        i = (int)paramMotionEvent.getY();
        j = Math.abs(j - point_x);
        if (Math.abs(i - point_y) > j)
        {
          requestDisallowInterceptTouchEvent(false);
          return super.onInterceptTouchEvent(paramMotionEvent);
        }
        return super.onInterceptTouchEvent(paramMotionEvent);
      }
    }
    else if (paramMotionEvent.getAction() == 1)
    {
      point_x = 0;
      point_y = 0;
      localObject = getScrollView();
      if (localObject != null)
      {
        i = mOnInterceptTouchEvent;
        if (i == 3) {
          ((ReactScrollView)localObject).setInterceptScrollEnabled(false);
        } else if (i == 5) {
          ((ReactHorizontalScrollView)localObject).setInterceptScrollEnabled(false);
        } else {
          requestDisallowInterceptTouchEvent(false);
        }
        return super.onInterceptTouchEvent(paramMotionEvent);
      }
    }
    else
    {
      localObject = getScrollView();
      if (localObject != null)
      {
        i = mOnInterceptTouchEvent;
        if (i == 3) {
          ((ReactScrollView)localObject).setInterceptScrollEnabled(false);
        } else if (i == 5) {
          ((ReactHorizontalScrollView)localObject).setInterceptScrollEnabled(false);
        } else {
          requestDisallowInterceptTouchEvent(false);
        }
        return super.onInterceptTouchEvent(paramMotionEvent);
      }
    }
    Object localObject = mOnInterceptTouchEventListener;
    if ((localObject != null) && (((OnInterceptTouchEventListener)localObject).onInterceptTouchEvent(this, paramMotionEvent))) {
      return true;
    }
    if (mPointerEvents != PointerEvents.NONE)
    {
      if (mPointerEvents == PointerEvents.BOX_ONLY) {
        return true;
      }
      return super.onInterceptTouchEvent(paramMotionEvent);
    }
    return true;
  }
  
  protected void onLayout(boolean paramBoolean, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {}
  
  protected void onMeasure(int paramInt1, int paramInt2)
  {
    MeasureSpecAssertions.assertExplicitMeasureSpec(paramInt1, paramInt2);
    setMeasuredDimension(View.MeasureSpec.getSize(paramInt1), View.MeasureSpec.getSize(paramInt2));
  }
  
  public void onRtlPropertiesChanged(int paramInt)
  {
    if (Build.VERSION.SDK_INT >= 17)
    {
      ReactViewBackgroundDrawable localReactViewBackgroundDrawable = mReactBackgroundDrawable;
      if (localReactViewBackgroundDrawable != null) {
        localReactViewBackgroundDrawable.setResolvedLayoutDirection(mLayoutDirection);
      }
    }
  }
  
  protected void onSizeChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    super.onSizeChanged(paramInt1, paramInt2, paramInt3, paramInt4);
    if (mRemoveClippedSubviews) {
      updateClippingRect();
    }
  }
  
  public boolean onTouchEvent(MotionEvent paramMotionEvent)
  {
    return (mPointerEvents != PointerEvents.NONE) && (mPointerEvents != PointerEvents.BOX_NONE);
  }
  
  void removeAllViewsWithSubviewClippingEnabled()
  {
    Assertions.assertCondition(mRemoveClippedSubviews);
    Assertions.assertNotNull(mAllChildren);
    int i = 0;
    while (i < mAllChildrenCount)
    {
      mAllChildren[i].removeOnLayoutChangeListener(mChildrenLayoutChangeListener);
      i += 1;
    }
    removeAllViewsInLayout();
    mAllChildrenCount = 0;
  }
  
  public void removeView(View paramView)
  {
    mDrawingOrderHelper.handleRemoveView(paramView);
    setChildrenDrawingOrderEnabled(mDrawingOrderHelper.shouldEnableCustomDrawingOrder());
    super.removeView(paramView);
  }
  
  public void removeViewAt(int paramInt)
  {
    mDrawingOrderHelper.handleRemoveView(getChildAt(paramInt));
    setChildrenDrawingOrderEnabled(mDrawingOrderHelper.shouldEnableCustomDrawingOrder());
    super.removeViewAt(paramInt);
  }
  
  void removeViewWithSubviewClippingEnabled(View paramView)
  {
    Assertions.assertCondition(mRemoveClippedSubviews);
    Assertions.assertNotNull(mClippingRect);
    Assertions.assertNotNull(mAllChildren);
    paramView.removeOnLayoutChangeListener(mChildrenLayoutChangeListener);
    int m = indexOfChildInAllChildren(paramView);
    if (mAllChildren[m].getParent() != null)
    {
      int i = 0;
      int k;
      for (int j = 0; i < m; j = k)
      {
        k = j;
        if (mAllChildren[i].getParent() == null) {
          k = j + 1;
        }
        i += 1;
      }
      super.removeViewsInLayout(m - j, 1);
    }
    removeFromArray(m);
  }
  
  public void requestLayout() {}
  
  public void setBackfaceVisibility(String paramString)
  {
    mBackfaceVisibility = paramString;
    setBackfaceVisibilityDependantOpacity();
  }
  
  public void setBackfaceVisibilityDependantOpacity()
  {
    if (mBackfaceVisibility.equals("visible"))
    {
      setAlpha(mBackfaceOpacity);
      return;
    }
    float f1 = getRotationX();
    float f2 = getRotationY();
    int i;
    if ((f1 >= -90.0F) && (f1 < 90.0F) && (f2 >= -90.0F) && (f2 < 90.0F)) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0)
    {
      setAlpha(mBackfaceOpacity);
      return;
    }
    setAlpha(0.0F);
  }
  
  public void setBackground(Drawable paramDrawable)
  {
    throw new UnsupportedOperationException("This method is not supported for ReactViewGroup instances");
  }
  
  public void setBackgroundColor(int paramInt)
  {
    if ((paramInt == 0) && (mReactBackgroundDrawable == null)) {
      return;
    }
    getOrCreateReactViewBackground().setColor(paramInt);
  }
  
  public void setBorderColor(int paramInt, float paramFloat1, float paramFloat2)
  {
    getOrCreateReactViewBackground().setBorderColor(paramInt, paramFloat1, paramFloat2);
  }
  
  public void setBorderRadius(float paramFloat)
  {
    ReactViewBackgroundDrawable localReactViewBackgroundDrawable = getOrCreateReactViewBackground();
    localReactViewBackgroundDrawable.setRadius(paramFloat);
    if (Build.VERSION.SDK_INT < 18)
    {
      int i;
      if (localReactViewBackgroundDrawable.hasRoundedBorders()) {
        i = 1;
      } else {
        i = 2;
      }
      if (i != getLayerType()) {
        setLayerType(i, null);
      }
    }
  }
  
  public void setBorderRadius(float paramFloat, int paramInt)
  {
    ReactViewBackgroundDrawable localReactViewBackgroundDrawable = getOrCreateReactViewBackground();
    localReactViewBackgroundDrawable.setRadius(paramFloat, paramInt);
    if (Build.VERSION.SDK_INT < 18)
    {
      if (localReactViewBackgroundDrawable.hasRoundedBorders()) {
        paramInt = 1;
      } else {
        paramInt = 2;
      }
      if (paramInt != getLayerType()) {
        setLayerType(paramInt, null);
      }
    }
  }
  
  public void setBorderStyle(String paramString)
  {
    getOrCreateReactViewBackground().setBorderStyle(paramString);
  }
  
  public void setBorderWidth(int paramInt, float paramFloat)
  {
    getOrCreateReactViewBackground().setBorderWidth(paramInt, paramFloat);
  }
  
  public void setHitSlopRect(Rect paramRect)
  {
    mHitSlopRect = paramRect;
  }
  
  public void setNeedsOffscreenAlphaCompositing(boolean paramBoolean)
  {
    mNeedsOffscreenAlphaCompositing = paramBoolean;
  }
  
  public void setOnInterceptTouchEvent(int paramInt)
  {
    mOnInterceptTouchEvent = paramInt;
  }
  
  public void setOnInterceptTouchEventListener(OnInterceptTouchEventListener paramOnInterceptTouchEventListener)
  {
    mOnInterceptTouchEventListener = paramOnInterceptTouchEventListener;
  }
  
  public void setOpacityIfPossible(float paramFloat)
  {
    mBackfaceOpacity = paramFloat;
    setBackfaceVisibilityDependantOpacity();
  }
  
  public void setOverflow(String paramString)
  {
    mOverflow = paramString;
    invalidate();
  }
  
  void setPointerEvents(PointerEvents paramPointerEvents)
  {
    mPointerEvents = paramPointerEvents;
  }
  
  public void setRemoveClippedSubviews(boolean paramBoolean)
  {
    if (paramBoolean == mRemoveClippedSubviews) {
      return;
    }
    mRemoveClippedSubviews = paramBoolean;
    int i = 0;
    if (paramBoolean)
    {
      mClippingRect = new Rect();
      ReactClippingViewGroupHelper.calculateClippingRect(this, mClippingRect);
      mAllChildrenCount = getChildCount();
      mAllChildren = new View[Math.max(12, mAllChildrenCount)];
      mChildrenLayoutChangeListener = new ChildrenLayoutChangeListener(this, null);
      while (i < mAllChildrenCount)
      {
        View localView = getChildAt(i);
        mAllChildren[i] = localView;
        localView.addOnLayoutChangeListener(mChildrenLayoutChangeListener);
        i += 1;
      }
      updateClippingRect();
      return;
    }
    Assertions.assertNotNull(mClippingRect);
    Assertions.assertNotNull(mAllChildren);
    Assertions.assertNotNull(mChildrenLayoutChangeListener);
    i = 0;
    while (i < mAllChildrenCount)
    {
      mAllChildren[i].removeOnLayoutChangeListener(mChildrenLayoutChangeListener);
      i += 1;
    }
    getDrawingRect(mClippingRect);
    updateClippingToRect(mClippingRect);
    mAllChildren = null;
    mClippingRect = null;
    mAllChildrenCount = 0;
    mChildrenLayoutChangeListener = null;
  }
  
  public void setTranslucentBackgroundDrawable(Drawable paramDrawable)
  {
    updateBackgroundDrawable(null);
    ReactViewBackgroundDrawable localReactViewBackgroundDrawable = mReactBackgroundDrawable;
    if ((localReactViewBackgroundDrawable != null) && (paramDrawable != null))
    {
      updateBackgroundDrawable(new LayerDrawable(new Drawable[] { localReactViewBackgroundDrawable, paramDrawable }));
      return;
    }
    if (paramDrawable != null) {
      updateBackgroundDrawable(paramDrawable);
    }
  }
  
  public void updateClippingRect()
  {
    if (!mRemoveClippedSubviews) {
      return;
    }
    Assertions.assertNotNull(mClippingRect);
    Assertions.assertNotNull(mAllChildren);
    ReactClippingViewGroupHelper.calculateClippingRect(this, mClippingRect);
    updateClippingToRect(mClippingRect);
  }
  
  public void updateDrawingOrder()
  {
    mDrawingOrderHelper.update();
    setChildrenDrawingOrderEnabled(mDrawingOrderHelper.shouldEnableCustomDrawingOrder());
    invalidate();
  }
  
  private static final class ChildrenLayoutChangeListener
    implements View.OnLayoutChangeListener
  {
    private final ReactViewGroup mParent;
    
    private ChildrenLayoutChangeListener(ReactViewGroup paramReactViewGroup)
    {
      mParent = paramReactViewGroup;
    }
    
    public void onLayoutChange(View paramView, int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7, int paramInt8)
    {
      if (mParent.getRemoveClippedSubviews()) {
        mParent.updateSubviewClipStatus(paramView);
      }
    }
  }
}
