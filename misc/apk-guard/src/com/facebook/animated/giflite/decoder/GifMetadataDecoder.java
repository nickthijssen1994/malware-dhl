package com.facebook.animated.giflite.decoder;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;

public class GifMetadataDecoder
{
  private static final int CONTROL_INDEX_DELAY = 1;
  private static final int CONTROL_INDEX_DISPOSE = 0;
  private static final int DEFAULT_FRAME_DURATION_MS = 100;
  private static final int MAX_BLOCK_SIZE = 256;
  private static final char[] NETSCAPE = { 78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48 };
  private final byte[] block = new byte['?'];
  private int mCurrentOffset = 0;
  private boolean mDecoded = false;
  private final List<int[]> mFrameControls = new ArrayList();
  private final InputStream mInputStream;
  private int mLoopCount = 1;
  @Nullable
  private final OutputStream mOutputStream;
  private boolean shouldFixStream;
  
  private GifMetadataDecoder(InputStream paramInputStream, OutputStream paramOutputStream)
  {
    mInputStream = paramInputStream;
    mOutputStream = paramOutputStream;
  }
  
  private void addFrame(int[] paramArrayOfInt)
  {
    mFrameControls.add(Arrays.copyOf(paramArrayOfInt, paramArrayOfInt.length));
  }
  
  private void copyFromIsToOs(InputStream paramInputStream, OutputStream paramOutputStream, int paramInt)
  {
    while (paramInt > 0)
    {
      int i = paramInputStream.read(block, 0, Math.min(256, paramInt));
      paramInt -= 256;
      paramOutputStream.write(block, 0, i);
    }
  }
  
  public static GifMetadataDecoder create(InputStream paramInputStream, OutputStream paramOutputStream)
  {
    paramInputStream = new GifMetadataDecoder(paramInputStream, paramOutputStream);
    paramInputStream.decode();
    return paramInputStream;
  }
  
  private void ignoreColorTable(int paramInt)
  {
    skipAndWriteBytes(paramInt * 3);
  }
  
  private void initFixedOutputStream()
  {
    if (!shouldFixStream)
    {
      if (mOutputStream == null) {
        return;
      }
      shouldFixStream = true;
      mInputStream.reset();
      copyFromIsToOs(mInputStream, mOutputStream, mCurrentOffset - 2);
      mInputStream.skip(2L);
    }
  }
  
  private boolean isNetscape()
  {
    int i = block.length;
    char[] arrayOfChar = NETSCAPE;
    if (i < arrayOfChar.length) {
      return false;
    }
    int j = arrayOfChar.length;
    i = 0;
    while (i < j)
    {
      if (NETSCAPE[i] != (char)block[i]) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  
  private int readAndWriteNextByte()
  {
    int i = readNextByte();
    writeNextByte(i);
    return i;
  }
  
  private int readBlock()
  {
    int j = readAndWriteNextByte();
    int i = 0;
    if (j > 0) {
      while (i < j) {
        i += readIntoBlock(i, j - i);
      }
    }
    return 0;
    return i;
  }
  
  private void readGifInfo()
  {
    validateAndIgnoreHeader();
    Object localObject = new int[2];
    Object tmp9_8 = localObject;
    tmp9_8[0] = 0;
    Object tmp13_9 = tmp9_8;
    tmp13_9[1] = 0;
    tmp13_9;
    int i = 0;
    while (i == 0)
    {
      int j = readAndWriteNextByte();
      if (j != 33)
      {
        if (j != 44)
        {
          if (j == 59)
          {
            i = 1;
          }
          else
          {
            localObject = new StringBuilder();
            ((StringBuilder)localObject).append("Unknown block header [");
            ((StringBuilder)localObject).append(Integer.toHexString(j));
            ((StringBuilder)localObject).append("]");
            throw new IOException(((StringBuilder)localObject).toString());
          }
        }
        else
        {
          addFrame((int[])localObject);
          skipImage();
        }
      }
      else
      {
        j = readAndWriteNextByte();
        if (j != 1) {
          if (j != 249) {
            if (j == 255) {}
          }
        }
        for (;;)
        {
          skipExtension();
          break;
          readBlock();
          if (isNetscape())
          {
            readNetscapeExtension();
            break;
            readGraphicsControlExtension((int[])localObject);
            break;
            addFrame((int[])localObject);
          }
        }
      }
    }
  }
  
  private void readGraphicsControlExtension(int[] paramArrayOfInt)
  {
    skipAndWriteBytes(1);
    paramArrayOfInt[0] = ((readAndWriteNextByte() & 0x1C) >> 2);
    paramArrayOfInt[1] = (readTwoByteInt() * 10);
    if (paramArrayOfInt[1] == 0)
    {
      paramArrayOfInt[1] = 100;
      initFixedOutputStream();
    }
    writeTwoByteInt(paramArrayOfInt[1] / 10);
    skipAndWriteBytes(2);
  }
  
  private int readIntoBlock(int paramInt1, int paramInt2)
  {
    int i = mInputStream.read(block, paramInt1, paramInt2);
    mCurrentOffset += paramInt2;
    if (shouldFixStream) {
      mOutputStream.write(block, paramInt1, paramInt2);
    }
    if (i != -1) {
      return i;
    }
    throw new EOFException("Unexpected end of gif file");
  }
  
  private void readNetscapeExtension()
  {
    int i;
    do
    {
      i = readBlock();
      byte[] arrayOfByte = block;
      if (arrayOfByte[0] == 1)
      {
        int j = arrayOfByte[2];
        mLoopCount = (arrayOfByte[1] & 0xFF | (j & 0xFF) << 8);
      }
    } while (i > 0);
  }
  
  private int readNextByte()
  {
    int i = mInputStream.read();
    mCurrentOffset += 1;
    if (i != -1) {
      return i;
    }
    throw new EOFException("Unexpected end of gif file");
  }
  
  private int readTwoByteInt()
  {
    return readNextByte() | readNextByte() << 8;
  }
  
  private void skipAndWriteBytes(int paramInt)
  {
    if (shouldFixStream) {
      copyFromIsToOs(mInputStream, mOutputStream, paramInt);
    } else {
      mInputStream.skip(paramInt);
    }
    mCurrentOffset += paramInt;
  }
  
  private void skipExtension()
  {
    while (readBlock() > 0) {}
  }
  
  private void skipImage()
  {
    skipAndWriteBytes(8);
    int j = readAndWriteNextByte();
    int i;
    if ((j & 0x80) != 0) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0) {
      ignoreColorTable(2 << (j & 0x7));
    }
    skipAndWriteBytes(1);
    skipExtension();
  }
  
  private void validateAndIgnoreHeader()
  {
    int j = 0;
    readIntoBlock(0, 6);
    byte[] arrayOfByte = block;
    int i;
    if (('G' == (char)arrayOfByte[0]) && ('I' == (char)arrayOfByte[1]) && ('F' == (char)arrayOfByte[2]) && ('8' == (char)arrayOfByte[3]) && (('7' == (char)arrayOfByte[4]) || ('9' == (char)arrayOfByte[4])) && ('a' == (char)block[5])) {
      i = 1;
    } else {
      i = 0;
    }
    if (i != 0)
    {
      skipAndWriteBytes(4);
      int k = readAndWriteNextByte();
      i = j;
      if ((k & 0x80) != 0) {
        i = 1;
      }
      skipAndWriteBytes(2);
      if (i != 0) {
        ignoreColorTable(2 << (k & 0x7));
      }
    }
    else
    {
      throw new IOException("Illegal header for gif");
    }
  }
  
  private void writeNextByte(int paramInt)
  {
    if (shouldFixStream) {
      mOutputStream.write(paramInt);
    }
  }
  
  private void writeTwoByteInt(int paramInt)
  {
    writeNextByte(paramInt);
    writeNextByte(paramInt >> 8);
  }
  
  public void decode()
  {
    if (!mDecoded)
    {
      mDecoded = true;
      readGifInfo();
      return;
    }
    throw new IllegalStateException("decode called multiple times");
  }
  
  public int getFrameCount()
  {
    if (mDecoded) {
      return mFrameControls.size();
    }
    throw new IllegalStateException("getFrameCount called before decode");
  }
  
  public int getFrameDisposal(int paramInt)
  {
    if (mDecoded) {
      return ((int[])mFrameControls.get(paramInt))[0];
    }
    throw new IllegalStateException("getFrameDisposal called before decode");
  }
  
  public int getFrameDurationMs(int paramInt)
  {
    if (mDecoded)
    {
      if (paramInt >= getFrameCount()) {
        return 1;
      }
      return ((int[])mFrameControls.get(paramInt))[1];
    }
    throw new IllegalStateException("getFrameDurationMs called before decode");
  }
  
  public int getLoopCount()
  {
    if (mDecoded) {
      return mLoopCount;
    }
    throw new IllegalStateException("getLoopCount called before decode");
  }
}
