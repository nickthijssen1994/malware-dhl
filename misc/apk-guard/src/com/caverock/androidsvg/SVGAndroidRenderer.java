package com.caverock.androidsvg;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.DashPathEffect;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Paint.Cap;
import android.graphics.Paint.Join;
import android.graphics.Paint.Style;
import android.graphics.Path;
import android.graphics.Path.FillType;
import android.graphics.Path.Op;
import android.graphics.PathMeasure;
import android.graphics.PorterDuff.Mode;
import android.graphics.PorterDuffXfermode;
import android.graphics.RadialGradient;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.Shader.TileMode;
import android.graphics.Typeface;
import android.os.Build.VERSION;
import android.util.Base64;
import android.util.Log;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.Stack;

class SVGAndroidRenderer
{
  private static HashSet<String> supportedFeatures;
  private Canvas canvas;
  private SVG document;
  private float dpi;
  private Stack<Matrix> matrixStack;
  private Stack<SVG.ag> parentStack;
  private RendererState state;
  private Stack<e.g> stateStack;
  private CSSParser.l x = null;
  
  SVGAndroidRenderer(Canvas paramCanvas, float paramFloat)
  {
    canvas = paramCanvas;
    dpi = paramFloat;
  }
  
  private float a(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    return paramFloat1 * paramFloat3 + paramFloat2 * paramFloat4;
  }
  
  private h a(h paramH1, h paramH2, h paramH3)
  {
    float f2 = a(n, r, x - x, y - y);
    float f1 = f2;
    if (f2 == 0.0F) {
      f1 = a(n, r, x - x, y - y);
    }
    if (f1 > 0.0F) {
      return paramH2;
    }
    if (f1 == 0.0F)
    {
      if (n > 0.0F) {
        return paramH2;
      }
      if (r >= 0.0F) {
        return paramH2;
      }
    }
    n = (-n);
    r = (-r);
    return paramH2;
  }
  
  private static double acos(double paramDouble)
  {
    if (paramDouble < -1.0D) {
      return 3.141592653589793D;
    }
    if (paramDouble > 1.0D) {
      return 0.0D;
    }
    return Math.acos(paramDouble);
  }
  
  private Path addObjectToClip(SVG.at paramAt)
  {
    Object localObject = x;
    float f2 = 0.0F;
    float f1;
    if ((localObject != null) && (x.size() != 0)) {
      f1 = ((SVG.n)x.get(0)).floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    float f3;
    if ((y != null) && (y.size() != 0)) {
      f3 = ((SVG.n)y.get(0)).floatValueY(this);
    } else {
      f3 = 0.0F;
    }
    float f4;
    if ((dx != null) && (dx.size() != 0)) {
      f4 = ((SVG.n)dx.get(0)).floatValueX(this);
    } else {
      f4 = 0.0F;
    }
    float f5 = f2;
    if (dy != null) {
      if (dy.size() == 0) {
        f5 = f2;
      } else {
        f5 = ((SVG.n)dy.get(0)).floatValueY(this);
      }
    }
    f2 = f1;
    if (state.style.textAnchor != SVG.Style.TextAnchor.Start)
    {
      f2 = calculateTextWidth(paramAt);
      if (state.style.textAnchor == SVG.Style.TextAnchor.Middle) {
        f2 = f1 - f2 / 2.0F;
      } else {
        f2 = f1 - f2;
      }
    }
    if (boundingBox == null)
    {
      localObject = new TextBoundsCalculator(f2, f3);
      enumerateTextSpans(paramAt, (TextProcessor)localObject);
      boundingBox = new SVG.a(bbox.left, bbox.top, bbox.width(), bbox.height());
    }
    localObject = new Path();
    enumerateTextSpans(paramAt, new PlainTextToPath(f2 + f4, f3 + f5, (Path)localObject));
    return localObject;
  }
  
  private void addObjectToClip(SVG.ak paramAk, boolean paramBoolean, Path paramPath, Matrix paramMatrix)
  {
    if (!display()) {
      return;
    }
    clipStatePush();
    if ((paramAk instanceof SVG.ba))
    {
      if (paramBoolean) {
        addObjectToClip((SVG.ba)paramAk, paramPath, paramMatrix);
      } else {
        error("<use> elements inside a <clipPath> cannot reference another <use>", new Object[0]);
      }
    }
    else if ((paramAk instanceof SVG.t)) {
      addObjectToClip((SVG.t)paramAk, paramPath, paramMatrix);
    } else if ((paramAk instanceof SVG.at)) {
      addObjectToClip((SVG.at)paramAk, paramPath, paramMatrix);
    } else if ((paramAk instanceof SVG.j)) {
      addObjectToClip((SVG.j)paramAk, paramPath, paramMatrix);
    } else {
      error("Invalid %s element found in clipPath definition", new Object[] { paramAk.toString() });
    }
    clipStatePop();
  }
  
  private void addObjectToClip(SVG.at paramAt, Path paramPath, Matrix paramMatrix)
  {
    updateStyleForElement(state, paramAt);
    if (!display()) {
      return;
    }
    if (transform != null) {
      paramMatrix.preConcat(transform);
    }
    Object localObject = x;
    float f2 = 0.0F;
    float f1;
    if ((localObject != null) && (x.size() != 0)) {
      f1 = ((SVG.n)x.get(0)).floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    float f3;
    if ((y != null) && (y.size() != 0)) {
      f3 = ((SVG.n)y.get(0)).floatValueY(this);
    } else {
      f3 = 0.0F;
    }
    float f4;
    if ((dx != null) && (dx.size() != 0)) {
      f4 = ((SVG.n)dx.get(0)).floatValueX(this);
    } else {
      f4 = 0.0F;
    }
    float f5 = f2;
    if (dy != null) {
      if (dy.size() == 0) {
        f5 = f2;
      } else {
        f5 = ((SVG.n)dy.get(0)).floatValueY(this);
      }
    }
    f2 = f1;
    if (state.style.textAnchor != SVG.Style.TextAnchor.Start)
    {
      f2 = calculateTextWidth(paramAt);
      if (state.style.textAnchor == SVG.Style.TextAnchor.Middle) {
        f2 = f1 - f2 / 2.0F;
      } else {
        f2 = f1 - f2;
      }
    }
    if (boundingBox == null)
    {
      localObject = new TextBoundsCalculator(f2, f3);
      enumerateTextSpans(paramAt, (TextProcessor)localObject);
      boundingBox = new SVG.a(bbox.left, bbox.top, bbox.width(), bbox.height());
    }
    checkForClipPath(paramAt);
    localObject = new Path();
    enumerateTextSpans(paramAt, new PlainTextToPath(f2 + f4, f3 + f5, (Path)localObject));
    paramPath.setFillType(getClipRuleFromState());
    paramPath.addPath((Path)localObject, paramMatrix);
  }
  
  private void addObjectToClip(SVG.ba paramBa, Path paramPath, Matrix paramMatrix)
  {
    updateStyleForElement(state, paramBa);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if (transform != null) {
      paramMatrix.preConcat(transform);
    }
    SVG.ak localAk = document.resolveIRI(href);
    if (localAk == null)
    {
      error("Use reference '%s' not found", new Object[] { href });
      return;
    }
    checkForClipPath(paramBa);
    addObjectToClip(localAk, false, paramPath, paramMatrix);
  }
  
  private void addObjectToClip(SVG.j paramJ, Path paramPath, Matrix paramMatrix)
  {
    updateStyleForElement(state, paramJ);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if (transform != null) {
      paramMatrix.preConcat(transform);
    }
    Path localPath;
    if ((paramJ instanceof SVG.z))
    {
      localPath = makePathAndBoundingBox((SVG.z)paramJ);
    }
    else if ((paramJ instanceof SVG.c))
    {
      localPath = makePathAndBoundingBox((SVG.c)paramJ);
    }
    else if ((paramJ instanceof SVG.h))
    {
      localPath = makePathAndBoundingBox((SVG.h)paramJ);
    }
    else
    {
      if (!(paramJ instanceof SVG.x)) {
        return;
      }
      localPath = makePathAndBoundingBox((SVG.x)paramJ);
    }
    checkForClipPath(paramJ);
    paramPath.setFillType(getClipRuleFromState());
    paramPath.addPath(localPath, paramMatrix);
  }
  
  private void addObjectToClip(SVG.t paramT, Path paramPath, Matrix paramMatrix)
  {
    updateStyleForElement(state, paramT);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if (transform != null) {
      paramMatrix.preConcat(transform);
    }
    Path localPath = new Item(this, d).getPath();
    if (boundingBox == null) {
      boundingBox = calculatePathBounds(localPath);
    }
    checkForClipPath(paramT);
    paramPath.setFillType(getClipRuleFromState());
    paramPath.addPath(localPath, paramMatrix);
  }
  
  private static void arcTo(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4, float paramFloat5, boolean paramBoolean1, boolean paramBoolean2, float paramFloat6, float paramFloat7, SVG.v paramV)
  {
    if ((paramFloat1 == paramFloat6) && (paramFloat2 == paramFloat7)) {
      return;
    }
    if ((paramFloat3 != 0.0F) && (paramFloat4 != 0.0F))
    {
      float f1 = Math.abs(paramFloat3);
      paramFloat3 = f1;
      float f2 = Math.abs(paramFloat4);
      paramFloat4 = f2;
      double d1 = paramFloat5;
      Double.isNaN(d1);
      d1 = Math.toRadians(d1 % 360.0D);
      double d5 = Math.cos(d1);
      double d6 = Math.sin(d1);
      d1 = paramFloat1 - paramFloat6;
      Double.isNaN(d1);
      d1 /= 2.0D;
      double d2 = paramFloat2 - paramFloat7;
      Double.isNaN(d2);
      d2 /= 2.0D;
      double d7 = d5 * d1 + d6 * d2;
      double d8 = -d6 * d1 + d2 * d5;
      d1 = f1 * f1;
      d2 = f2 * f2;
      double d9 = d7 * d7;
      double d10 = d8 * d8;
      Double.isNaN(d1);
      double d3 = d9 / d1;
      Double.isNaN(d2);
      d3 += d10 / d2;
      if (d3 > 0.99999D)
      {
        d1 = Math.sqrt(d3) * 1.00001D;
        d2 = f1;
        Double.isNaN(d2);
        paramFloat3 = (float)(d2 * d1);
        d2 = f2;
        Double.isNaN(d2);
        paramFloat4 = (float)(d1 * d2);
        d1 = paramFloat3 * paramFloat3;
        d2 = paramFloat4 * paramFloat4;
      }
      double d4 = 1.0D;
      if (paramBoolean1 == paramBoolean2) {
        d3 = -1.0D;
      } else {
        d3 = 1.0D;
      }
      d10 = d1 * d10;
      d9 = d2 * d9;
      d2 = (d1 * d2 - d10 - d9) / (d10 + d9);
      d1 = d2;
      if (d2 < 0.0D) {
        d1 = 0.0D;
      }
      d3 *= Math.sqrt(d1);
      d2 = paramFloat3;
      Double.isNaN(d2);
      d1 = paramFloat4;
      Double.isNaN(d1);
      d9 = d2 * d8 / d1 * d3;
      Double.isNaN(d1);
      Double.isNaN(d2);
      d10 = d3 * -(d1 * d7 / d2);
      d3 = paramFloat1 + paramFloat6;
      Double.isNaN(d3);
      double d11 = d3 / 2.0D;
      d3 = paramFloat2 + paramFloat7;
      Double.isNaN(d3);
      double d12 = d3 / 2.0D;
      Double.isNaN(d2);
      d3 = (d7 - d9) / d2;
      Double.isNaN(d1);
      double d13 = (d8 - d10) / d1;
      d7 = -d7;
      Double.isNaN(d2);
      d7 = (d7 - d9) / d2;
      d2 = -d8;
      Double.isNaN(d1);
      double d14 = (d2 - d10) / d1;
      d1 = d3 * d3 + d13 * d13;
      d8 = Math.sqrt(d1);
      if (d13 < 0.0D) {
        d2 = -1.0D;
      } else {
        d2 = 1.0D;
      }
      d8 = Math.acos(d3 / d8);
      double d15 = Math.sqrt(d1 * (d7 * d7 + d14 * d14));
      d1 = d4;
      if (d3 * d14 - d13 * d7 < 0.0D) {
        d1 = -1.0D;
      }
      d3 = d1 * acos((d3 * d7 + d13 * d14) / d15);
      if ((!paramBoolean2) && (d3 > 0.0D))
      {
        d1 = d3 - 6.283185307179586D;
      }
      else
      {
        d1 = d3;
        if (paramBoolean2)
        {
          d1 = d3;
          if (d3 < 0.0D) {
            d1 = d3 + 6.283185307179586D;
          }
        }
      }
      float[] arrayOfFloat = arcToBeziers(d2 * d8 % 6.283185307179586D, d1 % 6.283185307179586D);
      Matrix localMatrix = new Matrix();
      localMatrix.postScale(paramFloat3, paramFloat4);
      localMatrix.postRotate(paramFloat5);
      localMatrix.postTranslate((float)(d11 + (d5 * d9 - d6 * d10)), (float)(d12 + (d6 * d9 + d5 * d10)));
      localMatrix.mapPoints(arrayOfFloat);
      arrayOfFloat[(arrayOfFloat.length - 2)] = paramFloat6;
      arrayOfFloat[(arrayOfFloat.length - 1)] = paramFloat7;
      int i = 0;
      while (i < arrayOfFloat.length)
      {
        paramV.a(arrayOfFloat[i], arrayOfFloat[(i + 1)], arrayOfFloat[(i + 2)], arrayOfFloat[(i + 3)], arrayOfFloat[(i + 4)], arrayOfFloat[(i + 5)]);
        i += 6;
      }
      return;
    }
    paramV.a(paramFloat6, paramFloat7);
  }
  
  private static float[] arcToBeziers(double paramDouble1, double paramDouble2)
  {
    int k = (int)Math.ceil(Math.abs(paramDouble2) * 2.0D / 3.141592653589793D);
    double d1 = k;
    Double.isNaN(d1);
    paramDouble2 /= d1;
    d1 = paramDouble2 / 2.0D;
    d1 = Math.sin(d1) * 1.3333333333333333D / (Math.cos(d1) + 1.0D);
    float[] arrayOfFloat = new float[k * 6];
    int i = 0;
    int j = 0;
    while (i < k)
    {
      double d2 = i;
      Double.isNaN(d2);
      d2 = paramDouble1 + d2 * paramDouble2;
      double d3 = Math.cos(d2);
      double d4 = Math.sin(d2);
      int m = j + 1;
      arrayOfFloat[j] = ((float)(d3 - d1 * d4));
      j = m + 1;
      arrayOfFloat[m] = ((float)(d4 + d3 * d1));
      d3 = d2 + paramDouble2;
      d2 = Math.cos(d3);
      d3 = Math.sin(d3);
      m = j + 1;
      arrayOfFloat[j] = ((float)(d1 * d3 + d2));
      j = m + 1;
      arrayOfFloat[m] = ((float)(d3 - d1 * d2));
      m = j + 1;
      arrayOfFloat[j] = ((float)d2);
      j = m + 1;
      arrayOfFloat[m] = ((float)d3);
      i += 1;
    }
    return arrayOfFloat;
  }
  
  private List calculateMarkerPositions(SVG.o paramO)
  {
    float f1;
    if (x != null) {
      f1 = x.floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    float f2;
    if (y != null) {
      f2 = y.floatValueY(this);
    } else {
      f2 = 0.0F;
    }
    float f3;
    if (width != null) {
      f3 = width.floatValueX(this);
    } else {
      f3 = 0.0F;
    }
    float f4;
    if (height != null) {
      f4 = height.floatValueY(this);
    } else {
      f4 = 0.0F;
    }
    paramO = new ArrayList(2);
    float f5 = f3 - f1;
    float f6 = f4 - f2;
    paramO.add(new h(this, f1, f2, f5, f6));
    paramO.add(new h(this, f3, f4, f5, f6));
    return paramO;
  }
  
  private List calculateMarkerPositions(SVG.x paramX)
  {
    int j = points.length;
    int i = 2;
    if (j < 2) {
      return null;
    }
    ArrayList localArrayList = new ArrayList();
    h localH = new h(this, points[0], points[1], 0.0F, 0.0F);
    float f2 = 0.0F;
    float f1 = 0.0F;
    while (i < j)
    {
      f2 = points[i];
      f1 = points[(i + 1)];
      localH.add(f2, f1);
      localArrayList.add(localH);
      localH = new h(this, f2, f1, f2 - x, f1 - y);
      i += 2;
    }
    if ((paramX instanceof SVG.y))
    {
      if ((f2 != points[0]) && (f1 != points[1]))
      {
        f1 = points[0];
        f2 = points[1];
        localH.add(f1, f2);
        localArrayList.add(localH);
        paramX = new h(this, f1, f2, f1 - x, f2 - y);
        paramX.a((h)localArrayList.get(0));
        localArrayList.add(paramX);
        localArrayList.set(0, paramX);
        return localArrayList;
      }
    }
    else {
      localArrayList.add(localH);
    }
    return localArrayList;
  }
  
  private SVG.a calculatePathBounds(Path paramPath)
  {
    RectF localRectF = new RectF();
    paramPath.computeBounds(localRectF, true);
    return new SVG.a(left, top, localRectF.width(), localRectF.height());
  }
  
  private float calculateTextWidth(SVG.av paramAv)
  {
    TextWidthCalculator localTextWidthCalculator = new TextWidthCalculator(null);
    enumerateTextSpans(paramAv, localTextWidthCalculator);
    return x;
  }
  
  private Matrix calculateViewBoxTransform(SVG.a paramA1, SVG.a paramA2, PreserveAspectRatio paramPreserveAspectRatio)
  {
    Matrix localMatrix = new Matrix();
    if (paramPreserveAspectRatio != null)
    {
      if (paramPreserveAspectRatio.getAlignment() == null) {
        return localMatrix;
      }
      float f3 = width / width;
      float f4 = height / height;
      float f1 = -minX;
      float f2 = -minY;
      if (paramPreserveAspectRatio.equals(PreserveAspectRatio.STRETCH))
      {
        localMatrix.preTranslate(minX, minY);
        localMatrix.preScale(f3, f4);
        localMatrix.preTranslate(f1, f2);
        return localMatrix;
      }
      if (paramPreserveAspectRatio.getScale() == PreserveAspectRatio.Scale.slice) {
        f3 = Math.max(f3, f4);
      } else {
        f3 = Math.min(f3, f4);
      }
      float f5 = width / f3;
      f4 = height / f3;
      switch (Format.height[paramPreserveAspectRatio.getAlignment().ordinal()])
      {
      default: 
        break;
      case 4: 
      case 5: 
      case 6: 
        f1 -= width - f5;
        break;
      case 1: 
      case 2: 
      case 3: 
        f1 -= (width - f5) / 2.0F;
      }
      switch (Format.height[paramPreserveAspectRatio.getAlignment().ordinal()])
      {
      default: 
        break;
      case 4: 
        break;
      case 3: 
      case 6: 
      case 8: 
        f2 -= height - f4;
        break;
      }
      f2 -= (height - f4) / 2.0F;
      localMatrix.preTranslate(minX, minY);
      localMatrix.preScale(f3, f3);
      localMatrix.preTranslate(f1, f2);
    }
    return localMatrix;
  }
  
  private void checkForClipPath(SVG.ah paramAh)
  {
    fillWithPattern(paramAh, boundingBox);
  }
  
  private void checkForClipPath(SVG.ah paramAh, SVG.a paramA)
  {
    Object localObject = document.resolveIRI(state.style.clipPath);
    if (localObject == null)
    {
      error("ClipPath reference '%s' not found", new Object[] { state.style.clipPath });
      return;
    }
    localObject = (SVG.d)localObject;
    if (children.isEmpty())
    {
      canvas.clipRect(0, 0, 0, 0);
      return;
    }
    int i;
    if ((clipPathUnitsAreUser != null) && (!clipPathUnitsAreUser.booleanValue())) {
      i = 0;
    } else {
      i = 1;
    }
    if (((paramAh instanceof SVG.k)) && (i == 0))
    {
      warn("<clipPath clipPathUnits=\"objectBoundingBox\"> is not supported when referenced from container elements (like %s)", new Object[] { paramAh.getAttributeName() });
      return;
    }
    clipStatePush();
    if (i == 0)
    {
      paramAh = new Matrix();
      paramAh.preTranslate(minX, minY);
      paramAh.preScale(width, height);
      canvas.concat(paramAh);
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    state = findInheritFromAncestorState((SVG.ak)localObject);
    checkForClipPath((SVG.ah)localObject);
    paramAh = new Path();
    paramA = children.iterator();
    while (paramA.hasNext()) {
      addObjectToClip((SVG.ak)paramA.next(), true, paramAh, new Matrix());
    }
    canvas.clipPath(paramAh);
    clipStatePop();
  }
  
  private void checkForGradiantsAndPatterns(SVG.ah paramAh)
  {
    if ((state.style.fill instanceof SVG.s)) {
      decodePaintReference(true, boundingBox, (SVG.s)state.style.fill);
    }
    if ((state.style.stroke instanceof SVG.s)) {
      decodePaintReference(false, boundingBox, (SVG.s)state.style.stroke);
    }
  }
  
  private Bitmap checkForImageDataURL(String paramString)
  {
    if (!paramString.startsWith("data:")) {
      return null;
    }
    if (paramString.length() < 14) {
      return null;
    }
    int i = paramString.indexOf(',');
    if (i < 12) {
      return null;
    }
    if (!";base64".equals(paramString.substring(i - 7, i))) {
      return null;
    }
    try
    {
      paramString = Base64.decode(paramString.substring(i + 1), 0);
      i = paramString.length;
      paramString = BitmapFactory.decodeByteArray(paramString, 0, i);
      return paramString;
    }
    catch (Exception paramString)
    {
      Log.e("SVGAndroidRenderer", "Could not decode bad Data URL", paramString);
    }
    return null;
  }
  
  private Typeface checkGenericFont(String paramString, Integer paramInteger, SVG.Style.FontStyle paramFontStyle)
  {
    SVG.Style.FontStyle localFontStyle = SVG.Style.FontStyle.Italic;
    int k = 1;
    if (paramFontStyle == localFontStyle) {
      i = 1;
    } else {
      i = 0;
    }
    int j;
    if (paramInteger.intValue() > 500)
    {
      if (i != 0) {
        j = 3;
      } else {
        j = 1;
      }
    }
    else if (i != 0) {
      j = 2;
    } else {
      j = 0;
    }
    switch (paramString.hashCode())
    {
    default: 
      break;
    case 1126973893: 
      if (paramString.equals("cursive")) {
        i = 3;
      }
      break;
    case 109326717: 
      if (paramString.equals("serif")) {
        i = 0;
      }
      break;
    case -1081737434: 
      if (paramString.equals("fantasy")) {
        i = 4;
      }
      break;
    case -1431958525: 
      if (paramString.equals("monospace")) {
        i = 2;
      }
      break;
    case -1536685117: 
      if (paramString.equals("sans-serif")) {
        i = k;
      }
      break;
    }
    int i = -1;
    switch (i)
    {
    default: 
      return null;
    case 4: 
      return Typeface.create(Typeface.SANS_SERIF, j);
    case 3: 
      return Typeface.create(Typeface.SANS_SERIF, j);
    case 2: 
      return Typeface.create(Typeface.MONOSPACE, j);
    case 1: 
      return Typeface.create(Typeface.SANS_SERIF, j);
    }
    return Typeface.create(Typeface.SERIF, j);
  }
  
  private void checkXMLSpaceAttribute(SVG.ak paramAk)
  {
    if (!(paramAk instanceof SVG.ai)) {
      return;
    }
    paramAk = (SVG.ai)paramAk;
    if (spacePreserve != null) {
      state.spacePreserve = spacePreserve.booleanValue();
    }
  }
  
  private static int clamp255(float paramFloat)
  {
    int i = (int)(paramFloat * 256.0F);
    if (i < 0) {
      return 0;
    }
    if (i > 255) {
      return 255;
    }
    return i;
  }
  
  private static int clamp255(int paramInt, float paramFloat)
  {
    int i = 255;
    int j = Math.round((paramInt >> 24 & 0xFF) * paramFloat);
    if (j < 0) {
      i = 0;
    } else if (j <= 255) {
      i = j;
    }
    return paramInt & 0xFFFFFF | i << 24;
  }
  
  private void clipStatePop()
  {
    canvas.restore();
    state = ((RendererState)stateStack.pop());
  }
  
  private void clipStatePush()
  {
    f.a(canvas, f.h);
    stateStack.push(state);
    state = new RendererState(state);
  }
  
  private static void debug(String paramString, Object... paramVarArgs) {}
  
  private void decodePaintReference(boolean paramBoolean, SVG.a paramA, SVG.s paramS)
  {
    SVG.ak localAk = document.resolveIRI(href);
    if (localAk == null)
    {
      if (paramBoolean) {
        paramA = "Fill";
      } else {
        paramA = "Stroke";
      }
      error("%s reference '%s' not found", new Object[] { paramA, href });
      if (fallback != null)
      {
        setPaintColour(state, paramBoolean, fallback);
        return;
      }
      if (paramBoolean)
      {
        state.hasFill = false;
        return;
      }
      state.hasStroke = false;
      return;
    }
    if ((localAk instanceof SVG.aj))
    {
      makeLinearGradiant(paramBoolean, paramA, (SVG.aj)localAk);
      return;
    }
    if ((localAk instanceof SVG.an))
    {
      makeRadialGradiant(paramBoolean, paramA, (SVG.an)localAk);
      return;
    }
    if ((localAk instanceof SVG.aa)) {
      setSolidColor(paramBoolean, (SVG.aa)localAk);
    }
  }
  
  private boolean display()
  {
    if (state.style.display != null) {
      return state.style.display.booleanValue();
    }
    return true;
  }
  
  private void doFilledPath(SVG.ah paramAh, Path paramPath)
  {
    if ((state.style.fill instanceof SVG.s))
    {
      SVG.ak localAk = document.resolveIRI(state.style.fill).href);
      if ((localAk instanceof SVG.w))
      {
        fillWithPattern(paramAh, paramPath, (SVG.w)localAk);
        return;
      }
    }
    canvas.drawPath(paramPath, state.fillPaint);
  }
  
  private void doStroke(Path paramPath)
  {
    if (state.style.vectorEffect == SVG.Style.VectorEffect.NonScalingStroke)
    {
      Matrix localMatrix1 = canvas.getMatrix();
      Path localPath = new Path();
      paramPath.transform(localMatrix1, localPath);
      canvas.setMatrix(new Matrix());
      paramPath = state.strokePaint.getShader();
      Matrix localMatrix2 = new Matrix();
      if (paramPath != null)
      {
        paramPath.getLocalMatrix(localMatrix2);
        Matrix localMatrix3 = new Matrix(localMatrix2);
        localMatrix3.postConcat(localMatrix1);
        paramPath.setLocalMatrix(localMatrix3);
      }
      canvas.drawPath(localPath, state.strokePaint);
      canvas.setMatrix(localMatrix1);
      if (paramPath != null) {
        paramPath.setLocalMatrix(localMatrix2);
      }
    }
    else
    {
      canvas.drawPath(paramPath, state.strokePaint);
    }
  }
  
  private void enumerateTextSpans(SVG.av paramAv, TextProcessor paramTextProcessor)
  {
    if (!display()) {
      return;
    }
    paramAv = children.iterator();
    for (boolean bool = true; paramAv.hasNext(); bool = false)
    {
      SVG.ak localAk = (SVG.ak)paramAv.next();
      if ((localAk instanceof SVG.az)) {
        paramTextProcessor.processText(textXMLSpaceTransform(text, bool, paramAv.hasNext() ^ true));
      } else {
        processTextChild(localAk, paramTextProcessor);
      }
    }
  }
  
  private static void error(String paramString, Object... paramVarArgs)
  {
    Log.e("SVGAndroidRenderer", String.format(paramString, paramVarArgs));
  }
  
  private void extractRawText(SVG.av paramAv, StringBuilder paramStringBuilder)
  {
    paramAv = children.iterator();
    for (boolean bool = true; paramAv.hasNext(); bool = false)
    {
      SVG.ak localAk = (SVG.ak)paramAv.next();
      if ((localAk instanceof SVG.av)) {
        extractRawText((SVG.av)localAk, paramStringBuilder);
      } else if ((localAk instanceof SVG.az)) {
        paramStringBuilder.append(textXMLSpaceTransform(text, bool, paramAv.hasNext() ^ true));
      }
    }
  }
  
  private void fillInChainedGradientFields(SVG.an paramAn1, SVG.an paramAn2)
  {
    if (cx == null) {
      cx = cx;
    }
    if (cy == null) {
      cy = cy;
    }
    if (r == null) {
      r = r;
    }
    if (fx == null) {
      fx = fx;
    }
    if (fy == null) {
      fy = fy;
    }
  }
  
  private void fillInChainedGradientFields(SVG.i paramI, String paramString)
  {
    SVG.ak localAk = document.resolveIRI(paramString);
    if (localAk == null)
    {
      warn("Gradient reference '%s' not found", new Object[] { paramString });
      return;
    }
    if (!(localAk instanceof SVG.i))
    {
      error("Gradient href attributes must point to other gradient elements", new Object[0]);
      return;
    }
    if (localAk == paramI)
    {
      error("Circular reference in gradient href attribute '%s'", new Object[] { paramString });
      return;
    }
    paramString = (SVG.i)localAk;
    if (gradientUnitsAreUser == null) {
      gradientUnitsAreUser = gradientUnitsAreUser;
    }
    if (gradientTransform == null) {
      gradientTransform = gradientTransform;
    }
    if (spreadMethod == null) {
      spreadMethod = spreadMethod;
    }
    if (children.isEmpty()) {
      children = children;
    }
    if ((paramI instanceof SVG.aj)) {}
    try
    {
      fillInChainedPatternFields((SVG.aj)paramI, (SVG.aj)localAk);
    }
    catch (ClassCastException localClassCastException)
    {
      for (;;) {}
    }
    fillInChainedGradientFields((SVG.an)paramI, (SVG.an)localAk);
    if (href != null)
    {
      fillInChainedGradientFields(paramI, href);
      return;
    }
  }
  
  private void fillInChainedPatternFields(SVG.aj paramAj1, SVG.aj paramAj2)
  {
    if (x == null) {
      x = x;
    }
    if (y == null) {
      y = y;
    }
    if (width == null) {
      width = width;
    }
    if (height == null) {
      height = height;
    }
  }
  
  private void fillInChainedPatternFields(SVG.w paramW, String paramString)
  {
    SVG.ak localAk = document.resolveIRI(paramString);
    if (localAk == null)
    {
      warn("Pattern reference '%s' not found", new Object[] { paramString });
      return;
    }
    if (!(localAk instanceof SVG.w))
    {
      error("Pattern href attributes must point to other pattern elements", new Object[0]);
      return;
    }
    if (localAk == paramW)
    {
      error("Circular reference in pattern href attribute '%s'", new Object[] { paramString });
      return;
    }
    paramString = (SVG.w)localAk;
    if (patternUnitsAreUser == null) {
      patternUnitsAreUser = patternUnitsAreUser;
    }
    if (patternContentUnitsAreUser == null) {
      patternContentUnitsAreUser = patternContentUnitsAreUser;
    }
    if (patternTransform == null) {
      patternTransform = patternTransform;
    }
    if (x == null) {
      x = x;
    }
    if (y == null) {
      y = y;
    }
    if (width == null) {
      width = width;
    }
    if (height == null) {
      height = height;
    }
    if (children.isEmpty()) {
      children = children;
    }
    if (viewBox == null) {
      viewBox = viewBox;
    }
    if (preserveAspectRatio == null) {
      preserveAspectRatio = preserveAspectRatio;
    }
    if (href != null) {
      fillInChainedPatternFields(paramW, href);
    }
  }
  
  private void fillWithPattern(SVG.ah paramAh, Path paramPath, SVG.w paramW)
  {
    int i;
    if ((patternUnitsAreUser != null) && (patternUnitsAreUser.booleanValue())) {
      i = 1;
    } else {
      i = 0;
    }
    if (href != null) {
      fillInChainedPatternFields(paramW, href);
    }
    float f1;
    float f3;
    float f2;
    float f4;
    float f5;
    float f6;
    if (i != 0)
    {
      if (x != null) {
        f1 = x.floatValueX(this);
      } else {
        f1 = 0.0F;
      }
      if (y != null) {
        f3 = y.floatValueY(this);
      } else {
        f3 = 0.0F;
      }
      if (width != null) {
        f2 = width.floatValueX(this);
      } else {
        f2 = 0.0F;
      }
      if (height != null) {
        f4 = height.floatValueY(this);
      } else {
        f4 = 0.0F;
      }
      f5 = f3;
      f3 = f4;
    }
    else
    {
      if (x != null) {
        f2 = x.floatValue(this, 1.0F);
      } else {
        f2 = 0.0F;
      }
      if (y != null) {
        f3 = y.floatValue(this, 1.0F);
      } else {
        f3 = 0.0F;
      }
      if (width != null) {
        f1 = width.floatValue(this, 1.0F);
      } else {
        f1 = 0.0F;
      }
      if (height != null) {
        f4 = height.floatValue(this, 1.0F);
      } else {
        f4 = 0.0F;
      }
      f5 = boundingBox.minX;
      f6 = f2 * boundingBox.width + f5;
      f2 = boundingBox.minY;
      f5 = f3 * boundingBox.height + f2;
      f2 = boundingBox.width;
      f3 = f4 * boundingBox.height;
      f2 = f1 * f2;
      f1 = f6;
    }
    if (f2 != 0.0F)
    {
      if (f3 == 0.0F) {
        return;
      }
      PreserveAspectRatio localPreserveAspectRatio;
      if (preserveAspectRatio != null) {
        localPreserveAspectRatio = preserveAspectRatio;
      } else {
        localPreserveAspectRatio = PreserveAspectRatio.preserveAspectRatio;
      }
      statePush();
      canvas.clipPath(paramPath);
      paramPath = new RendererState();
      updateStyle(paramPath, SVG.Style.getDefaultStyle());
      style.overflow = Boolean.valueOf(false);
      state = findInheritFromAncestorState(paramW, paramPath);
      Object localObject = boundingBox;
      paramPath = (Path)localObject;
      if (patternTransform != null)
      {
        canvas.concat(patternTransform);
        Matrix localMatrix = new Matrix();
        paramPath = (Path)localObject;
        if (patternTransform.invert(localMatrix))
        {
          paramPath = new float[8];
          paramPath[0] = boundingBox.minX;
          paramPath[1] = boundingBox.minY;
          paramPath[2] = boundingBox.maxX();
          paramPath[3] = boundingBox.minY;
          paramPath[4] = boundingBox.maxX();
          paramPath[5] = boundingBox.maxY();
          paramPath[6] = boundingBox.minX;
          paramPath[7] = boundingBox.maxY();
          localMatrix.mapPoints(paramPath);
          localObject = new RectF(paramPath[0], paramPath[1], paramPath[0], paramPath[1]);
          i = 2;
          while (i <= 6)
          {
            if (paramPath[i] < left) {
              left = paramPath[i];
            }
            if (paramPath[i] > right) {
              right = paramPath[i];
            }
            int j = i + 1;
            if (paramPath[j] < top) {
              top = paramPath[j];
            }
            if (paramPath[j] > bottom) {
              bottom = paramPath[j];
            }
            i += 2;
          }
          paramPath = new SVG.a(left, top, right - left, bottom - top);
        }
      }
      f6 = (float)Math.floor((minX - f1) / f2);
      f4 = f5 + (float)Math.floor((minY - f5) / f3) * f3;
      float f7 = paramPath.maxX();
      float f8 = paramPath.maxY();
      paramPath = new SVG.a(0.0F, 0.0F, f2, f3);
      boolean bool = pushLayer();
      while (f4 < f8)
      {
        for (f5 = f1 + f6 * f2; f5 < f7; f5 += f2)
        {
          minX = f5;
          minY = f4;
          statePush();
          if (!state.style.overflow.booleanValue()) {
            setClipRect(minX, minY, width, height);
          }
          if (viewBox != null)
          {
            canvas.concat(calculateViewBoxTransform(paramPath, viewBox, localPreserveAspectRatio));
          }
          else
          {
            if ((patternContentUnitsAreUser != null) && (!patternContentUnitsAreUser.booleanValue())) {
              i = 0;
            } else {
              i = 1;
            }
            canvas.translate(f5, f4);
            if (i == 0) {
              canvas.scale(boundingBox.width, boundingBox.height);
            }
          }
          localObject = children.iterator();
          while (((Iterator)localObject).hasNext()) {
            render((SVG.ak)((Iterator)localObject).next());
          }
          statePop();
        }
        f4 += f3;
      }
      if (bool) {
        popLayer(paramW);
      }
      statePop();
    }
  }
  
  private void fillWithPattern(SVG.ah paramAh, SVG.a paramA)
  {
    if (state.style.clipPath == null) {
      return;
    }
    if (Build.VERSION.SDK_INT >= 19)
    {
      paramAh = render(paramAh, paramA);
      if (paramAh != null) {
        canvas.clipPath(paramAh);
      }
    }
    else
    {
      checkForClipPath(paramAh, paramA);
    }
  }
  
  private RendererState findInheritFromAncestorState(SVG.ak paramAk)
  {
    RendererState localRendererState = new RendererState();
    updateStyle(localRendererState, SVG.Style.getDefaultStyle());
    return findInheritFromAncestorState(paramAk, localRendererState);
  }
  
  private RendererState findInheritFromAncestorState(SVG.ak paramAk, RendererState paramRendererState)
  {
    ArrayList localArrayList = new ArrayList();
    for (;;)
    {
      if ((paramAk instanceof SVG.ai)) {
        localArrayList.add(0, (SVG.ai)paramAk);
      }
      if (parent == null)
      {
        paramAk = localArrayList.iterator();
        while (paramAk.hasNext()) {
          updateStyleForElement(paramRendererState, (SVG.ai)paramAk.next());
        }
        viewBox = state.viewBox;
        viewPort = state.viewPort;
        return paramRendererState;
      }
      paramAk = (SVG.ak)parent;
    }
  }
  
  private SVG.Style.TextAnchor getAnchorPosition()
  {
    if ((state.style.direction != SVG.Style.TextDirection.LTR) && (state.style.textAnchor != SVG.Style.TextAnchor.Middle))
    {
      if (state.style.textAnchor == SVG.Style.TextAnchor.Start) {
        return SVG.Style.TextAnchor.End;
      }
      return SVG.Style.TextAnchor.Start;
    }
    return state.style.textAnchor;
  }
  
  private Path.FillType getClipRuleFromState()
  {
    if ((state.style.clipRule != null) && (state.style.clipRule == SVG.Style.FillRule.EvenOdd)) {
      return Path.FillType.EVEN_ODD;
    }
    return Path.FillType.WINDING;
  }
  
  private Path.FillType getFillTypeFromState()
  {
    if ((state.style.fillRule != null) && (state.style.fillRule == SVG.Style.FillRule.EvenOdd)) {
      return Path.FillType.EVEN_ODD;
    }
    return Path.FillType.WINDING;
  }
  
  private static void initialiseSupportedFeaturesMap()
  {
    try
    {
      supportedFeatures = new HashSet();
      supportedFeatures.add("Structure");
      supportedFeatures.add("BasicStructure");
      supportedFeatures.add("ConditionalProcessing");
      supportedFeatures.add("Image");
      supportedFeatures.add("Style");
      supportedFeatures.add("ViewportAttribute");
      supportedFeatures.add("Shape");
      supportedFeatures.add("BasicText");
      supportedFeatures.add("PaintAttribute");
      supportedFeatures.add("BasicPaintAttribute");
      supportedFeatures.add("OpacityAttribute");
      supportedFeatures.add("BasicGraphicsAttribute");
      supportedFeatures.add("Marker");
      supportedFeatures.add("Gradient");
      supportedFeatures.add("Pattern");
      supportedFeatures.add("Clip");
      supportedFeatures.add("BasicClip");
      supportedFeatures.add("Mask");
      supportedFeatures.add("View");
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private boolean isSpecified(SVG.Style paramStyle, long paramLong)
  {
    return (paramLong & specifiedFlags) != 0L;
  }
  
  private void makeLinearGradiant(boolean paramBoolean, SVG.a paramA, SVG.aj paramAj)
  {
    if (href != null) {
      fillInChainedGradientFields(paramAj, href);
    }
    Object localObject1 = gradientUnitsAreUser;
    int j = 0;
    if ((localObject1 != null) && (gradientUnitsAreUser.booleanValue())) {
      i = 1;
    } else {
      i = 0;
    }
    if (paramBoolean) {
      localObject1 = state.fillPaint;
    } else {
      localObject1 = state.strokePaint;
    }
    float f1;
    float f2;
    float f3;
    float f4;
    float f5;
    if (i != 0)
    {
      localObject2 = getCurrentViewPortInUserUnits();
      if (x != null) {
        f1 = x.floatValueX(this);
      } else {
        f1 = 0.0F;
      }
      if (y != null) {
        f2 = y.floatValueY(this);
      } else {
        f2 = 0.0F;
      }
      if (width != null) {
        f3 = width.floatValueX(this);
      } else {
        f3 = width;
      }
      if (height != null) {
        f4 = height.floatValueY(this);
      } else {
        f4 = 0.0F;
      }
      f5 = f1;
    }
    else
    {
      if (x != null) {
        f1 = x.floatValue(this, 1.0F);
      } else {
        f1 = 0.0F;
      }
      if (y != null) {
        f2 = y.floatValue(this, 1.0F);
      } else {
        f2 = 0.0F;
      }
      if (width != null) {
        f3 = width.floatValue(this, 1.0F);
      } else {
        f3 = 1.0F;
      }
      if (height != null) {
        f4 = height.floatValue(this, 1.0F);
      } else {
        f4 = 0.0F;
      }
      f5 = f1;
    }
    statePush();
    state = findInheritFromAncestorState(paramAj);
    Matrix localMatrix = new Matrix();
    if (i == 0)
    {
      localMatrix.preTranslate(minX, minY);
      localMatrix.preScale(width, height);
    }
    if (gradientTransform != null) {
      localMatrix.preConcat(gradientTransform);
    }
    int k = children.size();
    if (k == 0)
    {
      statePop();
      if (paramBoolean)
      {
        state.hasFill = false;
        return;
      }
      state.hasStroke = false;
      return;
    }
    int[] arrayOfInt = new int[k];
    float[] arrayOfFloat = new float[k];
    float f6 = -1.0F;
    Iterator localIterator = children.iterator();
    int i = j;
    while (localIterator.hasNext())
    {
      paramA = (SVG.ab)localIterator.next();
      if (offset != null) {
        f1 = offset.floatValue();
      } else {
        f1 = 0.0F;
      }
      if ((i != 0) && (f1 < f6))
      {
        arrayOfFloat[i] = f6;
        f1 = f6;
      }
      else
      {
        arrayOfFloat[i] = f1;
      }
      statePush();
      updateStyleForElement(state, paramA);
      localObject2 = (SVG.e)state.style.stopColor;
      paramA = (SVG.a)localObject2;
      if (localObject2 == null) {
        paramA = SVG.e.BLACK;
      }
      arrayOfInt[i] = clamp255(style, state.style.stopOpacity.floatValue());
      i += 1;
      statePop();
      f6 = f1;
    }
    if (((f5 == f3) && (f2 == f4)) || (k == 1))
    {
      statePop();
      ((Paint)localObject1).setColor(arrayOfInt[(k - 1)]);
      return;
    }
    Object localObject2 = Shader.TileMode.CLAMP;
    paramA = (SVG.a)localObject2;
    if (spreadMethod != null) {
      if (spreadMethod == SVG.GradientSpread.reflect)
      {
        paramA = Shader.TileMode.MIRROR;
      }
      else
      {
        paramA = (SVG.a)localObject2;
        if (spreadMethod == SVG.GradientSpread.repeat) {
          paramA = Shader.TileMode.REPEAT;
        }
      }
    }
    statePop();
    paramA = new LinearGradient(f5, f2, f3, f4, arrayOfInt, arrayOfFloat, paramA);
    paramA.setLocalMatrix(localMatrix);
    ((Paint)localObject1).setShader(paramA);
    ((Paint)localObject1).setAlpha(clamp255(state.style.fillOpacity.floatValue()));
  }
  
  private Path makePathAndBoundingBox(SVG.c paramC)
  {
    SVG.n localN = cx;
    float f2 = 0.0F;
    float f1;
    if (localN != null) {
      f1 = cx.floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    if (cy != null) {
      f2 = cy.floatValueY(this);
    }
    float f7 = r.floatValue(this);
    float f3 = f1 - f7;
    float f4 = f2 - f7;
    float f6 = f1 + f7;
    float f5 = f2 + f7;
    if (boundingBox == null)
    {
      f8 = 2.0F * f7;
      boundingBox = new SVG.a(f3, f4, f8, f8);
    }
    float f9 = 0.5522848F * f7;
    paramC = new Path();
    paramC.moveTo(f1, f4);
    float f10 = f1 + f9;
    f7 = f2 - f9;
    paramC.cubicTo(f10, f4, f6, f7, f6, f2);
    float f8 = f2 + f9;
    paramC.cubicTo(f6, f8, f10, f5, f1, f5);
    f6 = f1 - f9;
    paramC.cubicTo(f6, f5, f3, f8, f3, f2);
    paramC.cubicTo(f3, f7, f6, f4, f1, f4);
    paramC.close();
    return paramC;
  }
  
  private Path makePathAndBoundingBox(SVG.h paramH)
  {
    SVG.n localN = cx;
    float f2 = 0.0F;
    float f1;
    if (localN != null) {
      f1 = cx.floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    if (cy != null) {
      f2 = cy.floatValueY(this);
    }
    float f7 = rx.floatValueX(this);
    float f8 = ry.floatValueY(this);
    float f3 = f1 - f7;
    float f4 = f2 - f8;
    float f6 = f1 + f7;
    float f5 = f2 + f8;
    if (boundingBox == null) {
      boundingBox = new SVG.a(f3, f4, f7 * 2.0F, 2.0F * f8);
    }
    f7 *= 0.5522848F;
    float f10 = 0.5522848F * f8;
    paramH = new Path();
    paramH.moveTo(f1, f4);
    float f9 = f1 + f7;
    f8 = f2 - f10;
    paramH.cubicTo(f9, f4, f6, f8, f6, f2);
    f10 += f2;
    paramH.cubicTo(f6, f10, f9, f5, f1, f5);
    f6 = f1 - f7;
    paramH.cubicTo(f6, f5, f3, f10, f3, f2);
    paramH.cubicTo(f3, f8, f6, f4, f1, f4);
    paramH.close();
    return paramH;
  }
  
  private Path makePathAndBoundingBox(SVG.o paramO)
  {
    SVG.n localN = x;
    float f4 = 0.0F;
    float f1;
    if (localN == null) {
      f1 = 0.0F;
    } else {
      f1 = x.floatValueX(this);
    }
    float f2;
    if (y == null) {
      f2 = 0.0F;
    } else {
      f2 = y.floatValueY(this);
    }
    float f3;
    if (width == null) {
      f3 = 0.0F;
    } else {
      f3 = width.floatValueX(this);
    }
    if (height != null) {
      f4 = height.floatValueY(this);
    }
    if (boundingBox == null) {
      boundingBox = new SVG.a(Math.min(f1, f3), Math.min(f2, f4), Math.abs(f3 - f1), Math.abs(f4 - f2));
    }
    paramO = new Path();
    paramO.moveTo(f1, f2);
    paramO.lineTo(f3, f4);
    return paramO;
  }
  
  private Path makePathAndBoundingBox(SVG.x paramX)
  {
    Path localPath = new Path();
    localPath.moveTo(points[0], points[1]);
    int i = 2;
    while (i < points.length)
    {
      localPath.lineTo(points[i], points[(i + 1)]);
      i += 2;
    }
    if ((paramX instanceof SVG.y)) {
      localPath.close();
    }
    if (boundingBox == null) {
      boundingBox = calculatePathBounds(localPath);
    }
    return localPath;
  }
  
  private Path makePathAndBoundingBox(SVG.z paramZ)
  {
    float f1;
    float f2;
    if ((rx == null) && (ry == null))
    {
      f1 = 0.0F;
      f2 = 0.0F;
    }
    else if (rx == null)
    {
      f2 = ry.floatValueY(this);
      f1 = f2;
    }
    else if (ry == null)
    {
      f2 = rx.floatValueX(this);
      f1 = f2;
    }
    else
    {
      f1 = rx.floatValueX(this);
      f2 = ry.floatValueY(this);
    }
    float f4 = Math.min(f1, width.floatValueX(this) / 2.0F);
    float f3 = Math.min(f2, height.floatValueY(this) / 2.0F);
    if (x != null) {
      f1 = x.floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    if (y != null) {
      f2 = y.floatValueY(this);
    } else {
      f2 = 0.0F;
    }
    float f5 = width.floatValueX(this);
    float f6 = height.floatValueY(this);
    if (boundingBox == null) {
      boundingBox = new SVG.a(f1, f2, f5, f6);
    }
    f5 = f1 + f5;
    f6 = f2 + f6;
    paramZ = new Path();
    if ((f4 != 0.0F) && (f3 != 0.0F))
    {
      float f12 = f4 * 0.5522848F;
      float f10 = 0.5522848F * f3;
      float f7 = f2 + f3;
      paramZ.moveTo(f1, f7);
      float f11 = f7 - f10;
      float f8 = f1 + f4;
      float f9 = f8 - f12;
      paramZ.cubicTo(f1, f11, f9, f2, f8, f2);
      f4 = f5 - f4;
      paramZ.lineTo(f4, f2);
      f12 = f4 + f12;
      paramZ.cubicTo(f12, f2, f5, f11, f5, f7);
      f2 = f6 - f3;
      paramZ.lineTo(f5, f2);
      f3 = f10 + f2;
      paramZ.cubicTo(f5, f3, f12, f6, f4, f6);
      paramZ.lineTo(f8, f6);
      paramZ.cubicTo(f9, f6, f1, f3, f1, f2);
      paramZ.lineTo(f1, f7);
    }
    else
    {
      paramZ.moveTo(f1, f2);
      paramZ.lineTo(f5, f2);
      paramZ.lineTo(f5, f6);
      paramZ.lineTo(f1, f6);
      paramZ.lineTo(f1, f2);
    }
    paramZ.close();
    return paramZ;
  }
  
  private void makeRadialGradiant(boolean paramBoolean, SVG.a paramA, SVG.an paramAn)
  {
    if (href != null) {
      fillInChainedGradientFields(paramAn, href);
    }
    Object localObject1 = gradientUnitsAreUser;
    int j = 0;
    if ((localObject1 != null) && (gradientUnitsAreUser.booleanValue())) {
      i = 1;
    } else {
      i = 0;
    }
    if (paramBoolean) {
      localObject1 = state.fillPaint;
    } else {
      localObject1 = state.strokePaint;
    }
    Object localObject2;
    float f1;
    float f2;
    float f4;
    float f3;
    if (i != 0)
    {
      localObject2 = new SVG.n(50.0F, SVG.Unit.percent);
      if (cx != null) {
        f1 = cx.floatValueX(this);
      } else {
        f1 = ((SVG.n)localObject2).floatValueX(this);
      }
      if (cy != null) {
        f2 = cy.floatValueY(this);
      } else {
        f2 = ((SVG.n)localObject2).floatValueY(this);
      }
      if (r != null) {
        localObject2 = r;
      }
      f4 = ((SVG.n)localObject2).floatValue(this);
      f3 = f1;
    }
    else
    {
      if (cx != null) {
        f2 = cx.floatValue(this, 1.0F);
      } else {
        f2 = 0.5F;
      }
      if (cy != null) {
        f1 = cy.floatValue(this, 1.0F);
      } else {
        f1 = 0.5F;
      }
      if (r != null) {
        f3 = r.floatValue(this, 1.0F);
      } else {
        f3 = 0.5F;
      }
      f5 = f2;
      f4 = f3;
      f2 = f1;
      f3 = f5;
    }
    statePush();
    state = findInheritFromAncestorState(paramAn);
    Matrix localMatrix = new Matrix();
    if (i == 0)
    {
      localMatrix.preTranslate(minX, minY);
      localMatrix.preScale(width, height);
    }
    if (gradientTransform != null) {
      localMatrix.preConcat(gradientTransform);
    }
    int k = children.size();
    if (k == 0)
    {
      statePop();
      if (paramBoolean)
      {
        state.hasFill = false;
        return;
      }
      state.hasStroke = false;
      return;
    }
    int[] arrayOfInt = new int[k];
    float[] arrayOfFloat = new float[k];
    float f5 = -1.0F;
    Iterator localIterator = children.iterator();
    int i = j;
    for (;;)
    {
      paramBoolean = localIterator.hasNext();
      f1 = 0.0F;
      if (!paramBoolean) {
        break;
      }
      paramA = (SVG.ab)localIterator.next();
      if (offset != null) {
        f1 = offset.floatValue();
      }
      if ((i != 0) && (f1 < f5))
      {
        arrayOfFloat[i] = f5;
        f1 = f5;
      }
      else
      {
        arrayOfFloat[i] = f1;
      }
      statePush();
      updateStyleForElement(state, paramA);
      localObject2 = (SVG.e)state.style.stopColor;
      paramA = (SVG.a)localObject2;
      if (localObject2 == null) {
        paramA = SVG.e.BLACK;
      }
      arrayOfInt[i] = clamp255(style, state.style.stopOpacity.floatValue());
      i += 1;
      statePop();
      f5 = f1;
    }
    if ((f4 != 0.0F) && (k != 1))
    {
      localObject2 = Shader.TileMode.CLAMP;
      paramA = (SVG.a)localObject2;
      if (spreadMethod != null) {
        if (spreadMethod == SVG.GradientSpread.reflect)
        {
          paramA = Shader.TileMode.MIRROR;
        }
        else
        {
          paramA = (SVG.a)localObject2;
          if (spreadMethod == SVG.GradientSpread.repeat) {
            paramA = Shader.TileMode.REPEAT;
          }
        }
      }
      statePop();
      paramA = new RadialGradient(f3, f2, f4, arrayOfInt, arrayOfFloat, paramA);
      paramA.setLocalMatrix(localMatrix);
      ((Paint)localObject1).setShader(paramA);
      ((Paint)localObject1).setAlpha(clamp255(state.style.fillOpacity.floatValue()));
      return;
    }
    statePop();
    ((Paint)localObject1).setColor(arrayOfInt[(k - 1)]);
  }
  
  private void parentPop()
  {
    parentStack.pop();
    matrixStack.pop();
  }
  
  private void parentPush(SVG.ag paramAg)
  {
    parentStack.push(paramAg);
    matrixStack.push(canvas.getMatrix());
  }
  
  private void popLayer(SVG.ah paramAh)
  {
    transform(paramAh, boundingBox);
  }
  
  private void processTextChild(SVG.ak paramAk, TextProcessor paramTextProcessor)
  {
    if (!paramTextProcessor.doTextContainer((SVG.av)paramAk)) {
      return;
    }
    if ((paramAk instanceof SVG.aw))
    {
      statePush();
      renderTextPath((SVG.aw)paramAk);
      statePop();
      return;
    }
    boolean bool = paramAk instanceof SVG.as;
    int i = 1;
    Object localObject;
    if (bool)
    {
      debug("TSpan render", new Object[0]);
      statePush();
      paramAk = (SVG.as)paramAk;
      updateStyleForElement(state, paramAk);
      if (display())
      {
        if ((x == null) || (x.size() <= 0)) {
          i = 0;
        }
        bool = paramTextProcessor instanceof PlainTextDrawer;
        float f1 = 0.0F;
        float f5 = 0.0F;
        float f3;
        float f4;
        if (bool)
        {
          if (i == 0) {
            f1 = x;
          } else {
            f1 = ((SVG.n)x.get(0)).floatValueX(this);
          }
          if ((y != null) && (y.size() != 0)) {
            f2 = ((SVG.n)y.get(0)).floatValueY(this);
          } else {
            f2 = y;
          }
          if ((dx != null) && (dx.size() != 0)) {
            f3 = ((SVG.n)dx.get(0)).floatValueX(this);
          } else {
            f3 = 0.0F;
          }
          f4 = f5;
          if (dy != null) {
            if (dy.size() == 0) {
              f4 = f5;
            } else {
              f4 = ((SVG.n)dy.get(0)).floatValueY(this);
            }
          }
          f5 = f4;
          f4 = f2;
        }
        else
        {
          f5 = 0.0F;
          f4 = 0.0F;
          f3 = 0.0F;
        }
        float f2 = f1;
        if (i != 0)
        {
          localObject = getAnchorPosition();
          f2 = f1;
          if (localObject != SVG.Style.TextAnchor.Start)
          {
            f2 = calculateTextWidth(paramAk);
            if (localObject == SVG.Style.TextAnchor.Middle) {
              f2 = f1 - f2 / 2.0F;
            } else {
              f2 = f1 - f2;
            }
          }
        }
        checkForGradiantsAndPatterns((SVG.ah)paramAk.n());
        if (bool)
        {
          localObject = (PlainTextDrawer)paramTextProcessor;
          x = (f2 + f3);
          y = (f4 + f5);
        }
        bool = pushLayer();
        enumerateTextSpans(paramAk, paramTextProcessor);
        if (bool) {
          popLayer(paramAk);
        }
      }
      statePop();
      return;
    }
    if ((paramAk instanceof SVG.ar))
    {
      statePush();
      localObject = (SVG.ar)paramAk;
      updateStyleForElement(state, (SVG.ai)localObject);
      if (display())
      {
        checkForGradiantsAndPatterns((SVG.ah)((SVG.ar)localObject).n());
        paramAk = document.resolveIRI(href);
        if ((paramAk != null) && ((paramAk instanceof SVG.av)))
        {
          localObject = new StringBuilder();
          extractRawText((SVG.av)paramAk, (StringBuilder)localObject);
          if (((StringBuilder)localObject).length() > 0) {
            paramTextProcessor.processText(((StringBuilder)localObject).toString());
          }
        }
        else
        {
          error("Tref reference '%s' not found", new Object[] { href });
        }
      }
      statePop();
    }
  }
  
  private boolean pushLayer()
  {
    if (!requiresCompositing()) {
      return false;
    }
    canvas.saveLayerAlpha(null, clamp255(state.style.opacity.floatValue()), 31);
    stateStack.push(state);
    state = new RendererState(state);
    if (state.style.mask != null)
    {
      SVG.ak localAk = document.resolveIRI(state.style.mask);
      if ((localAk == null) || (!(localAk instanceof SVG.q)))
      {
        error("Mask reference '%s' not found", new Object[] { state.style.mask });
        state.style.mask = null;
      }
    }
    return true;
  }
  
  private Path render(SVG.ah paramAh, SVG.a paramA)
  {
    paramAh = document.resolveIRI(state.style.clipPath);
    int i = 0;
    if (paramAh == null)
    {
      error("ClipPath reference '%s' not found", new Object[] { state.style.clipPath });
      return null;
    }
    Object localObject1 = (SVG.d)paramAh;
    stateStack.push(state);
    state = findInheritFromAncestorState((SVG.ak)localObject1);
    if ((clipPathUnitsAreUser == null) || (clipPathUnitsAreUser.booleanValue())) {
      i = 1;
    }
    paramAh = new Matrix();
    if (i == 0)
    {
      paramAh.preTranslate(minX, minY);
      paramAh.preScale(width, height);
    }
    if (transform != null) {
      paramAh.preConcat(transform);
    }
    paramA = new Path();
    Iterator localIterator = children.iterator();
    while (localIterator.hasNext())
    {
      Object localObject2 = (SVG.ak)localIterator.next();
      if ((localObject2 instanceof SVG.ah))
      {
        localObject2 = render((SVG.ah)localObject2, true);
        if (localObject2 != null) {
          paramA.op((Path)localObject2, Path.Op.UNION);
        }
      }
    }
    if (state.style.clipPath != null)
    {
      if (boundingBox == null) {
        boundingBox = calculatePathBounds(paramA);
      }
      localObject1 = render((SVG.ah)localObject1, boundingBox);
      if (localObject1 != null) {
        paramA.op((Path)localObject1, Path.Op.INTERSECT);
      }
    }
    paramA.transform(paramAh);
    state = ((RendererState)stateStack.pop());
    return paramA;
  }
  
  private Path render(SVG.ah paramAh, boolean paramBoolean)
  {
    stateStack.push(state);
    state = new RendererState(state);
    updateStyleForElement(state, paramAh);
    if ((display()) && (visible()))
    {
      Object localObject4;
      Object localObject1;
      Object localObject3;
      Object localObject2;
      if ((paramAh instanceof SVG.ba))
      {
        if (!paramBoolean) {
          error("<use> elements inside a <clipPath> cannot reference another <use>", new Object[0]);
        }
        localObject4 = (SVG.ba)paramAh;
        localObject1 = document.resolveIRI(href);
        if (localObject1 == null)
        {
          error("Use reference '%s' not found", new Object[] { href });
          state = ((RendererState)stateStack.pop());
          return null;
        }
        if (!(localObject1 instanceof SVG.ah))
        {
          state = ((RendererState)stateStack.pop());
          return null;
        }
        localObject3 = render((SVG.ah)localObject1, false);
        localObject2 = localObject3;
        if (localObject3 == null) {
          return null;
        }
        if (boundingBox == null) {
          boundingBox = calculatePathBounds((Path)localObject3);
        }
        localObject1 = localObject2;
        if (transform != null)
        {
          ((Path)localObject3).transform(transform);
          localObject1 = localObject2;
        }
      }
      else if ((paramAh instanceof SVG.j))
      {
        localObject4 = (SVG.j)paramAh;
        if ((paramAh instanceof SVG.t))
        {
          localObject3 = new Item(this, d).getPath();
          localObject2 = localObject3;
          localObject1 = localObject2;
          if (boundingBox == null)
          {
            boundingBox = calculatePathBounds((Path)localObject3);
            localObject1 = localObject2;
          }
        }
        else if ((paramAh instanceof SVG.z))
        {
          localObject1 = makePathAndBoundingBox((SVG.z)paramAh);
        }
        else if ((paramAh instanceof SVG.c))
        {
          localObject1 = makePathAndBoundingBox((SVG.c)paramAh);
        }
        else if ((paramAh instanceof SVG.h))
        {
          localObject1 = makePathAndBoundingBox((SVG.h)paramAh);
        }
        else if ((paramAh instanceof SVG.x))
        {
          localObject1 = makePathAndBoundingBox((SVG.x)paramAh);
        }
        else
        {
          localObject1 = null;
        }
        if (localObject1 == null) {
          return null;
        }
        if (boundingBox == null) {
          boundingBox = calculatePathBounds((Path)localObject1);
        }
        if (transform != null) {
          ((Path)localObject1).transform(transform);
        }
        ((Path)localObject1).setFillType(getClipRuleFromState());
      }
      else
      {
        if (!(paramAh instanceof SVG.at)) {
          break label532;
        }
        localObject3 = (SVG.at)paramAh;
        localObject2 = addObjectToClip((SVG.at)localObject3);
        localObject1 = localObject2;
        if (localObject2 == null) {
          return null;
        }
        if (transform != null) {
          ((Path)localObject2).transform(transform);
        }
        ((Path)localObject2).setFillType(getClipRuleFromState());
      }
      if (state.style.clipPath != null)
      {
        paramAh = render(paramAh, boundingBox);
        if (paramAh != null) {
          ((Path)localObject1).op(paramAh, Path.Op.INTERSECT);
        }
      }
      state = ((RendererState)stateStack.pop());
      return localObject1;
      label532:
      error("Invalid %s element found in clipPath definition", new Object[] { paramAh.getAttributeName() });
      return null;
    }
    state = ((RendererState)stateStack.pop());
    return null;
  }
  
  private SVG.a render(SVG.n paramN1, SVG.n paramN2, SVG.n paramN3, SVG.n paramN4)
  {
    float f2 = 0.0F;
    float f1;
    if (paramN1 != null) {
      f1 = paramN1.floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    if (paramN2 != null) {
      f2 = paramN2.floatValueY(this);
    }
    paramN1 = getCurrentViewPortInUserUnits();
    float f3;
    if (paramN3 != null) {
      f3 = paramN3.floatValueX(this);
    } else {
      f3 = width;
    }
    float f4;
    if (paramN4 != null) {
      f4 = paramN4.floatValueY(this);
    } else {
      f4 = height;
    }
    return new SVG.a(f1, f2, f3, f4);
  }
  
  private void render(SVG.ac paramAc)
  {
    render(paramAc, render(x, y, width, height), viewBox, preserveAspectRatio);
  }
  
  private void render(SVG.ac paramAc, SVG.a paramA)
  {
    render(paramAc, paramA, viewBox, preserveAspectRatio);
  }
  
  private void render(SVG.ac paramAc, SVG.a paramA1, SVG.a paramA2, PreserveAspectRatio paramPreserveAspectRatio)
  {
    debug("Svg render", new Object[0]);
    if (width != 0.0F)
    {
      if (height == 0.0F) {
        return;
      }
      PreserveAspectRatio localPreserveAspectRatio = paramPreserveAspectRatio;
      if (paramPreserveAspectRatio == null) {
        if (preserveAspectRatio != null) {
          localPreserveAspectRatio = preserveAspectRatio;
        } else {
          localPreserveAspectRatio = PreserveAspectRatio.preserveAspectRatio;
        }
      }
      updateStyleForElement(state, paramAc);
      if (!display()) {
        return;
      }
      paramPreserveAspectRatio = state;
      viewPort = paramA1;
      if (!style.overflow.booleanValue()) {
        setClipRect(state.viewPort.minX, state.viewPort.minY, state.viewPort.width, state.viewPort.height);
      }
      fillWithPattern(paramAc, state.viewPort);
      if (paramA2 != null)
      {
        canvas.concat(calculateViewBoxTransform(state.viewPort, paramA2, localPreserveAspectRatio));
        state.viewBox = viewBox;
      }
      else
      {
        canvas.translate(state.viewPort.minX, state.viewPort.minY);
      }
      boolean bool = pushLayer();
      viewportFill();
      renderChildren(paramAc, true);
      if (bool) {
        popLayer(paramAc);
      }
      updateParentBoundingBox(paramAc);
    }
  }
  
  private void render(SVG.ak paramAk)
  {
    if ((paramAk instanceof SVG.r)) {
      return;
    }
    statePush();
    checkXMLSpaceAttribute(paramAk);
    if ((paramAk instanceof SVG.ac)) {
      render((SVG.ac)paramAk);
    } else if ((paramAk instanceof SVG.ba)) {
      render((SVG.ba)paramAk);
    } else if ((paramAk instanceof SVG.ap)) {
      render((SVG.ap)paramAk);
    } else if ((paramAk instanceof SVG.k)) {
      render((SVG.k)paramAk);
    } else if ((paramAk instanceof SVG.m)) {
      render((SVG.m)paramAk);
    } else if ((paramAk instanceof SVG.t)) {
      render((SVG.t)paramAk);
    } else if ((paramAk instanceof SVG.z)) {
      render((SVG.z)paramAk);
    } else if ((paramAk instanceof SVG.c)) {
      render((SVG.c)paramAk);
    } else if ((paramAk instanceof SVG.h)) {
      render((SVG.h)paramAk);
    } else if ((paramAk instanceof SVG.o)) {
      render((SVG.o)paramAk);
    } else if ((paramAk instanceof SVG.y)) {
      render((SVG.y)paramAk);
    } else if ((paramAk instanceof SVG.x)) {
      render((SVG.x)paramAk);
    } else if ((paramAk instanceof SVG.at)) {
      render((SVG.at)paramAk);
    }
    statePop();
  }
  
  private void render(SVG.ap paramAp)
  {
    debug("Switch render", new Object[0]);
    updateStyleForElement(state, paramAp);
    if (!display()) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    checkForClipPath(paramAp);
    boolean bool = pushLayer();
    renderSwitchChild(paramAp);
    if (bool) {
      popLayer(paramAp);
    }
    updateParentBoundingBox(paramAp);
  }
  
  private void render(SVG.aq paramAq, SVG.a paramA)
  {
    debug("Symbol render", new Object[0]);
    if (width != 0.0F)
    {
      if (height == 0.0F) {
        return;
      }
      PreserveAspectRatio localPreserveAspectRatio;
      if (preserveAspectRatio != null) {
        localPreserveAspectRatio = preserveAspectRatio;
      } else {
        localPreserveAspectRatio = PreserveAspectRatio.preserveAspectRatio;
      }
      updateStyleForElement(state, paramAq);
      RendererState localRendererState = state;
      viewPort = paramA;
      if (!style.overflow.booleanValue()) {
        setClipRect(state.viewPort.minX, state.viewPort.minY, state.viewPort.width, state.viewPort.height);
      }
      if (viewBox != null)
      {
        canvas.concat(calculateViewBoxTransform(state.viewPort, viewBox, localPreserveAspectRatio));
        state.viewBox = viewBox;
      }
      else
      {
        canvas.translate(state.viewPort.minX, state.viewPort.minY);
      }
      boolean bool = pushLayer();
      renderChildren(paramAq, true);
      if (bool) {
        popLayer(paramAq);
      }
      updateParentBoundingBox(paramAq);
    }
  }
  
  private void render(SVG.at paramAt)
  {
    debug("Text render", new Object[0]);
    updateStyleForElement(state, paramAt);
    if (!display()) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    Object localObject = x;
    float f2 = 0.0F;
    float f1;
    if ((localObject != null) && (x.size() != 0)) {
      f1 = ((SVG.n)x.get(0)).floatValueX(this);
    } else {
      f1 = 0.0F;
    }
    float f3;
    if ((y != null) && (y.size() != 0)) {
      f3 = ((SVG.n)y.get(0)).floatValueY(this);
    } else {
      f3 = 0.0F;
    }
    float f4;
    if ((dx != null) && (dx.size() != 0)) {
      f4 = ((SVG.n)dx.get(0)).floatValueX(this);
    } else {
      f4 = 0.0F;
    }
    float f5 = f2;
    if (dy != null) {
      if (dy.size() == 0) {
        f5 = f2;
      } else {
        f5 = ((SVG.n)dy.get(0)).floatValueY(this);
      }
    }
    localObject = getAnchorPosition();
    f2 = f1;
    if (localObject != SVG.Style.TextAnchor.Start)
    {
      f2 = calculateTextWidth(paramAt);
      if (localObject == SVG.Style.TextAnchor.Middle) {
        f2 = f1 - f2 / 2.0F;
      } else {
        f2 = f1 - f2;
      }
    }
    if (boundingBox == null)
    {
      localObject = new TextBoundsCalculator(f2, f3);
      enumerateTextSpans(paramAt, (TextProcessor)localObject);
      boundingBox = new SVG.a(bbox.left, bbox.top, bbox.width(), bbox.height());
    }
    updateParentBoundingBox(paramAt);
    checkForGradiantsAndPatterns(paramAt);
    checkForClipPath(paramAt);
    boolean bool = pushLayer();
    enumerateTextSpans(paramAt, new PlainTextDrawer(f2 + f4, f3 + f5));
    if (bool) {
      popLayer(paramAt);
    }
  }
  
  private void render(SVG.ba paramBa)
  {
    debug("Use render", new Object[0]);
    if ((width == null) || (!width.isZero()))
    {
      if ((height != null) && (height.isZero())) {
        return;
      }
      updateStyleForElement(state, paramBa);
      if (!display()) {
        return;
      }
      SVG.ak localAk = document.resolveIRI(href);
      if (localAk == null)
      {
        error("Use reference '%s' not found", new Object[] { href });
        return;
      }
      if (transform != null) {
        canvas.concat(transform);
      }
      Object localObject1 = x;
      float f2 = 0.0F;
      float f1;
      if (localObject1 != null) {
        f1 = x.floatValueX(this);
      } else {
        f1 = 0.0F;
      }
      if (y != null) {
        f2 = y.floatValueY(this);
      }
      canvas.translate(f1, f2);
      checkForClipPath(paramBa);
      boolean bool = pushLayer();
      parentPush(paramBa);
      Object localObject2;
      if ((localAk instanceof SVG.ac))
      {
        localObject1 = (SVG.ac)localAk;
        localObject2 = render(null, null, width, height);
        statePush();
        render((SVG.ac)localObject1, (SVG.a)localObject2);
        statePop();
      }
      else if ((localAk instanceof SVG.aq))
      {
        if (width != null) {
          localObject1 = width;
        } else {
          localObject1 = new SVG.n(100.0F, SVG.Unit.percent);
        }
        if (height != null) {
          localObject2 = height;
        } else {
          localObject2 = new SVG.n(100.0F, SVG.Unit.percent);
        }
        localObject1 = render(null, null, (SVG.n)localObject1, (SVG.n)localObject2);
        statePush();
        render((SVG.aq)localAk, (SVG.a)localObject1);
        statePop();
      }
      else
      {
        render(localAk);
      }
      parentPop();
      if (bool) {
        popLayer(paramBa);
      }
      updateParentBoundingBox(paramBa);
    }
  }
  
  private void render(SVG.c paramC)
  {
    debug("Circle render", new Object[0]);
    if (r != null)
    {
      if (r.isZero()) {
        return;
      }
      updateStyleForElement(state, paramC);
      if (!display()) {
        return;
      }
      if (!visible()) {
        return;
      }
      if (transform != null) {
        canvas.concat(transform);
      }
      Path localPath = makePathAndBoundingBox(paramC);
      updateParentBoundingBox(paramC);
      checkForGradiantsAndPatterns(paramC);
      checkForClipPath(paramC);
      boolean bool = pushLayer();
      if (state.hasFill) {
        doFilledPath(paramC, localPath);
      }
      if (state.hasStroke) {
        doStroke(localPath);
      }
      if (bool) {
        popLayer(paramC);
      }
    }
  }
  
  private void render(SVG.h paramH)
  {
    debug("Ellipse render", new Object[0]);
    if ((rx != null) && (ry != null) && (!rx.isZero()))
    {
      if (ry.isZero()) {
        return;
      }
      updateStyleForElement(state, paramH);
      if (!display()) {
        return;
      }
      if (!visible()) {
        return;
      }
      if (transform != null) {
        canvas.concat(transform);
      }
      Path localPath = makePathAndBoundingBox(paramH);
      updateParentBoundingBox(paramH);
      checkForGradiantsAndPatterns(paramH);
      checkForClipPath(paramH);
      boolean bool = pushLayer();
      if (state.hasFill) {
        doFilledPath(paramH, localPath);
      }
      if (state.hasStroke) {
        doStroke(localPath);
      }
      if (bool) {
        popLayer(paramH);
      }
    }
  }
  
  private void render(SVG.k paramK)
  {
    debug("Group render", new Object[0]);
    updateStyleForElement(state, paramK);
    if (!display()) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    checkForClipPath(paramK);
    boolean bool = pushLayer();
    renderChildren(paramK, true);
    if (bool) {
      popLayer(paramK);
    }
    updateParentBoundingBox(paramK);
  }
  
  private void render(SVG.m paramM)
  {
    int i = 0;
    debug("Image render", new Object[0]);
    if ((width != null) && (!width.isZero()) && (height != null))
    {
      if (height.isZero()) {
        return;
      }
      if (href == null) {
        return;
      }
      if (preserveAspectRatio != null) {
        localObject1 = preserveAspectRatio;
      } else {
        localObject1 = PreserveAspectRatio.preserveAspectRatio;
      }
      Object localObject3 = checkForImageDataURL(href);
      Object localObject2 = localObject3;
      if (localObject3 == null)
      {
        localObject2 = SVG.getFileResolver();
        if (localObject2 == null) {
          return;
        }
        localObject2 = ((SVGExternalFileResolver)localObject2).resolveImage(href);
      }
      if (localObject2 == null)
      {
        error("Could not locate image '%s'", new Object[] { href });
        return;
      }
      localObject3 = new SVG.a(0.0F, 0.0F, ((Bitmap)localObject2).getWidth(), ((Bitmap)localObject2).getHeight());
      updateStyleForElement(state, paramM);
      if (!display()) {
        return;
      }
      if (!visible()) {
        return;
      }
      if (transform != null) {
        canvas.concat(transform);
      }
      float f1;
      if (x != null) {
        f1 = x.floatValueX(this);
      } else {
        f1 = 0.0F;
      }
      float f2;
      if (y != null) {
        f2 = y.floatValueY(this);
      } else {
        f2 = 0.0F;
      }
      float f3 = width.floatValueX(this);
      float f4 = height.floatValueX(this);
      state.viewPort = new SVG.a(f1, f2, f3, f4);
      if (!state.style.overflow.booleanValue()) {
        setClipRect(state.viewPort.minX, state.viewPort.minY, state.viewPort.width, state.viewPort.height);
      }
      boundingBox = state.viewPort;
      updateParentBoundingBox(paramM);
      checkForClipPath(paramM);
      boolean bool = pushLayer();
      viewportFill();
      canvas.save();
      canvas.concat(calculateViewBoxTransform(state.viewPort, (SVG.a)localObject3, (PreserveAspectRatio)localObject1));
      if (state.style.style != SVG.Style.RenderQuality.optimizeSpeed) {
        i = 2;
      }
      Object localObject1 = new Paint(i);
      canvas.drawBitmap((Bitmap)localObject2, 0.0F, 0.0F, (Paint)localObject1);
      canvas.restore();
      if (bool) {
        popLayer(paramM);
      }
    }
  }
  
  private void render(SVG.o paramO)
  {
    debug("Line render", new Object[0]);
    updateStyleForElement(state, paramO);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if (!state.hasStroke) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    Path localPath = makePathAndBoundingBox(paramO);
    updateParentBoundingBox(paramO);
    checkForGradiantsAndPatterns(paramO);
    checkForClipPath(paramO);
    boolean bool = pushLayer();
    doStroke(localPath);
    renderMarkers(paramO);
    if (bool) {
      popLayer(paramO);
    }
  }
  
  private void render(SVG.t paramT)
  {
    debug("Path render", new Object[0]);
    if (d == null) {
      return;
    }
    updateStyleForElement(state, paramT);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if ((!state.hasStroke) && (!state.hasFill)) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    Path localPath = new Item(this, d).getPath();
    if (boundingBox == null) {
      boundingBox = calculatePathBounds(localPath);
    }
    updateParentBoundingBox(paramT);
    checkForGradiantsAndPatterns(paramT);
    checkForClipPath(paramT);
    boolean bool = pushLayer();
    if (state.hasFill)
    {
      localPath.setFillType(getFillTypeFromState());
      doFilledPath(paramT, localPath);
    }
    if (state.hasStroke) {
      doStroke(localPath);
    }
    renderMarkers(paramT);
    if (bool) {
      popLayer(paramT);
    }
  }
  
  private void render(SVG.x paramX)
  {
    debug("PolyLine render", new Object[0]);
    updateStyleForElement(state, paramX);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if ((!state.hasStroke) && (!state.hasFill)) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    if (points.length < 2) {
      return;
    }
    Path localPath = makePathAndBoundingBox(paramX);
    updateParentBoundingBox(paramX);
    localPath.setFillType(getFillTypeFromState());
    checkForGradiantsAndPatterns(paramX);
    checkForClipPath(paramX);
    boolean bool = pushLayer();
    if (state.hasFill) {
      doFilledPath(paramX, localPath);
    }
    if (state.hasStroke) {
      doStroke(localPath);
    }
    renderMarkers(paramX);
    if (bool) {
      popLayer(paramX);
    }
  }
  
  private void render(SVG.y paramY)
  {
    debug("Polygon render", new Object[0]);
    updateStyleForElement(state, paramY);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    if ((!state.hasStroke) && (!state.hasFill)) {
      return;
    }
    if (transform != null) {
      canvas.concat(transform);
    }
    if (points.length < 2) {
      return;
    }
    Path localPath = makePathAndBoundingBox(paramY);
    updateParentBoundingBox(paramY);
    checkForGradiantsAndPatterns(paramY);
    checkForClipPath(paramY);
    boolean bool = pushLayer();
    if (state.hasFill) {
      doFilledPath(paramY, localPath);
    }
    if (state.hasStroke) {
      doStroke(localPath);
    }
    renderMarkers(paramY);
    if (bool) {
      popLayer(paramY);
    }
  }
  
  private void render(SVG.z paramZ)
  {
    debug("Rect render", new Object[0]);
    if ((width != null) && (height != null) && (!width.isZero()))
    {
      if (height.isZero()) {
        return;
      }
      updateStyleForElement(state, paramZ);
      if (!display()) {
        return;
      }
      if (!visible()) {
        return;
      }
      if (transform != null) {
        canvas.concat(transform);
      }
      Path localPath = makePathAndBoundingBox(paramZ);
      updateParentBoundingBox(paramZ);
      checkForGradiantsAndPatterns(paramZ);
      checkForClipPath(paramZ);
      boolean bool = pushLayer();
      if (state.hasFill) {
        doFilledPath(paramZ, localPath);
      }
      if (state.hasStroke) {
        doStroke(localPath);
      }
      if (bool) {
        popLayer(paramZ);
      }
    }
  }
  
  private void renderChildren(SVG.ag paramAg, boolean paramBoolean)
  {
    if (paramBoolean) {
      parentPush(paramAg);
    }
    paramAg = paramAg.listFiles().iterator();
    while (paramAg.hasNext()) {
      render((SVG.ak)paramAg.next());
    }
    if (paramBoolean) {
      parentPop();
    }
  }
  
  private void renderMarker(SVG.p paramP, h paramH)
  {
    statePush();
    Object localObject = orient;
    float f8 = 0.0F;
    if (localObject != null) {
      if (Float.isNaN(orient.floatValue()))
      {
        if ((n != 0.0F) || (r != 0.0F))
        {
          f1 = (float)Math.toDegrees(Math.atan2(r, n));
          break label83;
        }
      }
      else
      {
        f1 = orient.floatValue();
        break label83;
      }
    }
    float f1 = 0.0F;
    label83:
    float f2;
    if (overflow) {
      f2 = 1.0F;
    } else {
      f2 = state.style.strokeWidth.floatValue(dpi);
    }
    state = findInheritFromAncestorState(paramP);
    localObject = new Matrix();
    ((Matrix)localObject).preTranslate(x, y);
    ((Matrix)localObject).preRotate(f1);
    ((Matrix)localObject).preScale(f2, f2);
    if (refX != null) {
      f2 = refX.floatValueX(this);
    } else {
      f2 = 0.0F;
    }
    float f7;
    if (refY != null) {
      f7 = refY.floatValueY(this);
    } else {
      f7 = 0.0F;
    }
    paramH = markerWidth;
    float f4 = 3.0F;
    float f3;
    if (paramH != null) {
      f3 = markerWidth.floatValueX(this);
    } else {
      f3 = 3.0F;
    }
    if (markerHeight != null) {
      f4 = markerHeight.floatValueY(this);
    }
    if (viewBox != null)
    {
      f1 = f3 / viewBox.width;
      float f9 = f4 / viewBox.height;
      if (preserveAspectRatio != null) {
        paramH = preserveAspectRatio;
      } else {
        paramH = PreserveAspectRatio.preserveAspectRatio;
      }
      float f6 = f1;
      float f5 = f9;
      if (!paramH.equals(PreserveAspectRatio.STRETCH))
      {
        if (paramH.getScale() == PreserveAspectRatio.Scale.slice) {
          f1 = Math.max(f1, f9);
        } else {
          f1 = Math.min(f1, f9);
        }
        f5 = f1;
        f6 = f1;
      }
      ((Matrix)localObject).preTranslate(-f2 * f6, -f7 * f5);
      canvas.concat((Matrix)localObject);
      f1 = viewBox.width * f6;
      f2 = viewBox.height * f5;
      switch (Format.height[paramH.getAlignment().ordinal()])
      {
      default: 
        f1 = 0.0F;
        break;
      case 4: 
      case 5: 
      case 6: 
        f1 = 0.0F - (f3 - f1);
        break;
      case 1: 
      case 2: 
      case 3: 
        f1 = 0.0F - (f3 - f1) / 2.0F;
      }
      switch (Format.height[paramH.getAlignment().ordinal()])
      {
      default: 
        break;
      case 4: 
        f2 = f8;
        break;
      case 3: 
      case 6: 
      case 8: 
        f2 = 0.0F - (f4 - f2);
        break;
      }
      f2 = 0.0F - (f4 - f2) / 2.0F;
      if (!state.style.overflow.booleanValue()) {
        setClipRect(f1, f2, f3, f4);
      }
      ((Matrix)localObject).reset();
      ((Matrix)localObject).preScale(f6, f5);
      canvas.concat((Matrix)localObject);
    }
    else
    {
      ((Matrix)localObject).preTranslate(-f2, -f7);
      canvas.concat((Matrix)localObject);
      if (!state.style.overflow.booleanValue()) {
        setClipRect(0.0F, 0.0F, f3, f4);
      }
    }
    boolean bool = pushLayer();
    renderChildren(paramP, false);
    if (bool) {
      popLayer(paramP);
    }
    statePop();
  }
  
  private void renderMarkers(SVG.j paramJ)
  {
    if ((state.style.markerStart == null) && (state.style.markerMid == null) && (state.style.markerEnd == null)) {
      return;
    }
    Object localObject1;
    if (state.style.markerStart != null)
    {
      localObject1 = document.resolveIRI(state.style.markerStart);
      if (localObject1 != null) {
        localObject1 = (SVG.p)localObject1;
      } else {
        error("Marker reference '%s' not found", new Object[] { state.style.markerStart });
      }
    }
    else
    {
      localObject1 = null;
    }
    SVG.p localP1;
    if (state.style.markerMid != null)
    {
      localObject2 = document.resolveIRI(state.style.markerMid);
      if (localObject2 != null) {
        localP1 = (SVG.p)localObject2;
      } else {
        error("Marker reference '%s' not found", new Object[] { state.style.markerMid });
      }
    }
    else
    {
      localP1 = null;
    }
    SVG.p localP2;
    if (state.style.markerEnd != null)
    {
      localObject2 = document.resolveIRI(state.style.markerEnd);
      if (localObject2 != null) {
        localP2 = (SVG.p)localObject2;
      } else {
        error("Marker reference '%s' not found", new Object[] { state.style.markerEnd });
      }
    }
    else
    {
      localP2 = null;
    }
    if ((paramJ instanceof SVG.t)) {
      paramJ = new ClassWriter(this, d).get();
    } else if ((paramJ instanceof SVG.o)) {
      paramJ = calculateMarkerPositions((SVG.o)paramJ);
    } else {
      paramJ = calculateMarkerPositions((SVG.x)paramJ);
    }
    if (paramJ == null) {
      return;
    }
    int j = paramJ.size();
    if (j == 0) {
      return;
    }
    Object localObject2 = state.style;
    Object localObject3 = state.style;
    state.style.markerEnd = null;
    markerMid = null;
    markerStart = null;
    if (localObject1 != null) {
      renderMarker((SVG.p)localObject1, (h)paramJ.get(0));
    }
    if ((localP1 != null) && (paramJ.size() > 2))
    {
      localObject2 = (h)paramJ.get(0);
      localObject1 = (h)paramJ.get(1);
      int i = 1;
      while (i < j - 1)
      {
        i += 1;
        localObject3 = (h)paramJ.get(i);
        if (m) {
          localObject2 = a((h)localObject2, (h)localObject1, (h)localObject3);
        } else {
          localObject2 = localObject1;
        }
        renderMarker(localP1, (h)localObject2);
        localObject1 = localObject3;
      }
    }
    if (localP2 != null) {
      renderMarker(localP2, (h)paramJ.get(j - 1));
    }
  }
  
  private void renderMask(SVG.q paramQ, SVG.ah paramAh, SVG.a paramA)
  {
    debug("Mask render", new Object[0]);
    Object localObject = maskUnitsAreUser;
    int j = 1;
    int i;
    if ((localObject != null) && (maskUnitsAreUser.booleanValue())) {
      i = 1;
    } else {
      i = 0;
    }
    float f1;
    float f3;
    float f2;
    if (i != 0)
    {
      if (width != null) {
        f1 = width.floatValueX(this);
      } else {
        f1 = width;
      }
      if (height != null)
      {
        f3 = height.floatValueY(this);
        f2 = f1;
        f1 = f3;
      }
      else
      {
        f3 = height;
        f2 = f1;
        f1 = f3;
      }
    }
    else
    {
      localObject = width;
      f2 = 1.2F;
      if (localObject != null) {
        f1 = width.floatValue(this, 1.0F);
      } else {
        f1 = 1.2F;
      }
      if (height != null) {
        f2 = height.floatValue(this, 1.0F);
      }
      f3 = f1 * width;
      f1 = f2 * height;
      f2 = f3;
    }
    if (f2 != 0.0F)
    {
      if (f1 == 0.0F) {
        return;
      }
      statePush();
      state = findInheritFromAncestorState(paramQ);
      state.style.opacity = Float.valueOf(1.0F);
      boolean bool = pushLayer();
      canvas.save();
      i = j;
      if (maskContentUnitsAreUser != null) {
        if (maskContentUnitsAreUser.booleanValue()) {
          i = j;
        } else {
          i = 0;
        }
      }
      if (i == 0)
      {
        canvas.translate(minX, minY);
        canvas.scale(width, height);
      }
      renderChildren(paramQ, false);
      canvas.restore();
      if (bool) {
        transform(paramAh, paramA);
      }
      statePop();
    }
  }
  
  private void renderSwitchChild(SVG.ap paramAp)
  {
    String str = Locale.getDefault().getLanguage();
    SVGExternalFileResolver localSVGExternalFileResolver = SVG.getFileResolver();
    paramAp = paramAp.listFiles().iterator();
    while (paramAp.hasNext())
    {
      SVG.ak localAk = (SVG.ak)paramAp.next();
      if ((localAk instanceof SVG.ad))
      {
        Object localObject1 = (SVG.ad)localAk;
        if (((SVG.ad)localObject1).next() == null)
        {
          Object localObject2 = ((SVG.ad)localObject1).getSystemLanguage();
          if ((localObject2 == null) || ((!((Set)localObject2).isEmpty()) && (((Set)localObject2).contains(str))))
          {
            localObject2 = ((SVG.ad)localObject1).entries();
            if (localObject2 != null)
            {
              if (supportedFeatures == null) {
                initialiseSupportedFeaturesMap();
              }
              if ((((Set)localObject2).isEmpty()) || (!supportedFeatures.containsAll((Collection)localObject2))) {
                break;
              }
            }
            else
            {
              localObject2 = ((SVG.ad)localObject1).getRequiredFormats();
              if (localObject2 != null)
              {
                if ((!((Set)localObject2).isEmpty()) && (localSVGExternalFileResolver != null))
                {
                  localObject2 = ((Set)localObject2).iterator();
                  for (;;)
                  {
                    if (((Iterator)localObject2).hasNext()) {
                      if (!localSVGExternalFileResolver.isFormatSupported((String)((Iterator)localObject2).next())) {
                        break;
                      }
                    }
                  }
                }
              }
              else
              {
                localObject1 = ((SVG.ad)localObject1).getRequiredFeatures();
                if (localObject1 != null)
                {
                  if ((!((Set)localObject1).isEmpty()) && (localSVGExternalFileResolver != null))
                  {
                    localObject1 = ((Set)localObject1).iterator();
                    for (;;)
                    {
                      if (((Iterator)localObject1).hasNext()) {
                        if (localSVGExternalFileResolver.resolveFont((String)((Iterator)localObject1).next(), state.style.fontWeight.intValue(), String.valueOf(state.style.fontStyle)) == null) {
                          break;
                        }
                      }
                    }
                  }
                }
                else {
                  render(localAk);
                }
              }
            }
          }
        }
      }
    }
  }
  
  private void renderTextPath(SVG.aw paramAw)
  {
    debug("TextPath render", new Object[0]);
    updateStyleForElement(state, paramAw);
    if (!display()) {
      return;
    }
    if (!visible()) {
      return;
    }
    Object localObject1 = document.resolveIRI(href);
    if (localObject1 == null)
    {
      error("TextPath reference '%s' not found", new Object[] { href });
      return;
    }
    Object localObject2 = (SVG.t)localObject1;
    localObject1 = new Item(this, d).getPath();
    if (transform != null) {
      ((Path)localObject1).transform(transform);
    }
    localObject2 = new PathMeasure((Path)localObject1, false);
    float f1;
    if (x != null) {
      f1 = x.floatValue(this, ((PathMeasure)localObject2).getLength());
    } else {
      f1 = 0.0F;
    }
    localObject2 = getAnchorPosition();
    float f2 = f1;
    if (localObject2 != SVG.Style.TextAnchor.Start)
    {
      f2 = calculateTextWidth(paramAw);
      if (localObject2 == SVG.Style.TextAnchor.Middle) {
        f2 = f1 - f2 / 2.0F;
      } else {
        f2 = f1 - f2;
      }
    }
    checkForGradiantsAndPatterns((SVG.ah)paramAw.n());
    boolean bool = pushLayer();
    enumerateTextSpans(paramAw, new PathTextDrawer((Path)localObject1, f2, 0.0F));
    if (bool) {
      popLayer(paramAw);
    }
  }
  
  private boolean requiresCompositing()
  {
    return (state.style.opacity.floatValue() < 1.0F) || (state.style.mask != null);
  }
  
  private void resetState()
  {
    state = new RendererState();
    stateStack = new Stack();
    updateStyle(state, SVG.Style.getDefaultStyle());
    RendererState localRendererState = state;
    viewPort = null;
    spacePreserve = false;
    stateStack.push(new RendererState(localRendererState));
    matrixStack = new Stack();
    parentStack = new Stack();
  }
  
  private void setClipRect(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    float f3 = paramFloat3 + paramFloat1;
    float f4 = paramFloat4 + paramFloat2;
    float f2 = paramFloat1;
    float f1 = paramFloat2;
    paramFloat4 = f3;
    paramFloat3 = f4;
    if (state.style.clip != null)
    {
      f2 = paramFloat1 + state.style.clip.left.floatValueX(this);
      f1 = paramFloat2 + state.style.clip.canvas.floatValueY(this);
      paramFloat4 = f3 - state.style.clip.x.floatValueX(this);
      paramFloat3 = f4 - state.style.clip.bottom.floatValueY(this);
    }
    canvas.clipRect(f2, f1, paramFloat4, paramFloat3);
  }
  
  private void setPaintColour(RendererState paramRendererState, boolean paramBoolean, SVG.al paramAl)
  {
    Float localFloat;
    if (paramBoolean) {
      localFloat = style.fillOpacity;
    } else {
      localFloat = style.strokeOpacity;
    }
    float f = localFloat.floatValue();
    if ((paramAl instanceof SVG.e))
    {
      i = style;
    }
    else
    {
      if (!(paramAl instanceof SVG.f)) {
        return;
      }
      i = style.color.style;
    }
    int i = clamp255(i, f);
    if (paramBoolean)
    {
      fillPaint.setColor(i);
      return;
    }
    strokePaint.setColor(i);
  }
  
  private void setSolidColor(boolean paramBoolean, SVG.aa paramAa)
  {
    boolean bool2 = true;
    boolean bool1 = true;
    RendererState localRendererState;
    if (paramBoolean)
    {
      if (isSpecified(baseStyle, 2147483648L))
      {
        state.style.fill = baseStyle.solidColor;
        localRendererState = state;
        if (baseStyle.solidColor == null) {
          bool1 = false;
        }
        hasFill = bool1;
      }
      if (isSpecified(baseStyle, 4294967296L)) {
        state.style.fillOpacity = baseStyle.solidOpacity;
      }
      if (isSpecified(baseStyle, 6442450944L))
      {
        paramAa = state;
        setPaintColour(paramAa, paramBoolean, style.fill);
      }
    }
    else
    {
      if (isSpecified(baseStyle, 2147483648L))
      {
        state.style.stroke = baseStyle.solidColor;
        localRendererState = state;
        if (baseStyle.solidColor != null) {
          bool1 = bool2;
        } else {
          bool1 = false;
        }
        hasStroke = bool1;
      }
      if (isSpecified(baseStyle, 4294967296L)) {
        state.style.strokeOpacity = baseStyle.solidOpacity;
      }
      if (isSpecified(baseStyle, 6442450944L))
      {
        paramAa = state;
        setPaintColour(paramAa, paramBoolean, style.stroke);
      }
    }
  }
  
  private void statePop()
  {
    canvas.restore();
    state = ((RendererState)stateStack.pop());
  }
  
  private void statePush()
  {
    canvas.save();
    stateStack.push(state);
    state = new RendererState(state);
  }
  
  private String textXMLSpaceTransform(String paramString, boolean paramBoolean1, boolean paramBoolean2)
  {
    if (state.spacePreserve) {
      return paramString.replaceAll("[\\n\\t]", " ");
    }
    String str = paramString.replaceAll("\\n", "").replaceAll("\\t", " ");
    paramString = str;
    if (paramBoolean1) {
      paramString = str.replaceAll("^\\s+", "");
    }
    str = paramString;
    if (paramBoolean2) {
      str = paramString.replaceAll("\\s+$", "");
    }
    return str.replaceAll("\\s{2,}", " ");
  }
  
  private void transform(SVG.ah paramAh, SVG.a paramA)
  {
    if (state.style.mask != null)
    {
      Object localObject = new Paint();
      ((Paint)localObject).setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
      canvas.saveLayer(null, (Paint)localObject, 31);
      localObject = new Paint();
      ((Paint)localObject).setColorFilter(new ColorMatrixColorFilter(new ColorMatrix(new float[] { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.2127F, 0.7151F, 0.0722F, 0.0F, 0.0F })));
      canvas.saveLayer(null, (Paint)localObject, 31);
      localObject = (SVG.q)document.resolveIRI(state.style.mask);
      renderMask((SVG.q)localObject, paramAh, paramA);
      canvas.restore();
      Paint localPaint = new Paint();
      localPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
      canvas.saveLayer(null, localPaint, 31);
      renderMask((SVG.q)localObject, paramAh, paramA);
      canvas.restore();
      canvas.restore();
    }
    statePop();
  }
  
  private void updateParentBoundingBox(SVG.ah paramAh)
  {
    if (parent == null) {
      return;
    }
    if (boundingBox == null) {
      return;
    }
    Matrix localMatrix = new Matrix();
    if (((Matrix)matrixStack.peek()).invert(localMatrix))
    {
      Object localObject = new float[8];
      localObject[0] = boundingBox.minX;
      localObject[1] = boundingBox.minY;
      float f = boundingBox.maxX();
      int i = 2;
      localObject[2] = f;
      localObject[3] = boundingBox.minY;
      localObject[4] = boundingBox.maxX();
      localObject[5] = boundingBox.maxY();
      localObject[6] = boundingBox.minX;
      localObject[7] = boundingBox.maxY();
      localMatrix.preConcat(canvas.getMatrix());
      localMatrix.mapPoints((float[])localObject);
      paramAh = new RectF(localObject[0], localObject[1], localObject[0], localObject[1]);
      while (i <= 6)
      {
        if (localObject[i] < left) {
          left = localObject[i];
        }
        if (localObject[i] > right) {
          right = localObject[i];
        }
        int j = i + 1;
        if (localObject[j] < top) {
          top = localObject[j];
        }
        if (localObject[j] > bottom) {
          bottom = localObject[j];
        }
        i += 2;
      }
      localObject = (SVG.ah)parentStack.peek();
      if (boundingBox == null)
      {
        boundingBox = SVG.a.fromLimits(left, top, right, bottom);
        return;
      }
      boundingBox.union(SVG.a.fromLimits(left, top, right, bottom));
    }
  }
  
  private void updateStyle(RendererState paramRendererState, SVG.Style paramStyle)
  {
    if (isSpecified(paramStyle, 4096L)) {
      style.color = color;
    }
    if (isSpecified(paramStyle, 2048L)) {
      style.opacity = opacity;
    }
    boolean bool1 = isSpecified(paramStyle, 1L);
    boolean bool2 = false;
    if (bool1)
    {
      style.fill = fill;
      if ((fill != null) && (fill != SVG.e.fontSize)) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      hasFill = bool1;
    }
    if (isSpecified(paramStyle, 4L)) {
      style.fillOpacity = fillOpacity;
    }
    if (isSpecified(paramStyle, 6149L)) {
      setPaintColour(paramRendererState, true, style.fill);
    }
    if (isSpecified(paramStyle, 2L)) {
      style.fillRule = fillRule;
    }
    if (isSpecified(paramStyle, 8L))
    {
      style.stroke = stroke;
      if ((stroke != null) && (stroke != SVG.e.fontSize)) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      hasStroke = bool1;
    }
    if (isSpecified(paramStyle, 16L)) {
      style.strokeOpacity = strokeOpacity;
    }
    if (isSpecified(paramStyle, 6168L)) {
      setPaintColour(paramRendererState, false, style.stroke);
    }
    if (isSpecified(paramStyle, 34359738368L)) {
      style.vectorEffect = vectorEffect;
    }
    if (isSpecified(paramStyle, 32L))
    {
      style.strokeWidth = strokeWidth;
      strokePaint.setStrokeWidth(style.strokeWidth.floatValue(this));
    }
    if (isSpecified(paramStyle, 64L))
    {
      style.strokeLineCap = strokeLineCap;
      switch (Format.width[strokeLineCap.ordinal()])
      {
      default: 
        break;
      case 3: 
        strokePaint.setStrokeCap(Paint.Cap.SQUARE);
        break;
      case 2: 
        strokePaint.setStrokeCap(Paint.Cap.ROUND);
        break;
      case 1: 
        strokePaint.setStrokeCap(Paint.Cap.BUTT);
      }
    }
    if (isSpecified(paramStyle, 128L))
    {
      style.strokeLineJoin = strokeLineJoin;
      switch (Format.style[strokeLineJoin.ordinal()])
      {
      default: 
        break;
      case 3: 
        strokePaint.setStrokeJoin(Paint.Join.BEVEL);
        break;
      case 2: 
        strokePaint.setStrokeJoin(Paint.Join.ROUND);
        break;
      case 1: 
        strokePaint.setStrokeJoin(Paint.Join.MITER);
      }
    }
    if (isSpecified(paramStyle, 256L))
    {
      style.strokeMiterLimit = strokeMiterLimit;
      strokePaint.setStrokeMiter(strokeMiterLimit.floatValue());
    }
    if (isSpecified(paramStyle, 512L)) {
      style.strokeDashArray = strokeDashArray;
    }
    if (isSpecified(paramStyle, 1024L)) {
      style.strokeDashOffset = strokeDashOffset;
    }
    bool1 = isSpecified(paramStyle, 1536L);
    SVGExternalFileResolver localSVGExternalFileResolver = null;
    Object localObject2 = null;
    Object localObject1;
    float f1;
    if (bool1) {
      if (style.strokeDashArray == null)
      {
        strokePaint.setPathEffect(null);
      }
      else
      {
        int k = style.strokeDashArray.length;
        int i;
        if (k % 2 == 0) {
          i = k;
        } else {
          i = k * 2;
        }
        localObject1 = new float[i];
        int j = 0;
        f1 = 0.0F;
        while (j < i)
        {
          localObject1[j] = style.strokeDashArray[(j % k)].floatValue(this);
          f1 += localObject1[j];
          j += 1;
        }
        if (f1 == 0.0F)
        {
          strokePaint.setPathEffect(null);
        }
        else
        {
          float f3 = style.strokeDashOffset.floatValue(this);
          float f2 = f3;
          if (f3 < 0.0F) {
            f2 = f3 % f1 + f1;
          }
          strokePaint.setPathEffect(new DashPathEffect((float[])localObject1, f2));
        }
      }
    }
    if (isSpecified(paramStyle, 16384L))
    {
      f1 = getCurrentFontSize();
      style.fontSize = fontSize;
      fillPaint.setTextSize(fontSize.floatValue(this, f1));
      strokePaint.setTextSize(fontSize.floatValue(this, f1));
    }
    if (isSpecified(paramStyle, 8192L)) {
      style.fontFamily = fontFamily;
    }
    if (isSpecified(paramStyle, 32768L)) {
      if ((fontWeight.intValue() == -1) && (style.fontWeight.intValue() > 100))
      {
        localObject1 = style;
        fontWeight = Integer.valueOf(fontWeight.intValue() - 100);
      }
      else if ((fontWeight.intValue() == 1) && (style.fontWeight.intValue() < 900))
      {
        localObject1 = style;
        fontWeight = Integer.valueOf(fontWeight.intValue() + 100);
      }
      else
      {
        style.fontWeight = fontWeight;
      }
    }
    if (isSpecified(paramStyle, 65536L)) {
      style.fontStyle = fontStyle;
    }
    if (isSpecified(paramStyle, 106496L))
    {
      localObject1 = localSVGExternalFileResolver;
      if (style.fontFamily != null)
      {
        localObject1 = localSVGExternalFileResolver;
        if (document != null)
        {
          localSVGExternalFileResolver = SVG.getFileResolver();
          Iterator localIterator = style.fontFamily.iterator();
          do
          {
            localObject1 = localObject2;
            if (!localIterator.hasNext()) {
              break;
            }
            String str = (String)localIterator.next();
            localObject2 = checkGenericFont(str, style.fontWeight, style.fontStyle);
            localObject1 = localObject2;
            if (localObject2 == null)
            {
              localObject1 = localObject2;
              if (localSVGExternalFileResolver != null) {
                localObject1 = localSVGExternalFileResolver.resolveFont(str, style.fontWeight.intValue(), String.valueOf(style.fontStyle));
              }
            }
            localObject2 = localObject1;
          } while (localObject1 == null);
        }
      }
      localObject2 = localObject1;
      if (localObject1 == null) {
        localObject2 = checkGenericFont("serif", style.fontWeight, style.fontStyle);
      }
      fillPaint.setTypeface((Typeface)localObject2);
      strokePaint.setTypeface((Typeface)localObject2);
    }
    if (isSpecified(paramStyle, 131072L))
    {
      style.textDecoration = textDecoration;
      localObject1 = fillPaint;
      if (textDecoration == SVG.Style.TextDecoration.LineThrough) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      ((Paint)localObject1).setStrikeThruText(bool1);
      localObject1 = fillPaint;
      if (textDecoration == SVG.Style.TextDecoration.Underline) {
        bool1 = true;
      } else {
        bool1 = false;
      }
      ((Paint)localObject1).setUnderlineText(bool1);
      if (Build.VERSION.SDK_INT >= 17)
      {
        localObject1 = strokePaint;
        if (textDecoration == SVG.Style.TextDecoration.LineThrough) {
          bool1 = true;
        } else {
          bool1 = false;
        }
        ((Paint)localObject1).setStrikeThruText(bool1);
        localObject1 = strokePaint;
        bool1 = bool2;
        if (textDecoration == SVG.Style.TextDecoration.Underline) {
          bool1 = true;
        }
        ((Paint)localObject1).setUnderlineText(bool1);
      }
    }
    if (isSpecified(paramStyle, 68719476736L)) {
      style.direction = direction;
    }
    if (isSpecified(paramStyle, 262144L)) {
      style.textAnchor = textAnchor;
    }
    if (isSpecified(paramStyle, 524288L)) {
      style.overflow = overflow;
    }
    if (isSpecified(paramStyle, 2097152L)) {
      style.markerStart = markerStart;
    }
    if (isSpecified(paramStyle, 4194304L)) {
      style.markerMid = markerMid;
    }
    if (isSpecified(paramStyle, 8388608L)) {
      style.markerEnd = markerEnd;
    }
    if (isSpecified(paramStyle, 16777216L)) {
      style.display = display;
    }
    if (isSpecified(paramStyle, 33554432L)) {
      style.visibility = visibility;
    }
    if (isSpecified(paramStyle, 1048576L)) {
      style.clip = clip;
    }
    if (isSpecified(paramStyle, 268435456L)) {
      style.clipPath = clipPath;
    }
    if (isSpecified(paramStyle, 536870912L)) {
      style.clipRule = clipRule;
    }
    if (isSpecified(paramStyle, 1073741824L)) {
      style.mask = mask;
    }
    if (isSpecified(paramStyle, 67108864L)) {
      style.stopColor = stopColor;
    }
    if (isSpecified(paramStyle, 134217728L)) {
      style.stopOpacity = stopOpacity;
    }
    if (isSpecified(paramStyle, 8589934592L)) {
      style.viewportFill = viewportFill;
    }
    if (isSpecified(paramStyle, 17179869184L)) {
      style.viewportFillOpacity = viewportFillOpacity;
    }
    if (isSpecified(paramStyle, 137438953472L)) {
      style.style = style;
    }
  }
  
  private void updateStyleForElement(RendererState paramRendererState, SVG.ai paramAi)
  {
    boolean bool;
    if (parent == null) {
      bool = true;
    } else {
      bool = false;
    }
    style.resetNonInheritingProperties(bool);
    if (baseStyle != null) {
      updateStyle(paramRendererState, baseStyle);
    }
    if (document.hasCSSRules())
    {
      Iterator localIterator = document.getCSSRules().iterator();
      while (localIterator.hasNext())
      {
        CSSParser.k localK = (CSSParser.k)localIterator.next();
        if (CSSParser.add(x, b, paramAi)) {
          updateStyle(paramRendererState, style);
        }
      }
    }
    if (style != null) {
      updateStyle(paramRendererState, style);
    }
  }
  
  private void viewportFill()
  {
    int i;
    if ((state.style.viewportFill instanceof SVG.e))
    {
      i = state.style.viewportFill).style;
    }
    else
    {
      if (!(state.style.viewportFill instanceof SVG.f)) {
        return;
      }
      i = state.style.color.style;
    }
    int j = i;
    if (state.style.viewportFillOpacity != null) {
      j = clamp255(i, state.style.viewportFillOpacity.floatValue());
    }
    canvas.drawColor(j);
  }
  
  private boolean visible()
  {
    if (state.style.visibility != null) {
      return state.style.visibility.booleanValue();
    }
    return true;
  }
  
  private static void warn(String paramString, Object... paramVarArgs)
  {
    Log.w("SVGAndroidRenderer", String.format(paramString, paramVarArgs));
  }
  
  void a(SVG paramSVG, d paramD)
  {
    if (paramD != null)
    {
      document = paramSVG;
      SVG.ac localAc = paramSVG.split();
      if (localAc == null)
      {
        warn("Nothing to render. Document is empty.", new Object[0]);
        return;
      }
      Object localObject1;
      Object localObject2;
      if (paramD.a())
      {
        localObject1 = document.a(d);
        if ((localObject1 != null) && ((localObject1 instanceof SVG.bb)))
        {
          localObject2 = (SVG.bb)localObject1;
          if (viewBox == null)
          {
            Log.w("SVGAndroidRenderer", String.format("View element with id \"%s\" is missing a viewBox attribute.", new Object[] { d }));
            return;
          }
          localObject1 = viewBox;
          localObject2 = preserveAspectRatio;
        }
        else
        {
          Log.w("SVGAndroidRenderer", String.format("View element with id \"%s\" not found.", new Object[] { d }));
        }
      }
      else
      {
        if (paramD.b()) {
          localObject1 = b;
        } else {
          localObject1 = viewBox;
        }
        if (paramD.h()) {
          localObject2 = a;
        } else {
          localObject2 = preserveAspectRatio;
        }
      }
      if (paramD.c()) {
        paramSVG.setTitle(l);
      }
      if (paramD.f())
      {
        x = new CSSParser.l();
        x.y = paramSVG.a(c);
      }
      resetState();
      checkXMLSpaceAttribute(localAc);
      statePush();
      SVG.a localA = new SVG.a(j);
      if (width != null) {
        width = width.floatValue(this, width);
      }
      if (height != null) {
        height = height.floatValue(this, height);
      }
      render(localAc, localA, (SVG.a)localObject1, (PreserveAspectRatio)localObject2);
      statePop();
      if (paramD.c()) {
        paramSVG.f();
      }
    }
    else
    {
      throw new NullPointerException("renderOptions shouldn't be null");
    }
  }
  
  float getCurrentFontSize()
  {
    return state.fillPaint.getTextSize();
  }
  
  float getCurrentFontXHeight()
  {
    return state.fillPaint.getTextSize() / 2.0F;
  }
  
  SVG.a getCurrentViewPortInUserUnits()
  {
    if (state.viewBox != null) {
      return state.viewBox;
    }
    return state.viewPort;
  }
  
  float getDPI()
  {
    return dpi;
  }
  
  class PathTextDrawer
    extends SVGAndroidRenderer.PlainTextDrawer
  {
    private Path path;
    
    PathTextDrawer(Path paramPath, float paramFloat1, float paramFloat2)
    {
      super(paramFloat1, paramFloat2);
      path = paramPath;
    }
    
    public void processText(String paramString)
    {
      if (SVGAndroidRenderer.access$getVisible(SVGAndroidRenderer.this))
      {
        if (access$getStatehasFill) {
          SVGAndroidRenderer.access$getCanvas(SVGAndroidRenderer.this).drawTextOnPath(paramString, path, x, y, access$getStatefillPaint);
        }
        if (access$getStatehasStroke) {
          SVGAndroidRenderer.access$getCanvas(SVGAndroidRenderer.this).drawTextOnPath(paramString, path, x, y, access$getStatestrokePaint);
        }
      }
      x += access$getStatefillPaint.measureText(paramString);
    }
  }
  
  class PlainTextDrawer
    extends SVGAndroidRenderer.TextProcessor
  {
    float x;
    float y;
    
    PlainTextDrawer(float paramFloat1, float paramFloat2)
    {
      super(null);
      x = paramFloat1;
      y = paramFloat2;
    }
    
    public void processText(String paramString)
    {
      SVGAndroidRenderer.access$getDebug("TextSequence render", new Object[0]);
      if (SVGAndroidRenderer.access$getVisible(SVGAndroidRenderer.this))
      {
        if (access$getStatehasFill) {
          SVGAndroidRenderer.access$getCanvas(SVGAndroidRenderer.this).drawText(paramString, x, y, access$getStatefillPaint);
        }
        if (access$getStatehasStroke) {
          SVGAndroidRenderer.access$getCanvas(SVGAndroidRenderer.this).drawText(paramString, x, y, access$getStatestrokePaint);
        }
      }
      x += access$getStatefillPaint.measureText(paramString);
    }
  }
  
  class PlainTextToPath
    extends SVGAndroidRenderer.TextProcessor
  {
    Path textAsPath;
    float x;
    float y;
    
    PlainTextToPath(float paramFloat1, float paramFloat2, Path paramPath)
    {
      super(null);
      x = paramFloat1;
      y = paramFloat2;
      textAsPath = paramPath;
    }
    
    public boolean doTextContainer(SVG.av paramAv)
    {
      if ((paramAv instanceof SVG.aw))
      {
        SVGAndroidRenderer.access$getWarn("Using <textPath> elements in a clip path is not supported.", new Object[0]);
        return false;
      }
      return true;
    }
    
    public void processText(String paramString)
    {
      if (SVGAndroidRenderer.access$getVisible(SVGAndroidRenderer.this))
      {
        Path localPath = new Path();
        access$getStatefillPaint.getTextPath(paramString, 0, paramString.length(), x, y, localPath);
        textAsPath.addPath(localPath);
      }
      x += access$getStatefillPaint.measureText(paramString);
    }
  }
  
  class RendererState
  {
    Paint fillPaint;
    boolean hasFill;
    boolean hasStroke;
    boolean spacePreserve;
    Paint strokePaint;
    SVG.Style style;
    SVG.a viewBox;
    SVG.a viewPort;
    
    RendererState()
    {
      fillPaint = new Paint();
      fillPaint.setFlags(193);
      if (Build.VERSION.SDK_INT >= 14) {
        fillPaint.setHinting(0);
      }
      fillPaint.setStyle(Paint.Style.FILL);
      fillPaint.setTypeface(Typeface.DEFAULT);
      strokePaint = new Paint();
      strokePaint.setFlags(193);
      if (Build.VERSION.SDK_INT >= 14) {
        strokePaint.setHinting(0);
      }
      strokePaint.setStyle(Paint.Style.STROKE);
      strokePaint.setTypeface(Typeface.DEFAULT);
      style = SVG.Style.getDefaultStyle();
    }
    
    RendererState(RendererState paramRendererState)
    {
      hasFill = hasFill;
      hasStroke = hasStroke;
      fillPaint = new Paint(fillPaint);
      strokePaint = new Paint(strokePaint);
      this$1 = viewPort;
      if (SVGAndroidRenderer.this != null) {
        viewPort = new SVG.a(SVGAndroidRenderer.this);
      }
      this$1 = viewBox;
      if (SVGAndroidRenderer.this != null) {
        viewBox = new SVG.a(SVGAndroidRenderer.this);
      }
      spacePreserve = spacePreserve;
      this$1 = style;
      try
      {
        this$1 = clone();
        style = ((SVG.Style)SVGAndroidRenderer.this);
        return;
      }
      catch (CloneNotSupportedException this$1)
      {
        Log.e("SVGAndroidRenderer", "Unexpected clone error", SVGAndroidRenderer.this);
        style = SVG.Style.getDefaultStyle();
      }
    }
  }
  
  class TextBoundsCalculator
    extends SVGAndroidRenderer.TextProcessor
  {
    RectF bbox = new RectF();
    float x;
    float y;
    
    TextBoundsCalculator(float paramFloat1, float paramFloat2)
    {
      super(null);
      x = paramFloat1;
      y = paramFloat2;
    }
    
    public boolean doTextContainer(SVG.av paramAv)
    {
      if ((paramAv instanceof SVG.aw))
      {
        Object localObject = (SVG.aw)paramAv;
        paramAv = document.resolveIRI(href);
        if (paramAv == null)
        {
          SVGAndroidRenderer.access$getError("TextPath path reference '%s' not found", new Object[] { href });
          return false;
        }
        localObject = (SVG.t)paramAv;
        paramAv = new Item(SVGAndroidRenderer.this, d).getPath();
        if (transform != null) {
          paramAv.transform(transform);
        }
        localObject = new RectF();
        paramAv.computeBounds((RectF)localObject, true);
        bbox.union((RectF)localObject);
        return false;
      }
      return true;
    }
    
    public void processText(String paramString)
    {
      if (SVGAndroidRenderer.access$getVisible(SVGAndroidRenderer.this))
      {
        Object localObject = new Rect();
        access$getStatefillPaint.getTextBounds(paramString, 0, paramString.length(), (Rect)localObject);
        localObject = new RectF((Rect)localObject);
        ((RectF)localObject).offset(x, y);
        bbox.union((RectF)localObject);
      }
      x += access$getStatefillPaint.measureText(paramString);
    }
  }
  
  abstract class TextProcessor
  {
    private TextProcessor() {}
    
    public boolean doTextContainer(SVG.av paramAv)
    {
      return true;
    }
    
    public abstract void processText(String paramString);
  }
  
  class TextWidthCalculator
    extends SVGAndroidRenderer.TextProcessor
  {
    float x = 0.0F;
    
    private TextWidthCalculator()
    {
      super(null);
    }
    
    public void processText(String paramString)
    {
      x += access$getStatefillPaint.measureText(paramString);
    }
  }
}
