package com.caverock.androidsvg;

import android.graphics.Matrix;
import android.util.Log;
import android.util.Xml;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.zip.GZIPInputStream;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.DefaultHandler2;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

class SVGParser
{
  private SVG.ag currentElement = null;
  private int ignoreDepth;
  private boolean ignoring = false;
  private boolean inMetadataElement = false;
  private boolean inStyleElement = false;
  private StringBuilder metadataElementContents = null;
  private SVGElem metadataTag = null;
  private StringBuilder styleElementContents = null;
  private SVG svgDocument = null;
  
  SVGParser() {}
  
  private static float HueToRGB(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    float f = paramFloat3;
    if (paramFloat3 < 0.0F) {
      f = paramFloat3 + 6.0F;
    }
    paramFloat3 = f;
    if (f >= 6.0F) {
      paramFloat3 = f - 6.0F;
    }
    if (paramFloat3 < 1.0F) {
      return (paramFloat2 - paramFloat1) * paramFloat3 + paramFloat1;
    }
    if (paramFloat3 < 3.0F) {
      return paramFloat2;
    }
    f = paramFloat1;
    if (paramFloat3 < 4.0F) {
      f = (paramFloat2 - paramFloat1) * (4.0F - paramFloat3) + paramFloat1;
    }
    return f;
  }
  
  private static int a(float paramFloat1, float paramFloat2, float paramFloat3)
  {
    if (paramFloat1 >= 0.0F) {
      paramFloat1 %= 360.0F;
    } else {
      paramFloat1 = paramFloat1 % 360.0F + 360.0F;
    }
    float f1 = paramFloat1 / 60.0F;
    paramFloat2 /= 100.0F;
    paramFloat3 /= 100.0F;
    if (paramFloat2 < 0.0F)
    {
      paramFloat1 = 0.0F;
    }
    else
    {
      paramFloat1 = paramFloat2;
      if (paramFloat2 > 1.0F) {
        paramFloat1 = 1.0F;
      }
    }
    if (paramFloat3 < 0.0F)
    {
      paramFloat2 = 0.0F;
    }
    else
    {
      paramFloat2 = paramFloat3;
      if (paramFloat3 > 1.0F) {
        paramFloat2 = 1.0F;
      }
    }
    if (paramFloat2 <= 0.5F) {
      paramFloat1 = (paramFloat1 + 1.0F) * paramFloat2;
    } else {
      paramFloat1 = paramFloat2 + paramFloat1 - paramFloat1 * paramFloat2;
    }
    float f2 = paramFloat2 * 2.0F - paramFloat1;
    paramFloat2 = HueToRGB(f2, paramFloat1, f1 + 2.0F);
    paramFloat3 = HueToRGB(f2, paramFloat1, f1);
    paramFloat1 = HueToRGB(f2, paramFloat1, f1 - 2.0F);
    int i = clamp255(paramFloat2 * 256.0F);
    int j = clamp255(paramFloat3 * 256.0F);
    return clamp255(paramFloat1 * 256.0F) | i << 16 | j << 8;
  }
  
  private void characters(String paramString)
    throws SVGParseException
  {
    if (ignoring) {
      return;
    }
    if (inMetadataElement)
    {
      if (metadataElementContents == null) {
        metadataElementContents = new StringBuilder(paramString.length());
      }
      metadataElementContents.append(paramString);
      return;
    }
    if (inStyleElement)
    {
      if (styleElementContents == null) {
        styleElementContents = new StringBuilder(paramString.length());
      }
      styleElementContents.append(paramString);
      return;
    }
    if ((currentElement instanceof SVG.av)) {
      endElement(paramString);
    }
  }
  
  private void characters(char[] paramArrayOfChar, int paramInt1, int paramInt2)
    throws SVGParseException
  {
    if (ignoring) {
      return;
    }
    if (inMetadataElement)
    {
      if (metadataElementContents == null) {
        metadataElementContents = new StringBuilder(paramInt2);
      }
      metadataElementContents.append(paramArrayOfChar, paramInt1, paramInt2);
      return;
    }
    if (inStyleElement)
    {
      if (styleElementContents == null) {
        styleElementContents = new StringBuilder(paramInt2);
      }
      styleElementContents.append(paramArrayOfChar, paramInt1, paramInt2);
      return;
    }
    if ((currentElement instanceof SVG.av)) {
      endElement(new String(paramArrayOfChar, paramInt1, paramInt2));
    }
  }
  
  private void circle(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<circle>", new Object[0]);
    if (currentElement != null)
    {
      SVG.c localC = new SVG.c();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localC, paramAttributes);
      parseAttributesStyle(localC, paramAttributes);
      parseAttributesTransform(localC, paramAttributes);
      parseAttributesConditional(localC, paramAttributes);
      parseAttributesCircle(localC, paramAttributes);
      currentElement.addChild(localC);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private static int clamp255(float paramFloat)
  {
    if (paramFloat < 0.0F) {
      return 0;
    }
    if (paramFloat > 255.0F) {
      return 255;
    }
    return Math.round(paramFloat);
  }
  
  private void clear() {}
  
  private void clipPath(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<clipPath>", new Object[0]);
    if (currentElement != null)
    {
      SVG.d localD = new SVG.d();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localD, paramAttributes);
      parseAttributesStyle(localD, paramAttributes);
      parseAttributesTransform(localD, paramAttributes);
      parseAttributesConditional(localD, paramAttributes);
      parseAttributesClipPath(localD, paramAttributes);
      currentElement.addChild(localD);
      currentElement = localD;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void debug(String paramString, Object... paramVarArgs) {}
  
  private void defs(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<defs>", new Object[0]);
    if (currentElement != null)
    {
      SVG.g localG = new SVG.g();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localG, paramAttributes);
      parseAttributesStyle(localG, paramAttributes);
      parseAttributesTransform(localG, paramAttributes);
      currentElement.addChild(localG);
      currentElement = localG;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void ellipse(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<ellipse>", new Object[0]);
    if (currentElement != null)
    {
      SVG.h localH = new SVG.h();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localH, paramAttributes);
      parseAttributesStyle(localH, paramAttributes);
      parseAttributesTransform(localH, paramAttributes);
      parseAttributesConditional(localH, paramAttributes);
      parseAttributesEllipse(localH, paramAttributes);
      currentElement.addChild(localH);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void endElement(String paramString)
    throws SVGParseException
  {
    Object localObject = (SVG.ae)currentElement;
    int i = children.size();
    if (i == 0) {
      localObject = null;
    } else {
      localObject = (SVG.ak)children.get(i - 1);
    }
    if ((localObject instanceof SVG.az))
    {
      StringBuilder localStringBuilder = new StringBuilder();
      localObject = (SVG.az)localObject;
      localStringBuilder.append(text);
      localStringBuilder.append(paramString);
      text = localStringBuilder.toString();
      return;
    }
    currentElement.addChild(new SVG.az(paramString));
  }
  
  private void endElement(String paramString1, String paramString2, String paramString3)
    throws SVGParseException
  {
    if (ignoring)
    {
      int i = ignoreDepth - 1;
      ignoreDepth = i;
      if (i == 0)
      {
        ignoring = false;
        return;
      }
    }
    if ((!"http://www.w3.org/2000/svg".equals(paramString1)) && (!"".equals(paramString1))) {
      return;
    }
    if (paramString2.length() <= 0) {
      paramString2 = paramString3;
    }
    switch (1.this$0[SVGElem.fromString(paramString2).ordinal()])
    {
    default: 
      
    case 3: 
    case 6: 
    case 7: 
    case 8: 
    case 9: 
    case 10: 
    case 11: 
    case 12: 
    case 15: 
      
    case 30: 
      paramString1 = styleElementContents;
      if (paramString1 != null)
      {
        inStyleElement = false;
        parseCSSStyleSheet(paramString1.toString());
        styleElementContents.setLength(0);
        return;
      }
      break;
    case 22: 
    case 23: 
      inMetadataElement = false;
      if (metadataElementContents != null)
      {
        if (metadataTag == SVGElem.title) {
          svgDocument.setTitle(metadataElementContents.toString());
        } else if (metadataTag == SVGElem.desc) {
          svgDocument.setDesc(metadataElementContents.toString());
        }
        metadataElementContents.setLength(0);
        return;
      }
      break;
    case 1: 
    case 2: 
    case 4: 
    case 5: 
    case 13: 
    case 14: 
    case 16: 
    case 17: 
    case 18: 
    case 19: 
    case 20: 
    case 21: 
    case 24: 
    case 25: 
    case 26: 
    case 27: 
    case 28: 
    case 29: 
    case 31: 
      currentElement = currentElement).parent;
    }
  }
  
  private static SVG.Style.FontStyle fontStyleKeyword(String paramString)
  {
    int i = paramString.hashCode();
    if (i != -1657669071)
    {
      if (i != -1178781136)
      {
        if ((i == -1039745817) && (paramString.equals("normal")))
        {
          i = 1;
          break label76;
        }
      }
      else if (paramString.equals("italic"))
      {
        i = 0;
        break label76;
      }
    }
    else if (paramString.equals("oblique"))
    {
      i = 2;
      break label76;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 2: 
      return SVG.Style.FontStyle.Oblique;
    case 1: 
      label76:
      return SVG.Style.FontStyle.Normal;
    }
    return SVG.Style.FontStyle.Italic;
  }
  
  private static SVG.Style.RenderQuality fromString(String paramString)
  {
    int i = paramString.hashCode();
    if (i != -933002398)
    {
      if (i != 3005871)
      {
        if ((i == 362741610) && (paramString.equals("optimizeSpeed")))
        {
          i = 2;
          break label76;
        }
      }
      else if (paramString.equals("auto"))
      {
        i = 0;
        break label76;
      }
    }
    else if (paramString.equals("optimizeQuality"))
    {
      i = 1;
      break label76;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 2: 
      return SVG.Style.RenderQuality.optimizeSpeed;
    case 1: 
      label76:
      return SVG.Style.RenderQuality.optimizeQuality;
    }
    return SVG.Style.RenderQuality.auto;
  }
  
  private void g(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<g>", new Object[0]);
    if (currentElement != null)
    {
      SVG.k localK = new SVG.k();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localK, paramAttributes);
      parseAttributesStyle(localK, paramAttributes);
      parseAttributesTransform(localK, paramAttributes);
      parseAttributesConditional(localK, paramAttributes);
      currentElement.addChild(localK);
      currentElement = localK;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void image(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<image>", new Object[0]);
    if (currentElement != null)
    {
      SVG.m localM = new SVG.m();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localM, paramAttributes);
      parseAttributesStyle(localM, paramAttributes);
      parseAttributesTransform(localM, paramAttributes);
      parseAttributesConditional(localM, paramAttributes);
      parseAttributesImage(localM, paramAttributes);
      currentElement.addChild(localM);
      currentElement = localM;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void line(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<line>", new Object[0]);
    if (currentElement != null)
    {
      SVG.o localO = new SVG.o();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localO, paramAttributes);
      parseAttributesStyle(localO, paramAttributes);
      parseAttributesTransform(localO, paramAttributes);
      parseAttributesConditional(localO, paramAttributes);
      parseAttributesSVG(localO, paramAttributes);
      currentElement.addChild(localO);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void linearGradient(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<linearGradient>", new Object[0]);
    if (currentElement != null)
    {
      SVG.aj localAj = new SVG.aj();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAj, paramAttributes);
      parseAttributesStyle(localAj, paramAttributes);
      parseAttributesGradient(localAj, paramAttributes);
      parseAttributesSVG(localAj, paramAttributes);
      currentElement.addChild(localAj);
      currentElement = localAj;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void marker(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<marker>", new Object[0]);
    if (currentElement != null)
    {
      SVG.p localP = new SVG.p();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localP, paramAttributes);
      parseAttributesStyle(localP, paramAttributes);
      parseAttributesConditional(localP, paramAttributes);
      parseAttributesViewBox(localP, paramAttributes);
      parseAttributesMarker(localP, paramAttributes);
      currentElement.addChild(localP);
      currentElement = localP;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void mask(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<mask>", new Object[0]);
    if (currentElement != null)
    {
      SVG.q localQ = new SVG.q();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localQ, paramAttributes);
      parseAttributesStyle(localQ, paramAttributes);
      parseAttributesConditional(localQ, paramAttributes);
      parseAttributesMask(localQ, paramAttributes);
      currentElement.addChild(localQ);
      currentElement = localQ;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private static Boolean parse(String paramString)
  {
    int i = paramString.hashCode();
    if (i != -1217487446)
    {
      if (i != -907680051)
      {
        if (i != 3005871)
        {
          if ((i == 466743410) && (paramString.equals("visible")))
          {
            i = 0;
            break label98;
          }
        }
        else if (paramString.equals("auto"))
        {
          i = 1;
          break label98;
        }
      }
      else if (paramString.equals("scroll"))
      {
        i = 3;
        break label98;
      }
    }
    else if (paramString.equals("hidden"))
    {
      i = 2;
      break label98;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 2: 
    case 3: 
      label98:
      return Boolean.FALSE;
    }
    return Boolean.TRUE;
  }
  
  private Map parse(f paramF)
  {
    HashMap localHashMap = new HashMap();
    paramF.skipWhitespace();
    for (String str = paramF.nextToken('='); str != null; str = paramF.nextToken('='))
    {
      paramF.consume('=');
      localHashMap.put(str, paramF.nextQuotedString());
      paramF.skipWhitespace();
    }
    return localHashMap;
  }
  
  private void parse()
  {
    svgDocument = new SVG();
  }
  
  private void parse(InputStream paramInputStream)
    throws SVGParseException
  {
    Log.d("SVGParser", "Falling back to SAX parser");
    try
    {
      Object localObject = SAXParserFactory.newInstance();
      ((SAXParserFactory)localObject).setFeature("http://xml.org/sax/features/external-general-entities", false);
      ((SAXParserFactory)localObject).setFeature("http://xml.org/sax/features/external-parameter-entities", false);
      localObject = ((SAXParserFactory)localObject).newSAXParser().getXMLReader();
      e localE = new e(null);
      ((XMLReader)localObject).setContentHandler(localE);
      ((XMLReader)localObject).setProperty("http://xml.org/sax/properties/lexical-handler", localE);
      ((XMLReader)localObject).parse(new InputSource(paramInputStream));
      return;
    }
    catch (IOException paramInputStream)
    {
      throw new SVGParseException("Stream error", paramInputStream);
    }
    catch (SAXException paramInputStream)
    {
      throw new SVGParseException("SVG parse error", paramInputStream);
    }
    catch (ParserConfigurationException paramInputStream)
    {
      throw new SVGParseException("XML parser problem", paramInputStream);
    }
  }
  
  private void parse(InputStream paramInputStream, boolean paramBoolean)
    throws SVGParseException
  {
    for (;;)
    {
      try
      {
        localXmlPullParser = Xml.newPullParser();
        g localG = new g(localXmlPullParser);
        localXmlPullParser.setFeature("http://xmlpull.org/v1/doc/features.html#process-docdecl", false);
        localXmlPullParser.setFeature("http://xmlpull.org/v1/doc/features.html#process-namespaces", true);
        localXmlPullParser.setInput(paramInputStream, null);
        i = localXmlPullParser.getEventType();
        if (i != 1) {
          if (i != 0) {
            if (i != 8)
            {
              if (i != 10)
              {
                Object localObject2;
                String str;
                switch (i)
                {
                default: 
                  break;
                case 5: 
                  characters(localXmlPullParser.getText());
                  break;
                case 4: 
                  localObject1 = new int[2];
                  localObject2 = localXmlPullParser.getTextCharacters((int[])localObject1);
                  i = localObject1[0];
                  int j = localObject1[1];
                  characters((char[])localObject2, i, j);
                  break;
                case 3: 
                  localObject2 = localXmlPullParser.getName();
                  localObject1 = localObject2;
                  str = localXmlPullParser.getPrefix();
                  if (str != null)
                  {
                    localObject1 = new StringBuilder();
                    ((StringBuilder)localObject1).append(localXmlPullParser.getPrefix());
                    ((StringBuilder)localObject1).append(':');
                    ((StringBuilder)localObject1).append((String)localObject2);
                    localObject1 = ((StringBuilder)localObject1).toString();
                  }
                  endElement(localXmlPullParser.getNamespace(), localXmlPullParser.getName(), (String)localObject1);
                  break;
                case 2: 
                  localObject2 = localXmlPullParser.getName();
                  localObject1 = localObject2;
                  str = localXmlPullParser.getPrefix();
                  if (str != null)
                  {
                    localObject1 = new StringBuilder();
                    ((StringBuilder)localObject1).append(localXmlPullParser.getPrefix());
                    ((StringBuilder)localObject1).append(':');
                    ((StringBuilder)localObject1).append((String)localObject2);
                    localObject1 = ((StringBuilder)localObject1).toString();
                  }
                  startElement(localXmlPullParser.getNamespace(), localXmlPullParser.getName(), (String)localObject1, localG);
                  break;
                }
              }
              if (!paramBoolean) {
                continue;
              }
              localObject1 = svgDocument;
              localObject1 = ((SVG)localObject1).split();
              if (localObject1 != null) {
                continue;
              }
              boolean bool = localXmlPullParser.getText().contains("<!ENTITY ");
              if (!bool) {
                continue;
              }
            }
          }
        }
      }
      catch (IOException paramInputStream)
      {
        XmlPullParser localXmlPullParser;
        int i;
        Object localObject1;
        throw new SVGParseException("Stream error", (Exception)paramInputStream);
      }
      catch (XmlPullParserException paramInputStream)
      {
        throw new SVGParseException("XML parser problem", paramInputStream);
      }
      try
      {
        Log.d("SVGParser", "Switching to SAX parser to process entities");
        paramInputStream.reset();
        parse(paramInputStream);
        return;
      }
      catch (IOException paramInputStream)
      {
        continue;
      }
      Log.w("SVGParser", "Detected internal entity definitions, but could not parse them.");
      return;
      localObject1 = new StringBuilder();
      ((StringBuilder)localObject1).append("PROC INSTR: ");
      ((StringBuilder)localObject1).append(localXmlPullParser.getText());
      Log.d("SVGParser", ((StringBuilder)localObject1).toString());
      localObject1 = new f(localXmlPullParser.getText());
      parse(((f)localObject1).get(), parse((f)localObject1));
      continue;
      parse();
      i = localXmlPullParser.nextToken();
    }
    clear();
  }
  
  private void parse(String paramString, Map paramMap)
  {
    if ((paramString.equals("xml-stylesheet")) && (SVG.getFileResolver() != null))
    {
      if (((String)paramMap.get("type") != null) && (!"text/css".equals(paramMap.get("type")))) {
        return;
      }
      if (((String)paramMap.get("alternate") != null) && (!"no".equals(paramMap.get("alternate")))) {
        return;
      }
      paramString = (String)paramMap.get("href");
      if (paramString != null)
      {
        String str1 = SVG.getFileResolver().string(paramString);
        paramString = str1;
        if (str1 == null) {
          return;
        }
        String str2 = (String)paramMap.get("media");
        paramMap = paramString;
        if (str2 != null)
        {
          paramMap = paramString;
          if (!"all".equals(str2.trim()))
          {
            paramString = new StringBuilder();
            paramString.append("@media ");
            paramString.append(str2);
            paramString.append(" { ");
            paramString.append(str1);
            paramString.append("}");
            paramMap = paramString.toString();
          }
        }
        parseCSSStyleSheet(paramMap);
      }
    }
  }
  
  private void parseAttributesCircle(SVG.c paramC, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 14: 
        r = parseLength(str);
        if (r.isNegative()) {
          throw new SVGParseException("Invalid <circle> element. r cannot be negative");
        }
        break;
      case 13: 
        cy = parseLength(str);
        break;
      case 12: 
        cx = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesClipPath(SVG.d paramD, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      if (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()] == 38) {
        if ("objectBoundingBox".equals(str))
        {
          clipPathUnitsAreUser = Boolean.valueOf(false);
        }
        else
        {
          if (!"userSpaceOnUse".equals(str)) {
            break label97;
          }
          clipPathUnitsAreUser = Boolean.valueOf(true);
        }
      }
      i += 1;
      continue;
      label97:
      throw new SVGParseException("Invalid value for attribute clipPathUnits");
    }
  }
  
  private void parseAttributesConditional(SVG.ad paramAd, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      Object localObject = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 25: 
        localObject = parseFontFamily((String)localObject);
        if (localObject != null) {
          localObject = new HashSet((Collection)localObject);
        } else {
          localObject = new HashSet(0);
        }
        paramAd.setRequiredFeatures((Set)localObject);
        break;
      case 24: 
        paramAd.setRequiredFormats(parseRequiredFormats((String)localObject));
        break;
      case 23: 
        paramAd.setSystemLanguage(parseSystemLanguage((String)localObject));
        break;
      case 22: 
        paramAd.parseHeader((String)localObject);
        break;
      case 21: 
        paramAd.updateEntries(parseRequiredFeatures((String)localObject));
      }
      i += 1;
    }
  }
  
  private void parseAttributesCore(SVG.ai paramAi, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getQName(i);
      if ((!str.equals("id")) && (!str.equals("xml:id")))
      {
        if (str.equals("xml:space"))
        {
          paramAttributes = paramAttributes.getValue(i).trim();
          if ("default".equals(paramAttributes))
          {
            spacePreserve = Boolean.FALSE;
            return;
          }
          if ("preserve".equals(paramAttributes))
          {
            spacePreserve = Boolean.TRUE;
            return;
          }
          paramAi = new StringBuilder();
          paramAi.append("Invalid value for \"xml:space\" attribute: ");
          paramAi.append(paramAttributes);
          throw new SVGParseException(paramAi.toString());
        }
        i += 1;
      }
      else
      {
        c = paramAttributes.getValue(i).trim();
      }
    }
  }
  
  private void parseAttributesEllipse(SVG.h paramH, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 13: 
        cy = parseLength(str);
        break;
      case 12: 
        cx = parseLength(str);
        break;
      case 11: 
        ry = parseLength(str);
        if (ry.isNegative()) {
          throw new SVGParseException("Invalid <ellipse> element. ry cannot be negative");
        }
        break;
      case 10: 
        rx = parseLength(str);
        if (rx.isNegative()) {
          throw new SVGParseException("Invalid <ellipse> element. rx cannot be negative");
        }
        break;
      }
      i += 1;
    }
  }
  
  private void parseAttributesGradient(SVG.i paramI, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      if (j != 6) {
        switch (j)
        {
        default: 
          break;
        }
      }
      try
      {
        SVG.GradientSpread localGradientSpread = SVG.GradientSpread.valueOf(str);
        spreadMethod = localGradientSpread;
      }
      catch (IllegalArgumentException paramI)
      {
        for (;;) {}
      }
      paramI = new StringBuilder();
      paramI.append("Invalid spreadMethod attribute. \"");
      paramI.append(str);
      paramI.append("\" is not a valid value.");
      throw new SVGParseException(paramI.toString());
      gradientTransform = parseTransformList(str);
      break label258;
      if ("objectBoundingBox".equals(str))
      {
        gradientUnitsAreUser = Boolean.valueOf(false);
      }
      else if ("userSpaceOnUse".equals(str))
      {
        gradientUnitsAreUser = Boolean.valueOf(true);
      }
      else
      {
        throw new SVGParseException("Invalid value for attribute gradientUnits");
        if (("".equals(paramAttributes.getURI(i))) || ("http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i)))) {
          href = str;
        }
      }
      label258:
      i += 1;
    }
  }
  
  private void parseAttributesImage(SVG.m paramM, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 5: 
        break;
      case 7: 
        parsePreserveAspectRatio(paramM, str);
        break;
      case 6: 
        if ((!"".equals(paramAttributes.getURI(i))) && (!"http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i)))) {
          break;
        }
        href = str;
        break;
      case 4: 
        height = parseLength(str);
        if (!height.isNegative()) {
          break;
        }
        throw new SVGParseException("Invalid <use> element. height cannot be negative");
      case 3: 
        width = parseLength(str);
        if (!width.isNegative()) {
          break;
        }
        throw new SVGParseException("Invalid <use> element. width cannot be negative");
      case 2: 
        y = parseLength(str);
        break;
      }
      x = parseLength(str);
      i += 1;
    }
  }
  
  private void parseAttributesMarker(SVG.p paramP, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 31: 
        if ("auto".equals(str)) {
          orient = Float.valueOf(NaN.0F);
        } else {
          orient = Float.valueOf(parseFloat(str));
        }
        break;
      case 30: 
        if ("strokeWidth".equals(str)) {
          overflow = false;
        } else if ("userSpaceOnUse".equals(str)) {
          overflow = true;
        } else {
          throw new SVGParseException("Invalid value for attribute markerUnits");
        }
        break;
      case 29: 
        markerHeight = parseLength(str);
        if (markerHeight.isNegative()) {
          throw new SVGParseException("Invalid <marker> element. markerHeight cannot be negative");
        }
        break;
      case 28: 
        markerWidth = parseLength(str);
        if (markerWidth.isNegative()) {
          throw new SVGParseException("Invalid <marker> element. markerWidth cannot be negative");
        }
        break;
      case 27: 
        refY = parseLength(str);
        break;
      case 26: 
        refX = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesMask(SVG.q paramQ, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      switch (j)
      {
      default: 
        switch (j)
        {
        default: 
          break;
        case 44: 
          if ("objectBoundingBox".equals(str)) {
            maskContentUnitsAreUser = Boolean.valueOf(false);
          } else if ("userSpaceOnUse".equals(str)) {
            maskContentUnitsAreUser = Boolean.valueOf(true);
          } else {
            throw new SVGParseException("Invalid value for attribute maskContentUnits");
          }
          break;
        case 43: 
          if ("objectBoundingBox".equals(str)) {
            maskUnitsAreUser = Boolean.valueOf(false);
          } else if ("userSpaceOnUse".equals(str)) {
            maskUnitsAreUser = Boolean.valueOf(true);
          } else {
            throw new SVGParseException("Invalid value for attribute maskUnits");
          }
          break;
        }
        break;
      case 4: 
        height = parseLength(str);
        if (height.isNegative()) {
          throw new SVGParseException("Invalid <mask> element. height cannot be negative");
        }
        break;
      case 3: 
        width = parseLength(str);
        if (width.isNegative()) {
          throw new SVGParseException("Invalid <mask> element. width cannot be negative");
        }
        break;
      case 2: 
        y = parseLength(str);
        break;
      case 1: 
        x = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesPath(SVG.t paramT, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 9: 
        pathLength = Float.valueOf(parseFloat(str));
        if (pathLength.floatValue() < 0.0F) {
          throw new SVGParseException("Invalid <path> element. pathLength cannot be negative");
        }
        break;
      case 8: 
        d = parsePath(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesPattern(SVG.ar paramAr, Attributes paramAttributes)
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      if ((1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()] == 6) && (("".equals(paramAttributes.getURI(i))) || ("http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i))))) {
        href = str;
      }
      i += 1;
    }
  }
  
  private void parseAttributesPattern(SVG.aw paramAw, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      if (j != 6)
      {
        if (j == 39) {
          x = parseLength(str);
        }
      }
      else if (("".equals(paramAttributes.getURI(i))) || ("http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i)))) {
        href = str;
      }
      i += 1;
    }
  }
  
  private void parseAttributesPattern(SVG.w paramW, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      if (j != 6) {
        switch (j)
        {
        default: 
          switch (j)
          {
          default: 
            break;
          case 42: 
            patternTransform = parseTransformList(str);
            break;
          case 41: 
            if ("objectBoundingBox".equals(str))
            {
              patternContentUnitsAreUser = Boolean.valueOf(false);
              break;
            }
            if ("userSpaceOnUse".equals(str))
            {
              patternContentUnitsAreUser = Boolean.valueOf(true);
              break;
            }
            throw new SVGParseException("Invalid value for attribute patternContentUnits");
          case 40: 
            if ("objectBoundingBox".equals(str))
            {
              patternUnitsAreUser = Boolean.valueOf(false);
              break;
            }
            if ("userSpaceOnUse".equals(str))
            {
              patternUnitsAreUser = Boolean.valueOf(true);
              break;
            }
            throw new SVGParseException("Invalid value for attribute patternUnits");
          }
          break;
        case 4: 
          height = parseLength(str);
          if (!height.isNegative()) {
            break;
          }
          throw new SVGParseException("Invalid <pattern> element. height cannot be negative");
        case 3: 
          width = parseLength(str);
          if (!width.isNegative()) {
            break;
          }
          throw new SVGParseException("Invalid <pattern> element. width cannot be negative");
        case 2: 
          y = parseLength(str);
          break;
        case 1: 
          x = parseLength(str);
          break;
        }
      } else if (("".equals(paramAttributes.getURI(i))) || ("http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i)))) {
        href = str;
      }
      i += 1;
    }
  }
  
  private void parseAttributesPolyLine(SVG.x paramX, Attributes paramAttributes, String paramString)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      if (SVGAttr.fromString(paramAttributes.getLocalName(i)) == SVGAttr.points)
      {
        Object localObject = new f(paramAttributes.getValue(i));
        ArrayList localArrayList = new ArrayList();
        ((f)localObject).skipWhitespace();
        float f1;
        while (!((f)localObject).empty())
        {
          f1 = ((f)localObject).nextFloat();
          if (!Float.isNaN(f1))
          {
            ((f)localObject).skipCommaWhitespace();
            float f2 = ((f)localObject).nextFloat();
            if (!Float.isNaN(f2))
            {
              ((f)localObject).skipCommaWhitespace();
              localArrayList.add(Float.valueOf(f1));
              localArrayList.add(Float.valueOf(f2));
            }
            else
            {
              paramX = new StringBuilder();
              paramX.append("Invalid <");
              paramX.append(paramString);
              paramX.append("> points attribute. There should be an even number of coordinates.");
              throw new SVGParseException(paramX.toString());
            }
          }
          else
          {
            paramX = new StringBuilder();
            paramX.append("Invalid <");
            paramX.append(paramString);
            paramX.append("> points attribute. Non-coordinate content found in list.");
            throw new SVGParseException(paramX.toString());
          }
        }
        points = new float[localArrayList.size()];
        localObject = localArrayList.iterator();
        int j = 0;
        while (((Iterator)localObject).hasNext())
        {
          f1 = ((Float)((Iterator)localObject).next()).floatValue();
          points[j] = f1;
          j += 1;
        }
      }
      i += 1;
    }
  }
  
  private void parseAttributesRadialGradient(SVG.an paramAn, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      switch (j)
      {
      default: 
        switch (j)
        {
        default: 
          break;
        case 36: 
          fy = parseLength(str);
          break;
        case 35: 
          fx = parseLength(str);
        }
        break;
      case 14: 
        r = parseLength(str);
        if (r.isNegative()) {
          throw new SVGParseException("Invalid <radialGradient> element. r cannot be negative");
        }
        break;
      case 13: 
        cy = parseLength(str);
        break;
      case 12: 
        cx = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesRect(SVG.z paramZ, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      switch (j)
      {
      default: 
        switch (j)
        {
        default: 
          break;
        case 11: 
          ry = parseLength(str);
          if (ry.isNegative()) {
            throw new SVGParseException("Invalid <rect> element. ry cannot be negative");
          }
          break;
        case 10: 
          rx = parseLength(str);
          if (rx.isNegative()) {
            throw new SVGParseException("Invalid <rect> element. rx cannot be negative");
          }
          break;
        }
        break;
      case 4: 
        height = parseLength(str);
        if (height.isNegative()) {
          throw new SVGParseException("Invalid <rect> element. height cannot be negative");
        }
        break;
      case 3: 
        width = parseLength(str);
        if (width.isNegative()) {
          throw new SVGParseException("Invalid <rect> element. width cannot be negative");
        }
        break;
      case 2: 
        y = parseLength(str);
        break;
      case 1: 
        x = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesSVG(SVG.ac paramAc, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 5: 
        version = str;
        break;
      case 4: 
        height = parseLength(str);
        if (height.isNegative()) {
          throw new SVGParseException("Invalid <svg> element. height cannot be negative");
        }
        break;
      case 3: 
        width = parseLength(str);
        if (width.isNegative()) {
          throw new SVGParseException("Invalid <svg> element. width cannot be negative");
        }
        break;
      case 2: 
        y = parseLength(str);
        break;
      case 1: 
        x = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesSVG(SVG.aj paramAj, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 18: 
        height = parseLength(str);
        break;
      case 17: 
        width = parseLength(str);
        break;
      case 16: 
        y = parseLength(str);
        break;
      case 15: 
        x = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesSVG(SVG.o paramO, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 18: 
        height = parseLength(str);
        break;
      case 17: 
        width = parseLength(str);
        break;
      case 16: 
        y = parseLength(str);
        break;
      case 15: 
        x = parseLength(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesStop(SVG.ab paramAb, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      if (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()] == 37) {
        offset = parseGradiantOffset(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesStyle(SVG.ai paramAi, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      if (str.length() != 0)
      {
        switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
        {
        default: 
          if (baseStyle == null) {
            baseStyle = new SVG.Style();
          }
          break;
        case 46: 
          classNames = CSSParser.parseClassAttribute(str);
          break;
        case 45: 
          parseStyle(paramAi, str);
          break;
        }
        processStyleProperty(baseStyle, paramAttributes.getLocalName(i), paramAttributes.getValue(i).trim());
      }
      i += 1;
    }
  }
  
  private void parseAttributesTextPosition(SVG.ax paramAx, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
      {
      default: 
        break;
      case 20: 
        dy = parseLengthList(str);
        break;
      case 19: 
        dx = parseLengthList(str);
        break;
      case 2: 
        y = parseLengthList(str);
        break;
      case 1: 
        x = parseLengthList(str);
      }
      i += 1;
    }
  }
  
  private void parseAttributesTransform(SVG.l paramL, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      if (SVGAttr.fromString(paramAttributes.getLocalName(i)) == SVGAttr.transform) {
        paramL.setTransform(parseTransformList(paramAttributes.getValue(i)));
      }
      i += 1;
    }
  }
  
  private void parseAttributesUse(SVG.ba paramBa, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      if (j != 6) {
        switch (j)
        {
        default: 
          break;
        case 4: 
          height = parseLength(str);
          if (!height.isNegative()) {
            break;
          }
          throw new SVGParseException("Invalid <use> element. height cannot be negative");
        case 3: 
          width = parseLength(str);
          if (!width.isNegative()) {
            break;
          }
          throw new SVGParseException("Invalid <use> element. width cannot be negative");
        case 2: 
          y = parseLength(str);
          break;
        case 1: 
          x = parseLength(str);
          break;
        }
      } else if (("".equals(paramAttributes.getURI(i))) || ("http://www.w3.org/1999/xlink".equals(paramAttributes.getURI(i)))) {
        href = str;
      }
      i += 1;
    }
  }
  
  private void parseAttributesViewBox(SVG.ao paramAo, Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    while (i < paramAttributes.getLength())
    {
      String str = paramAttributes.getValue(i).trim();
      int j = 1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()];
      if (j != 7)
      {
        if (j == 87) {
          viewBox = parseViewBox(str);
        }
      }
      else {
        parsePreserveAspectRatio(paramAo, str);
      }
      i += 1;
    }
  }
  
  private void parseCSSStyleSheet(String paramString)
  {
    CSSParser localCSSParser = new CSSParser(CSSParser.MediaType.screen, CSSParser.Source.Document);
    svgDocument.setTitle(localCSSParser.parse(paramString));
  }
  
  private static SVG.b parseClip(String paramString)
  {
    if ("auto".equals(paramString)) {
      return null;
    }
    if (!paramString.startsWith("rect(")) {
      return null;
    }
    paramString = new f(paramString.substring(5));
    paramString.skipWhitespace();
    SVG.n localN1 = parseLengthOrAuto(paramString);
    paramString.skipCommaWhitespace();
    SVG.n localN2 = parseLengthOrAuto(paramString);
    paramString.skipCommaWhitespace();
    SVG.n localN3 = parseLengthOrAuto(paramString);
    paramString.skipCommaWhitespace();
    SVG.n localN4 = parseLengthOrAuto(paramString);
    paramString.skipWhitespace();
    if ((!paramString.consume(')')) && (!paramString.empty())) {
      return null;
    }
    return new SVG.b(localN1, localN2, localN3, localN4);
  }
  
  private static SVG.e parseColour(String paramString)
    throws SVGParseException
  {
    int j = paramString.charAt(0);
    int i = 4;
    if (j == 35)
    {
      localObject = IntegerParser.parseHex(paramString, 1, paramString.length());
      if (localObject != null)
      {
        i = ((IntegerParser)localObject).getEndPos();
        if (i != 7)
        {
          if (i != 9)
          {
            switch (i)
            {
            default: 
              localObject = new StringBuilder();
              ((StringBuilder)localObject).append("Bad hex colour value: ");
              ((StringBuilder)localObject).append(paramString);
              throw new SVGParseException(((StringBuilder)localObject).toString());
            case 5: 
              int m = ((IntegerParser)localObject).value();
              i = 0xF000 & m;
              j = m & 0xF00;
              k = m & 0xF0;
              m &= 0xF;
              return new SVG.e(m << 24 | m << 28 | i << 8 | i << 4 | j << 4 | j | k | k >> 4);
            }
            int k = ((IntegerParser)localObject).value();
            i = k & 0xF00;
            j = k & 0xF0;
            k &= 0xF;
            return new SVG.e(k | i << 8 | 0xFF000000 | i << 12 | j << 8 | j << 4 | k << 4);
          }
          i = ((IntegerParser)localObject).value();
          return new SVG.e(((IntegerParser)localObject).value() >>> 8 | i << 24);
        }
        return new SVG.e(((IntegerParser)localObject).value() | 0xFF000000);
      }
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("Bad hex colour value: ");
      ((StringBuilder)localObject).append(paramString);
      throw new SVGParseException(((StringBuilder)localObject).toString());
    }
    Object localObject = paramString.toLowerCase(Locale.US);
    boolean bool = ((String)localObject).startsWith("rgba(");
    if ((!bool) && (!((String)localObject).startsWith("rgb(")))
    {
      bool = ((String)localObject).startsWith("hsla(");
      if ((!bool) && (!((String)localObject).startsWith("hsl("))) {
        return parseColourKeyword((String)localObject);
      }
      if (bool) {
        i = 5;
      }
      localObject = new f(paramString.substring(i));
      ((f)localObject).skipWhitespace();
      f1 = ((f)localObject).nextFloat();
      f2 = ((f)localObject).checkedNextFloat(f1);
      if (!Float.isNaN(f2)) {
        ((f)localObject).consume('%');
      }
      f3 = ((f)localObject).checkedNextFloat(f2);
      if (!Float.isNaN(f3)) {
        ((f)localObject).consume('%');
      }
      if (bool)
      {
        f4 = ((f)localObject).checkedNextFloat(f3);
        ((f)localObject).skipWhitespace();
        if ((!Float.isNaN(f4)) && (((f)localObject).consume(')'))) {
          return new SVG.e(clamp255(f4 * 256.0F) << 24 | a(f1, f2, f3));
        }
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append("Bad hsla() colour value: ");
        ((StringBuilder)localObject).append(paramString);
        throw new SVGParseException(((StringBuilder)localObject).toString());
      }
      ((f)localObject).skipWhitespace();
      if ((!Float.isNaN(f3)) && (((f)localObject).consume(')'))) {
        return new SVG.e(a(f1, f2, f3) | 0xFF000000);
      }
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("Bad hsl() colour value: ");
      ((StringBuilder)localObject).append(paramString);
      throw new SVGParseException(((StringBuilder)localObject).toString());
    }
    if (bool) {
      i = 5;
    }
    localObject = new f(paramString.substring(i));
    ((f)localObject).skipWhitespace();
    float f3 = ((f)localObject).nextFloat();
    float f2 = f3;
    float f1 = f2;
    if (!Float.isNaN(f3))
    {
      f1 = f2;
      if (((f)localObject).consume('%')) {
        f1 = f3 * 256.0F / 100.0F;
      }
    }
    float f4 = ((f)localObject).checkedNextFloat(f1);
    f3 = f4;
    f2 = f3;
    if (!Float.isNaN(f4))
    {
      f2 = f3;
      if (((f)localObject).consume('%')) {
        f2 = f4 * 256.0F / 100.0F;
      }
    }
    float f5 = ((f)localObject).checkedNextFloat(f2);
    f4 = f5;
    f3 = f4;
    if (!Float.isNaN(f5))
    {
      f3 = f4;
      if (((f)localObject).consume('%')) {
        f3 = f5 * 256.0F / 100.0F;
      }
    }
    if (bool)
    {
      f4 = ((f)localObject).checkedNextFloat(f3);
      ((f)localObject).skipWhitespace();
      if ((!Float.isNaN(f4)) && (((f)localObject).consume(')'))) {
        return new SVG.e(clamp255(f4 * 256.0F) << 24 | clamp255(f1) << 16 | clamp255(f2) << 8 | clamp255(f3));
      }
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("Bad rgba() colour value: ");
      ((StringBuilder)localObject).append(paramString);
      throw new SVGParseException(((StringBuilder)localObject).toString());
    }
    ((f)localObject).skipWhitespace();
    if ((!Float.isNaN(f3)) && (((f)localObject).consume(')'))) {
      return new SVG.e(clamp255(f1) << 16 | 0xFF000000 | clamp255(f2) << 8 | clamp255(f3));
    }
    localObject = new StringBuilder();
    ((StringBuilder)localObject).append("Bad rgb() colour value: ");
    ((StringBuilder)localObject).append(paramString);
    throw new SVGParseException(((StringBuilder)localObject).toString());
  }
  
  private static SVG.e parseColourKeyword(String paramString)
    throws SVGParseException
  {
    Object localObject = b.get(paramString);
    if (localObject != null) {
      return new SVG.e(((Integer)localObject).intValue());
    }
    localObject = new StringBuilder();
    ((StringBuilder)localObject).append("Invalid colour keyword: ");
    ((StringBuilder)localObject).append(paramString);
    throw new SVGParseException(((StringBuilder)localObject).toString());
  }
  
  private static SVG.al parseColourSpecifer(String paramString)
  {
    int i = paramString.hashCode();
    if (i != 3387192)
    {
      if ((i == 1442907498) && (paramString.equals("currentColor")))
      {
        i = 1;
        break label54;
      }
    }
    else if (paramString.equals("none"))
    {
      i = 0;
      break label54;
    }
    i = -1;
    switch (i)
    {
    default: 
      label54:
      break;
    }
    try
    {
      paramString = parseColour(paramString);
      return paramString;
    }
    catch (SVGParseException paramString)
    {
      for (;;) {}
    }
    return SVG.f.parseColour();
    return SVG.e.fontSize;
    return null;
  }
  
  private static SVG.Style.FillRule parseFillRule(String paramString)
  {
    if ("nonzero".equals(paramString)) {
      return SVG.Style.FillRule.NonZero;
    }
    if ("evenodd".equals(paramString)) {
      return SVG.Style.FillRule.EvenOdd;
    }
    return null;
  }
  
  private static float parseFloat(String paramString)
    throws SVGParseException
  {
    int i = paramString.length();
    if (i != 0) {
      return parseFloat(paramString, 0, i);
    }
    throw new SVGParseException("Invalid float value (empty string)");
  }
  
  private static float parseFloat(String paramString, int paramInt1, int paramInt2)
    throws SVGParseException
  {
    float f = new NumberParser().parseNumber(paramString, paramInt1, paramInt2);
    if (!Float.isNaN(f)) {
      return f;
    }
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("Invalid float value: ");
    localStringBuilder.append(paramString);
    throw new SVGParseException(localStringBuilder.toString());
  }
  
  private static void parseFont(SVG.Style paramStyle, String paramString)
  {
    Object localObject1 = new StringBuilder();
    ((StringBuilder)localObject1).append('|');
    ((StringBuilder)localObject1).append(paramString);
    ((StringBuilder)localObject1).append('|');
    if (!"|caption|icon|menu|message-box|small-caption|status-bar|".contains(((StringBuilder)localObject1).toString())) {
      return;
    }
    f localF = new f(paramString);
    localObject1 = null;
    paramString = null;
    Object localObject4 = null;
    String str;
    Object localObject3;
    for (;;)
    {
      str = localF.nextToken('/');
      localF.skipWhitespace();
      if (str == null) {
        return;
      }
      if ((localObject1 != null) && (paramString != null)) {
        break;
      }
      if (!str.equals("normal"))
      {
        localObject2 = localObject1;
        if (localObject1 == null)
        {
          localObject3 = d.get(str);
          localObject1 = localObject3;
          localObject2 = localObject1;
          if (localObject3 != null) {}
        }
        else
        {
          localObject3 = paramString;
          if (paramString == null)
          {
            localObject1 = fontStyleKeyword(str);
            paramString = (String)localObject1;
            localObject3 = paramString;
            if (localObject1 != null)
            {
              localObject1 = localObject2;
              continue;
            }
          }
          localObject1 = localObject2;
          paramString = (String)localObject3;
          if (localObject4 != null) {
            break;
          }
          localObject1 = localObject2;
          paramString = (String)localObject3;
          if (!str.equals("small-caps")) {
            break;
          }
          localObject4 = str;
          localObject1 = localObject2;
          paramString = (String)localObject3;
        }
      }
    }
    Object localObject2 = parseFontSize(str);
    if (localF.consume('/'))
    {
      localF.skipWhitespace();
      localObject3 = localF.get();
      if (localObject3 == null) {}
    }
    try
    {
      parseLength((String)localObject3);
      localF.skipWhitespace();
      fontFamily = parseFontFamily(localF.restOfText());
      fontSize = ((SVG.n)localObject2);
      int i;
      if (localObject1 == null) {
        i = 400;
      } else {
        i = ((Integer)localObject1).intValue();
      }
      fontWeight = Integer.valueOf(i);
      localObject1 = paramString;
      if (paramString == null) {
        localObject1 = SVG.Style.FontStyle.Normal;
      }
      fontStyle = ((SVG.Style.FontStyle)localObject1);
      specifiedFlags |= 0x1E000;
      return;
    }
    catch (SVGParseException paramStyle) {}
  }
  
  private static List parseFontFamily(String paramString)
  {
    f localF = new f(paramString);
    paramString = null;
    Object localObject2;
    do
    {
      localObject2 = localF.nextQuotedString();
      Object localObject1 = localObject2;
      if (localObject2 == null) {
        localObject1 = localF.add(',');
      }
      if (localObject1 == null) {
        return paramString;
      }
      localObject2 = paramString;
      if (paramString == null) {
        localObject2 = new ArrayList();
      }
      ((List)localObject2).add(localObject1);
      localF.skipCommaWhitespace();
      paramString = (String)localObject2;
    } while (!localF.empty());
    return localObject2;
  }
  
  private static SVG.n parseFontSize(String paramString)
  {
    SVG.n localN;
    try
    {
      localN = c.parseLength(paramString);
      if (localN != null) {
        return localN;
      }
      paramString = parseLength(paramString);
      return paramString;
    }
    catch (SVGParseException paramString)
    {
      for (;;) {}
    }
    return null;
    return localN;
  }
  
  private static Integer parseFontWeight(String paramString)
  {
    return d.get(paramString);
  }
  
  private static String parseFunctionalIRI(String paramString1, String paramString2)
  {
    if (paramString1.equals("none")) {
      return null;
    }
    if (!paramString1.startsWith("url(")) {
      return null;
    }
    if (paramString1.endsWith(")")) {
      return paramString1.substring(4, paramString1.length() - 1).trim();
    }
    return paramString1.substring(4).trim();
  }
  
  private Float parseGradiantOffset(String paramString)
    throws SVGParseException
  {
    if (paramString.length() != 0)
    {
      int k = paramString.length();
      int i = k;
      int m = paramString.length();
      int j = 1;
      if (paramString.charAt(m - 1) == '%') {
        i = k - 1;
      } else {
        j = 0;
      }
      try
      {
        float f2 = parseFloat(paramString, 0, i);
        float f1 = f2;
        if (j != 0) {
          f1 = f2 / 100.0F;
        }
        if (f1 < 0.0F)
        {
          f2 = 0.0F;
        }
        else
        {
          f2 = f1;
          if (f1 > 100.0F) {
            f2 = 100.0F;
          }
        }
        return Float.valueOf(f2);
      }
      catch (NumberFormatException localNumberFormatException)
      {
        StringBuilder localStringBuilder = new StringBuilder();
        localStringBuilder.append("Invalid offset value in <stop>: ");
        localStringBuilder.append(paramString);
        throw new SVGParseException(localStringBuilder.toString(), localNumberFormatException);
      }
    }
    throw new SVGParseException("Invalid offset value in <stop> (empty string)");
  }
  
  static SVG.n parseLength(String paramString)
    throws SVGParseException
  {
    Object localObject2;
    int i;
    if (paramString.length() != 0)
    {
      int k = paramString.length();
      int j = k;
      localObject2 = SVG.Unit.px;
      char c = paramString.charAt(k - 1);
      if (c == '%')
      {
        i = k - 1;
        localObject1 = SVG.Unit.percent;
      }
      else
      {
        i = j;
        localObject1 = localObject2;
        if (k > 2)
        {
          i = j;
          localObject1 = localObject2;
          if (Character.isLetter(c))
          {
            i = j;
            localObject1 = localObject2;
            if (Character.isLetter(paramString.charAt(k - 2)))
            {
              i = k - 2;
              localObject1 = paramString.substring(i);
              localObject2 = Locale.US;
            }
          }
        }
      }
    }
    try
    {
      localObject1 = SVG.Unit.valueOf(((String)localObject1).toLowerCase((Locale)localObject2));
    }
    catch (IllegalArgumentException localIllegalArgumentException)
    {
      for (;;) {}
    }
    Object localObject1 = new StringBuilder();
    ((StringBuilder)localObject1).append("Invalid length unit specifier: ");
    ((StringBuilder)localObject1).append(paramString);
    throw new SVGParseException(((StringBuilder)localObject1).toString());
    try
    {
      float f = parseFloat(paramString, 0, i);
      localObject1 = new SVG.n(f, (SVG.Unit)localObject1);
      return localObject1;
    }
    catch (NumberFormatException localNumberFormatException)
    {
      localObject2 = new StringBuilder();
      ((StringBuilder)localObject2).append("Invalid length value: ");
      ((StringBuilder)localObject2).append(paramString);
      throw new SVGParseException(((StringBuilder)localObject2).toString(), localNumberFormatException);
    }
    throw new SVGParseException("Invalid length value (empty string)");
  }
  
  private static List parseLengthList(String paramString)
    throws SVGParseException
  {
    ArrayList localArrayList;
    if (paramString.length() != 0)
    {
      localArrayList = new ArrayList(1);
      f localF = new f(paramString);
      localF.skipWhitespace();
      for (;;)
      {
        if (localF.empty()) {
          return localArrayList;
        }
        float f = localF.nextFloat();
        if (Float.isNaN(f)) {
          break;
        }
        SVG.Unit localUnit = localF.nextUnit();
        paramString = localUnit;
        if (localUnit == null) {
          paramString = SVG.Unit.px;
        }
        localArrayList.add(new SVG.n(f, paramString));
        localF.skipCommaWhitespace();
      }
      paramString = new StringBuilder();
      paramString.append("Invalid length list value: ");
      paramString.append(localF.ahead());
      throw new SVGParseException(paramString.toString());
    }
    throw new SVGParseException("Invalid length list (empty string)");
    return localArrayList;
  }
  
  private static SVG.n parseLengthOrAuto(f paramF)
  {
    if (paramF.consume("auto")) {
      return new SVG.n(0.0F);
    }
    return paramF.nextLength();
  }
  
  private static SVG.al parsePaintSpecifier(String paramString)
  {
    if (paramString.startsWith("url("))
    {
      int i = paramString.indexOf(")");
      Object localObject = null;
      if (i != -1)
      {
        String str1 = paramString.substring(4, i).trim();
        String str2 = paramString.substring(i + 1).trim();
        paramString = localObject;
        if (str2.length() > 0) {
          paramString = parseColourSpecifer(str2);
        }
        return new SVG.s(str1, paramString);
      }
      return new SVG.s(paramString.substring(4).trim(), null);
    }
    return parseColourSpecifer(paramString);
  }
  
  private static SVG.u parsePath(String paramString)
  {
    Object localObject = new f(paramString);
    paramString = new SVG.u();
    if (((f)localObject).empty()) {
      return paramString;
    }
    int i = ((f)localObject).nextChar().intValue();
    if ((i != 77) && (i != 109)) {
      return paramString;
    }
    float f8 = 0.0F;
    float f10 = 0.0F;
    float f7 = 0.0F;
    float f9 = 0.0F;
    float f6 = 0.0F;
    float f5 = 0.0F;
    for (;;)
    {
      ((f)localObject).skipWhitespace();
      int j = 108;
      float f1;
      float f2;
      float f3;
      float f4;
      float f11;
      switch (i)
      {
      default: 
        return paramString;
      case 90: 
      case 122: 
        paramString.a();
        f1 = f6;
        f2 = f6;
        f3 = f5;
        f4 = f5;
        break;
      case 86: 
      case 118: 
        f1 = ((f)localObject).nextFloat();
        f4 = f1;
        if (Float.isNaN(f1))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 118) {
          f4 = f1 + f7;
        }
        paramString.a(f8, f4);
        f3 = f4;
        f1 = f8;
        f2 = f10;
        break;
      case 84: 
      case 116: 
        f10 = f8 * 2.0F - f10;
        f4 = 2.0F * f7 - f9;
        f9 = ((f)localObject).nextFloat();
        f2 = f9;
        f3 = ((f)localObject).checkedNextFloat(f9);
        f1 = f3;
        if (Float.isNaN(f3))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 116)
        {
          f2 = f9 + f8;
          f1 = f3 + f7;
        }
        paramString.a(f10, f4, f2, f1);
        f3 = f1;
        f1 = f2;
        f2 = f10;
        break;
      case 83: 
      case 115: 
        f4 = ((f)localObject).nextFloat();
        f3 = ((f)localObject).checkedNextFloat(f4);
        f2 = ((f)localObject).checkedNextFloat(f3);
        f1 = ((f)localObject).checkedNextFloat(f2);
        if (Float.isNaN(f1))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 115)
        {
          f4 += f8;
          f3 += f7;
          f2 += f8;
          f1 += f7;
        }
        paramString.a(f8 * 2.0F - f10, 2.0F * f7 - f9, f4, f3, f2, f1);
        f7 = f4;
        f4 = f3;
        f3 = f1;
        f1 = f2;
        f2 = f7;
        break;
      case 81: 
      case 113: 
        f10 = ((f)localObject).nextFloat();
        f2 = f10;
        f9 = ((f)localObject).checkedNextFloat(f10);
        f4 = f9;
        float f12 = ((f)localObject).checkedNextFloat(f9);
        f3 = f12;
        f11 = ((f)localObject).checkedNextFloat(f12);
        f1 = f11;
        if (Float.isNaN(f11))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 113)
        {
          f3 = f12 + f8;
          f1 = f11 + f7;
          f2 = f10 + f8;
          f4 = f9 + f7;
        }
        paramString.a(f2, f4, f3, f1);
        f7 = f3;
        f3 = f1;
        f1 = f7;
        break;
      case 77: 
      case 109: 
        f6 = ((f)localObject).nextFloat();
        f1 = f6;
        f5 = ((f)localObject).checkedNextFloat(f6);
        f3 = f5;
        if (Float.isNaN(f5))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        f2 = f1;
        f4 = f3;
        if (i == 109)
        {
          f2 = f1;
          f4 = f3;
          if (!paramString.isEmpty())
          {
            f2 = f6 + f8;
            f4 = f5 + f7;
          }
        }
        paramString.b(f2, f4);
        if (i == 109) {
          i = j;
        } else {
          i = 76;
        }
        f1 = f2;
        f6 = f2;
        f3 = f4;
        f5 = f4;
        break;
      case 76: 
      case 108: 
        f3 = ((f)localObject).nextFloat();
        f2 = f3;
        f1 = ((f)localObject).checkedNextFloat(f3);
        f4 = f1;
        if (Float.isNaN(f1))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 108)
        {
          f2 = f3 + f8;
          f4 = f1 + f7;
        }
        paramString.a(f2, f4);
        f1 = f2;
        f3 = f4;
        break;
      case 72: 
      case 104: 
        f1 = ((f)localObject).nextFloat();
        f2 = f1;
        if (Float.isNaN(f1))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 104) {
          f2 = f1 + f8;
        }
        paramString.a(f2, f7);
        f1 = f2;
        f3 = f7;
        f4 = f9;
        break;
      case 67: 
      case 99: 
        f11 = ((f)localObject).nextFloat();
        f9 = f11;
        f10 = ((f)localObject).checkedNextFloat(f11);
        f4 = ((f)localObject).checkedNextFloat(f10);
        f3 = ((f)localObject).checkedNextFloat(f4);
        f2 = ((f)localObject).checkedNextFloat(f3);
        f1 = ((f)localObject).checkedNextFloat(f2);
        if (Float.isNaN(f1))
        {
          localObject = new StringBuilder();
          ((StringBuilder)localObject).append("Bad path coords for ");
          ((StringBuilder)localObject).append((char)i);
          ((StringBuilder)localObject).append(" path segment");
          Log.e("SVGParser", ((StringBuilder)localObject).toString());
          return paramString;
        }
        if (i == 99)
        {
          f2 += f8;
          f1 += f7;
          f9 = f11 + f8;
          f4 += f8;
          f8 = f10 + f7;
          f3 += f7;
          f7 = f8;
        }
        else
        {
          f7 = f10;
        }
        paramString.a(f9, f7, f4, f3, f2, f1);
        f7 = f4;
        f4 = f3;
        f3 = f1;
        f1 = f2;
        f2 = f7;
        break;
      case 65: 
      case 97: 
        f3 = ((f)localObject).nextFloat();
        f9 = ((f)localObject).checkedNextFloat(f3);
        f10 = ((f)localObject).checkedNextFloat(f9);
        Boolean localBoolean1 = ((f)localObject).checkedNextFlag(Float.valueOf(f10));
        Boolean localBoolean2 = ((f)localObject).checkedNextFlag(localBoolean1);
        f1 = ((f)localObject).checkedNextFloat(localBoolean2);
        f2 = ((f)localObject).checkedNextFloat(f1);
        f4 = f2;
        if ((Float.isNaN(f2)) || (f3 < 0.0F) || (f9 < 0.0F)) {
          break label1579;
        }
        if (i == 97)
        {
          f4 = f2 + f7;
          f1 += f8;
        }
        paramString.a(f3, f9, f10, localBoolean1.booleanValue(), localBoolean2.booleanValue(), f1, f4);
        f7 = f1;
        f3 = f4;
        f2 = f1;
        f1 = f7;
      }
      ((f)localObject).skipCommaWhitespace();
      if (((f)localObject).empty()) {
        return paramString;
      }
      if (((f)localObject).hasLetter())
      {
        i = ((f)localObject).nextChar().intValue();
        f8 = f1;
        f10 = f2;
        f7 = f3;
        f9 = f4;
      }
      else
      {
        f8 = f1;
        f10 = f2;
        f7 = f3;
        f9 = f4;
      }
    }
    label1579:
    localObject = new StringBuilder();
    ((StringBuilder)localObject).append("Bad path coords for ");
    ((StringBuilder)localObject).append((char)i);
    ((StringBuilder)localObject).append(" path segment");
    Log.e("SVGParser", ((StringBuilder)localObject).toString());
    return paramString;
  }
  
  static PreserveAspectRatio parsePreserveAspectRatio(String paramString)
    throws SVGParseException
  {
    f localF = new f(paramString);
    localF.skipWhitespace();
    Object localObject2 = localF.get();
    Object localObject1 = localObject2;
    if ("defer".equals(localObject2))
    {
      localF.skipWhitespace();
      localObject1 = localF.get();
    }
    localObject2 = a.get((String)localObject1);
    localObject1 = null;
    localF.skipWhitespace();
    if (!localF.empty())
    {
      localObject1 = localF.get();
      int i = -1;
      int j = ((String)localObject1).hashCode();
      if (j != 3347527)
      {
        if ((j == 109526418) && (((String)localObject1).equals("slice"))) {
          i = 1;
        }
      }
      else if (((String)localObject1).equals("meet")) {
        i = 0;
      }
      switch (i)
      {
      default: 
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append("Invalid preserveAspectRatio definition: ");
        ((StringBuilder)localObject1).append(paramString);
        throw new SVGParseException(((StringBuilder)localObject1).toString());
      case 1: 
        localObject1 = PreserveAspectRatio.Scale.slice;
        break;
      case 0: 
        localObject1 = PreserveAspectRatio.Scale.meet;
      }
    }
    return new PreserveAspectRatio((PreserveAspectRatio.Alignment)localObject2, (PreserveAspectRatio.Scale)localObject1);
  }
  
  private static void parsePreserveAspectRatio(SVG.am paramAm, String paramString)
    throws SVGParseException
  {
    preserveAspectRatio = parsePreserveAspectRatio(paramString);
  }
  
  private static Set parseRequiredFeatures(String paramString)
  {
    paramString = new f(paramString);
    HashSet localHashSet = new HashSet();
    while (!paramString.empty())
    {
      String str = paramString.get();
      if (str.startsWith("http://www.w3.org/TR/SVG11/feature#")) {
        localHashSet.add(str.substring(35));
      } else {
        localHashSet.add("UNSUPPORTED");
      }
      paramString.skipWhitespace();
    }
    return localHashSet;
  }
  
  private static Set parseRequiredFormats(String paramString)
  {
    paramString = new f(paramString);
    HashSet localHashSet = new HashSet();
    while (!paramString.empty())
    {
      localHashSet.add(paramString.get());
      paramString.skipWhitespace();
    }
    return localHashSet;
  }
  
  private static SVG.n[] parseStrokeDashArray(String paramString)
  {
    paramString = new f(paramString);
    paramString.skipWhitespace();
    if (paramString.empty()) {
      return null;
    }
    SVG.n localN = paramString.nextLength();
    if (localN == null) {
      return null;
    }
    if (localN.isNegative()) {
      return null;
    }
    float f = localN.floatValue();
    ArrayList localArrayList = new ArrayList();
    localArrayList.add(localN);
    while (!paramString.empty())
    {
      paramString.skipCommaWhitespace();
      localN = paramString.nextLength();
      if (localN == null) {
        return null;
      }
      if (localN.isNegative()) {
        return null;
      }
      localArrayList.add(localN);
      f += localN.floatValue();
    }
    if (f == 0.0F) {
      return null;
    }
    return (SVG.n[])localArrayList.toArray(new SVG.n[localArrayList.size()]);
  }
  
  private static SVG.Style.LineCap parseStrokeLineCap(String paramString)
  {
    if ("butt".equals(paramString)) {
      return SVG.Style.LineCap.Butt;
    }
    if ("round".equals(paramString)) {
      return SVG.Style.LineCap.Round;
    }
    if ("square".equals(paramString)) {
      return SVG.Style.LineCap.Square;
    }
    return null;
  }
  
  private static SVG.Style.LineJoin parseStrokeLineJoin(String paramString)
  {
    if ("miter".equals(paramString)) {
      return SVG.Style.LineJoin.Miter;
    }
    if ("round".equals(paramString)) {
      return SVG.Style.LineJoin.Round;
    }
    if ("bevel".equals(paramString)) {
      return SVG.Style.LineJoin.Bevel;
    }
    return null;
  }
  
  private static void parseStyle(SVG.ai paramAi, String paramString)
  {
    paramString = new f(paramString.replaceAll("/\\*.*?\\*/", ""));
    for (;;)
    {
      String str1 = paramString.nextToken(':');
      paramString.skipWhitespace();
      if (!paramString.consume(':')) {
        return;
      }
      paramString.skipWhitespace();
      String str2 = paramString.add(';');
      if (str2 == null) {
        return;
      }
      paramString.skipWhitespace();
      if ((paramString.empty()) || (paramString.consume(';')))
      {
        if (style == null) {
          style = new SVG.Style();
        }
        processStyleProperty(style, str1, str2);
        paramString.skipWhitespace();
      }
    }
  }
  
  private static Set parseSystemLanguage(String paramString)
  {
    f localF = new f(paramString);
    HashSet localHashSet = new HashSet();
    while (!localF.empty())
    {
      String str = localF.get();
      paramString = str;
      int i = str.indexOf('-');
      if (i != -1) {
        paramString = str.substring(0, i);
      }
      localHashSet.add(new Locale(paramString, "", "").getLanguage());
      localF.skipWhitespace();
    }
    return localHashSet;
  }
  
  private static SVG.Style.TextAnchor parseTextAnchor(String paramString)
  {
    int i = paramString.hashCode();
    if (i != -1074341483)
    {
      if (i != 100571)
      {
        if ((i == 109757538) && (paramString.equals("start")))
        {
          i = 0;
          break label76;
        }
      }
      else if (paramString.equals("end"))
      {
        i = 2;
        break label76;
      }
    }
    else if (paramString.equals("middle"))
    {
      i = 1;
      break label76;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 2: 
      return SVG.Style.TextAnchor.End;
    case 1: 
      label76:
      return SVG.Style.TextAnchor.Middle;
    }
    return SVG.Style.TextAnchor.Start;
  }
  
  private static SVG.Style.TextDecoration parseTextDecoration(String paramString)
  {
    switch (paramString.hashCode())
    {
    default: 
      break;
    case 529818312: 
      if (paramString.equals("overline")) {
        i = 2;
      }
      break;
    case 93826908: 
      if (paramString.equals("blink")) {
        i = 4;
      }
      break;
    case 3387192: 
      if (paramString.equals("none")) {
        i = 0;
      }
      break;
    case -1026963764: 
      if (paramString.equals("underline")) {
        i = 1;
      }
      break;
    case -1171789332: 
      if (paramString.equals("line-through")) {
        i = 3;
      }
      break;
    }
    int i = -1;
    switch (i)
    {
    default: 
      return null;
    case 4: 
      return SVG.Style.TextDecoration.Blink;
    case 3: 
      return SVG.Style.TextDecoration.LineThrough;
    case 2: 
      return SVG.Style.TextDecoration.Overline;
    case 1: 
      return SVG.Style.TextDecoration.Underline;
    }
    return SVG.Style.TextDecoration.None;
  }
  
  private static SVG.Style.TextDirection parseTextDirection(String paramString)
  {
    int i = paramString.hashCode();
    if (i != 107498)
    {
      if ((i == 113258) && (paramString.equals("rtl")))
      {
        i = 1;
        break label54;
      }
    }
    else if (paramString.equals("ltr"))
    {
      i = 0;
      break label54;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 1: 
      label54:
      return SVG.Style.TextDirection.RTL;
    }
    return SVG.Style.TextDirection.LTR;
  }
  
  private Matrix parseTransformList(String paramString)
    throws SVGParseException
  {
    Object localObject1 = new Matrix();
    f localF = new f(paramString);
    localF.skipWhitespace();
    while (!localF.empty())
    {
      Object localObject2 = localF.nextFunction();
      if (localObject2 != null)
      {
        int i = -1;
        switch (((String)localObject2).hashCode())
        {
        default: 
          break;
        case 1052832078: 
          if (((String)localObject2).equals("translate")) {
            i = 1;
          }
          break;
        case 109493391: 
          if (((String)localObject2).equals("skewY")) {
            i = 5;
          }
          break;
        case 109493390: 
          if (((String)localObject2).equals("skewX")) {
            i = 4;
          }
          break;
        case 109250890: 
          if (((String)localObject2).equals("scale")) {
            i = 2;
          }
          break;
        case -925180581: 
          if (((String)localObject2).equals("rotate")) {
            i = 3;
          }
          break;
        case -1081239615: 
          if (((String)localObject2).equals("matrix")) {
            i = 0;
          }
          break;
        }
        float f1;
        float f2;
        float f3;
        switch (i)
        {
        default: 
          paramString = new StringBuilder();
          paramString.append("Invalid transform list fn: ");
          paramString.append((String)localObject2);
          paramString.append(")");
          throw new SVGParseException(paramString.toString());
        case 5: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          localF.skipWhitespace();
          if ((!Float.isNaN(f1)) && (localF.consume(')')))
          {
            ((Matrix)localObject1).preSkew(0.0F, (float)Math.tan(Math.toRadians(f1)));
          }
          else
          {
            localObject1 = new StringBuilder();
            ((StringBuilder)localObject1).append("Invalid transform list: ");
            ((StringBuilder)localObject1).append(paramString);
            throw new SVGParseException(((StringBuilder)localObject1).toString());
          }
          break;
        case 4: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          localF.skipWhitespace();
          if ((!Float.isNaN(f1)) && (localF.consume(')')))
          {
            ((Matrix)localObject1).preSkew((float)Math.tan(Math.toRadians(f1)), 0.0F);
          }
          else
          {
            localObject1 = new StringBuilder();
            ((StringBuilder)localObject1).append("Invalid transform list: ");
            ((StringBuilder)localObject1).append(paramString);
            throw new SVGParseException(((StringBuilder)localObject1).toString());
          }
          break;
        case 3: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          f2 = localF.possibleNextFloat();
          f3 = localF.possibleNextFloat();
          localF.skipWhitespace();
          if ((!Float.isNaN(f1)) && (localF.consume(')')))
          {
            if (Float.isNaN(f2))
            {
              ((Matrix)localObject1).preRotate(f1);
            }
            else if (!Float.isNaN(f3))
            {
              ((Matrix)localObject1).preRotate(f1, f2, f3);
            }
            else
            {
              localObject1 = new StringBuilder();
              ((StringBuilder)localObject1).append("Invalid transform list: ");
              ((StringBuilder)localObject1).append(paramString);
              throw new SVGParseException(((StringBuilder)localObject1).toString());
            }
          }
          else
          {
            localObject1 = new StringBuilder();
            ((StringBuilder)localObject1).append("Invalid transform list: ");
            ((StringBuilder)localObject1).append(paramString);
            throw new SVGParseException(((StringBuilder)localObject1).toString());
          }
          break;
        case 2: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          f2 = localF.possibleNextFloat();
          localF.skipWhitespace();
          if ((!Float.isNaN(f1)) && (localF.consume(')')))
          {
            if (Float.isNaN(f2)) {
              ((Matrix)localObject1).preScale(f1, f1);
            } else {
              ((Matrix)localObject1).preScale(f1, f2);
            }
          }
          else
          {
            localObject1 = new StringBuilder();
            ((StringBuilder)localObject1).append("Invalid transform list: ");
            ((StringBuilder)localObject1).append(paramString);
            throw new SVGParseException(((StringBuilder)localObject1).toString());
          }
          break;
        case 1: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          f2 = localF.possibleNextFloat();
          localF.skipWhitespace();
          if ((!Float.isNaN(f1)) && (localF.consume(')')))
          {
            if (Float.isNaN(f2)) {
              ((Matrix)localObject1).preTranslate(f1, 0.0F);
            } else {
              ((Matrix)localObject1).preTranslate(f1, f2);
            }
          }
          else
          {
            localObject1 = new StringBuilder();
            ((StringBuilder)localObject1).append("Invalid transform list: ");
            ((StringBuilder)localObject1).append(paramString);
            throw new SVGParseException(((StringBuilder)localObject1).toString());
          }
          break;
        case 0: 
          localF.skipWhitespace();
          f1 = localF.nextFloat();
          localF.skipCommaWhitespace();
          f2 = localF.nextFloat();
          localF.skipCommaWhitespace();
          f3 = localF.nextFloat();
          localF.skipCommaWhitespace();
          float f4 = localF.nextFloat();
          localF.skipCommaWhitespace();
          float f5 = localF.nextFloat();
          localF.skipCommaWhitespace();
          float f6 = localF.nextFloat();
          localF.skipWhitespace();
          if ((Float.isNaN(f6)) || (!localF.consume(')'))) {
            break label1063;
          }
          localObject2 = new Matrix();
          ((Matrix)localObject2).setValues(new float[] { f1, f3, f5, f2, f4, f6, 0.0F, 0.0F, 1.06535322E9F });
          ((Matrix)localObject1).preConcat((Matrix)localObject2);
        }
        if (localF.empty()) {
          return localObject1;
        }
        localF.skipCommaWhitespace();
        continue;
        label1063:
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append("Invalid transform list: ");
        ((StringBuilder)localObject1).append(paramString);
        throw new SVGParseException(((StringBuilder)localObject1).toString());
      }
      else
      {
        localObject1 = new StringBuilder();
        ((StringBuilder)localObject1).append("Bad transform function encountered in transform list: ");
        ((StringBuilder)localObject1).append(paramString);
        throw new SVGParseException(((StringBuilder)localObject1).toString());
      }
    }
    return localObject1;
  }
  
  private static SVG.Style.VectorEffect parseVectorEffect(String paramString)
  {
    int i = paramString.hashCode();
    if (i != 3387192)
    {
      if ((i == 1629199934) && (paramString.equals("non-scaling-stroke")))
      {
        i = 1;
        break label54;
      }
    }
    else if (paramString.equals("none"))
    {
      i = 0;
      break label54;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 1: 
      label54:
      return SVG.Style.VectorEffect.NonScalingStroke;
    }
    return SVG.Style.VectorEffect.None;
  }
  
  private static SVG.a parseViewBox(String paramString)
    throws SVGParseException
  {
    paramString = new f(paramString);
    paramString.skipWhitespace();
    float f1 = paramString.nextFloat();
    paramString.skipCommaWhitespace();
    float f2 = paramString.nextFloat();
    paramString.skipCommaWhitespace();
    float f3 = paramString.nextFloat();
    paramString.skipCommaWhitespace();
    float f4 = paramString.nextFloat();
    if ((!Float.isNaN(f1)) && (!Float.isNaN(f2)) && (!Float.isNaN(f3)) && (!Float.isNaN(f4)))
    {
      if (f3 >= 0.0F)
      {
        if (f4 >= 0.0F) {
          return new SVG.a(f1, f2, f3, f4);
        }
        throw new SVGParseException("Invalid viewBox. height cannot be negative");
      }
      throw new SVGParseException("Invalid viewBox. width cannot be negative");
    }
    throw new SVGParseException("Invalid viewBox definition - should have four numbers");
  }
  
  private void path(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<path>", new Object[0]);
    if (currentElement != null)
    {
      SVG.t localT = new SVG.t();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localT, paramAttributes);
      parseAttributesStyle(localT, paramAttributes);
      parseAttributesTransform(localT, paramAttributes);
      parseAttributesConditional(localT, paramAttributes);
      parseAttributesPath(localT, paramAttributes);
      currentElement.addChild(localT);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void pattern(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<pattern>", new Object[0]);
    if (currentElement != null)
    {
      SVG.w localW = new SVG.w();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localW, paramAttributes);
      parseAttributesStyle(localW, paramAttributes);
      parseAttributesConditional(localW, paramAttributes);
      parseAttributesViewBox(localW, paramAttributes);
      parseAttributesPattern(localW, paramAttributes);
      currentElement.addChild(localW);
      currentElement = localW;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void polygon(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<polygon>", new Object[0]);
    if (currentElement != null)
    {
      SVG.y localY = new SVG.y();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localY, paramAttributes);
      parseAttributesStyle(localY, paramAttributes);
      parseAttributesTransform(localY, paramAttributes);
      parseAttributesConditional(localY, paramAttributes);
      parseAttributesPolyLine(localY, paramAttributes, "polygon");
      currentElement.addChild(localY);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void polyline(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<polyline>", new Object[0]);
    if (currentElement != null)
    {
      SVG.x localX = new SVG.x();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localX, paramAttributes);
      parseAttributesStyle(localX, paramAttributes);
      parseAttributesTransform(localX, paramAttributes);
      parseAttributesConditional(localX, paramAttributes);
      parseAttributesPolyLine(localX, paramAttributes, "polyline");
      currentElement.addChild(localX);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  static void processStyleProperty(SVG.Style paramStyle, String paramString1, String paramString2)
  {
    if (paramString2.length() == 0) {
      return;
    }
    if (paramString2.equals("inherit")) {
      return;
    }
    switch (1.height[SVGAttr.fromString(paramString1).ordinal()])
    {
    default: 
      return;
    case 86: 
      style = fromString(paramString2);
      if (style == null) {
        return;
      }
      specifiedFlags |= 0x2000000000;
      return;
    case 85: 
      vectorEffect = parseVectorEffect(paramString2);
      if (vectorEffect == null) {
        return;
      }
      specifiedFlags |= 0x800000000;
      return;
    case 84: 
      viewportFillOpacity = valueOf(paramString2);
      specifiedFlags |= 0x400000000;
      return;
    case 83: 
      if (paramString2.equals("currentColor")) {
        viewportFill = SVG.f.parseColour();
      }
      try
      {
        paramString1 = parseColour(paramString2);
        viewportFill = paramString1;
        specifiedFlags |= 0x200000000;
        return;
      }
      catch (SVGParseException paramStyle)
      {
        Log.w("SVGParser", paramStyle.getMessage());
        return;
      }
    case 82: 
      solidOpacity = valueOf(paramString2);
      specifiedFlags |= 0x100000000;
      return;
    case 81: 
      if (paramString2.equals("currentColor")) {
        solidColor = SVG.f.parseColour();
      }
      try
      {
        paramString1 = parseColour(paramString2);
        solidColor = paramString1;
        specifiedFlags |= 0x80000000;
        return;
      }
      catch (SVGParseException paramStyle)
      {
        Log.w("SVGParser", paramStyle.getMessage());
        return;
      }
    case 80: 
      mask = parseFunctionalIRI(paramString2, paramString1);
      specifiedFlags |= 0x40000000;
      return;
    case 79: 
      clipRule = parseFillRule(paramString2);
      specifiedFlags |= 0x20000000;
      return;
    case 78: 
      clipPath = parseFunctionalIRI(paramString2, paramString1);
      specifiedFlags |= 0x10000000;
      return;
    case 77: 
      clip = parseClip(paramString2);
      if (clip == null) {
        return;
      }
      specifiedFlags |= 0x100000;
      return;
    case 76: 
      stopOpacity = valueOf(paramString2);
      specifiedFlags |= 0x8000000;
      return;
    case 75: 
      if (paramString2.equals("currentColor")) {
        stopColor = SVG.f.parseColour();
      }
      try
      {
        paramString1 = parseColour(paramString2);
        stopColor = paramString1;
        specifiedFlags |= 0x4000000;
        return;
      }
      catch (SVGParseException paramStyle)
      {
        Log.w("SVGParser", paramStyle.getMessage());
        return;
      }
    case 74: 
      if (paramString2.indexOf('|') >= 0) {
        return;
      }
      paramString1 = new StringBuilder();
      paramString1.append('|');
      paramString1.append(paramString2);
      paramString1.append('|');
      if (!"|visible|hidden|collapse|".contains(paramString1.toString())) {
        return;
      }
      visibility = Boolean.valueOf(paramString2.equals("visible"));
      specifiedFlags |= 0x2000000;
      return;
    case 73: 
      if (paramString2.indexOf('|') >= 0) {
        return;
      }
      paramString1 = new StringBuilder();
      paramString1.append('|');
      paramString1.append(paramString2);
      paramString1.append('|');
      if (!"|inline|block|list-item|run-in|compact|marker|table|inline-table|table-row-group|table-header-group|table-footer-group|table-row|table-column-group|table-column|table-cell|table-caption|none|".contains(paramString1.toString())) {
        return;
      }
      display = Boolean.valueOf(paramString2.equals("none") ^ true);
      specifiedFlags |= 0x1000000;
      return;
    case 72: 
      markerEnd = parseFunctionalIRI(paramString2, paramString1);
      specifiedFlags |= 0x800000;
      return;
    case 71: 
      markerMid = parseFunctionalIRI(paramString2, paramString1);
      specifiedFlags |= 0x400000;
      return;
    case 70: 
      markerStart = parseFunctionalIRI(paramString2, paramString1);
      specifiedFlags |= 0x200000;
      return;
    case 69: 
      markerStart = parseFunctionalIRI(paramString2, paramString1);
      markerMid = markerStart;
      markerEnd = markerStart;
      specifiedFlags |= 0xE00000;
      return;
    case 68: 
      overflow = parse(paramString2);
      if (overflow == null) {
        return;
      }
      specifiedFlags |= 0x80000;
      return;
    case 67: 
      textAnchor = parseTextAnchor(paramString2);
      if (textAnchor == null) {
        return;
      }
      specifiedFlags |= 0x40000;
      return;
    case 66: 
      direction = parseTextDirection(paramString2);
      if (direction == null) {
        return;
      }
      specifiedFlags |= 0x1000000000;
      return;
    case 65: 
      textDecoration = parseTextDecoration(paramString2);
      if (textDecoration == null) {
        return;
      }
      specifiedFlags |= 0x20000;
      return;
    case 64: 
      fontStyle = fontStyleKeyword(paramString2);
      if (fontStyle == null) {
        return;
      }
      specifiedFlags |= 0x10000;
      return;
    case 63: 
      fontWeight = parseFontWeight(paramString2);
      if (fontWeight == null) {
        return;
      }
      specifiedFlags |= 0x8000;
      return;
    case 62: 
      fontSize = parseFontSize(paramString2);
      if (fontSize == null) {
        return;
      }
      specifiedFlags |= 0x4000;
      return;
    case 61: 
      fontFamily = parseFontFamily(paramString2);
      if (fontFamily == null) {
        return;
      }
      specifiedFlags |= 0x2000;
      return;
    case 60: 
      parseFont(paramStyle, paramString2);
      return;
    }
    try
    {
      paramString1 = parseColour(paramString2);
      color = paramString1;
      specifiedFlags |= 0x1000;
      return;
    }
    catch (SVGParseException paramStyle)
    {
      return;
    }
    opacity = valueOf(paramString2);
    specifiedFlags |= 0x800;
    return;
    try
    {
      paramString1 = parseLength(paramString2);
      strokeDashOffset = paramString1;
      specifiedFlags |= 0x400;
      return;
    }
    catch (SVGParseException paramStyle)
    {
      return;
    }
    if ("none".equals(paramString2))
    {
      strokeDashArray = null;
      specifiedFlags |= 0x200;
      return;
    }
    strokeDashArray = parseStrokeDashArray(paramString2);
    if (strokeDashArray != null)
    {
      specifiedFlags |= 0x200;
      return;
      try
      {
        float f = parseFloat(paramString2);
        strokeMiterLimit = Float.valueOf(f);
        specifiedFlags |= 0x100;
        return;
      }
      catch (SVGParseException paramStyle)
      {
        return;
      }
      strokeLineJoin = parseStrokeLineJoin(paramString2);
      if (strokeLineJoin != null)
      {
        specifiedFlags |= 0x80;
        return;
        strokeLineCap = parseStrokeLineCap(paramString2);
        if (strokeLineCap != null)
        {
          specifiedFlags |= 0x40;
          return;
          try
          {
            paramString1 = parseLength(paramString2);
            strokeWidth = paramString1;
            specifiedFlags |= 0x20;
            return;
          }
          catch (SVGParseException paramStyle) {}
          strokeOpacity = valueOf(paramString2);
          if (strokeOpacity != null)
          {
            specifiedFlags |= 0x10;
            return;
            stroke = parsePaintSpecifier(paramString2);
            if (stroke != null)
            {
              specifiedFlags |= 0x8;
              return;
              fillOpacity = valueOf(paramString2);
              if (fillOpacity != null)
              {
                specifiedFlags |= 0x4;
                return;
                fillRule = parseFillRule(paramString2);
                if (fillRule != null)
                {
                  specifiedFlags |= 0x2;
                  return;
                  fill = parsePaintSpecifier(paramString2);
                  if (fill != null)
                  {
                    specifiedFlags |= 1L;
                    return;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  private void radialGradient(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<radialGradient>", new Object[0]);
    if (currentElement != null)
    {
      SVG.an localAn = new SVG.an();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAn, paramAttributes);
      parseAttributesStyle(localAn, paramAttributes);
      parseAttributesGradient(localAn, paramAttributes);
      parseAttributesRadialGradient(localAn, paramAttributes);
      currentElement.addChild(localAn);
      currentElement = localAn;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void rect(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<rect>", new Object[0]);
    if (currentElement != null)
    {
      SVG.z localZ = new SVG.z();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localZ, paramAttributes);
      parseAttributesStyle(localZ, paramAttributes);
      parseAttributesTransform(localZ, paramAttributes);
      parseAttributesConditional(localZ, paramAttributes);
      parseAttributesRect(localZ, paramAttributes);
      currentElement.addChild(localZ);
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void solidColor(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<solidColor>", new Object[0]);
    if (currentElement != null)
    {
      SVG.aa localAa = new SVG.aa();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAa, paramAttributes);
      parseAttributesStyle(localAa, paramAttributes);
      currentElement.addChild(localAa);
      currentElement = localAa;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void startElement(String paramString1, String paramString2, String paramString3, Attributes paramAttributes)
    throws SVGParseException
  {
    if (ignoring)
    {
      ignoreDepth += 1;
      return;
    }
    if ((!"http://www.w3.org/2000/svg".equals(paramString1)) && (!"".equals(paramString1))) {
      return;
    }
    if (paramString2.length() <= 0) {
      paramString2 = paramString3;
    }
    paramString1 = SVGElem.fromString(paramString2);
    switch (1.this$0[paramString1.ordinal()])
    {
    default: 
      ignoring = true;
      ignoreDepth = 1;
      return;
    case 31: 
      solidColor(paramAttributes);
      return;
    case 30: 
      style(paramAttributes);
      return;
    case 29: 
      mask(paramAttributes);
      return;
    case 28: 
      view(paramAttributes);
      return;
    case 27: 
      image(paramAttributes);
      return;
    case 26: 
      pattern(paramAttributes);
      return;
    case 25: 
      textPath(paramAttributes);
      return;
    case 24: 
      clipPath(paramAttributes);
      return;
    case 22: 
    case 23: 
      inMetadataElement = true;
      metadataTag = paramString1;
      return;
    case 21: 
      stop(paramAttributes);
      return;
    case 20: 
      radialGradient(paramAttributes);
      return;
    case 19: 
      linearGradient(paramAttributes);
      return;
    case 18: 
      marker(paramAttributes);
      return;
    case 17: 
      symbol(paramAttributes);
      return;
    case 16: 
      zwitch(paramAttributes);
      return;
    case 15: 
      tref(paramAttributes);
      return;
    case 14: 
      tspan(paramAttributes);
      return;
    case 13: 
      text(paramAttributes);
      return;
    case 12: 
      polygon(paramAttributes);
      return;
    case 11: 
      polyline(paramAttributes);
      return;
    case 10: 
      line(paramAttributes);
      return;
    case 9: 
      ellipse(paramAttributes);
      return;
    case 8: 
      circle(paramAttributes);
      return;
    case 7: 
      rect(paramAttributes);
      return;
    case 6: 
      path(paramAttributes);
      return;
    case 5: 
      use(paramAttributes);
      return;
    case 4: 
      defs(paramAttributes);
      return;
    case 2: 
    case 3: 
      g(paramAttributes);
      return;
    }
    svg(paramAttributes);
  }
  
  private void stop(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<stop>", new Object[0]);
    Object localObject = currentElement;
    if (localObject != null)
    {
      if ((localObject instanceof SVG.i))
      {
        localObject = new SVG.ab();
        document = svgDocument;
        parent = currentElement;
        parseAttributesCore((SVG.ai)localObject, paramAttributes);
        parseAttributesStyle((SVG.ai)localObject, paramAttributes);
        parseAttributesStop((SVG.ab)localObject, paramAttributes);
        currentElement.addChild((SVG.ak)localObject);
        currentElement = ((SVG.ag)localObject);
        return;
      }
      throw new SVGParseException("Invalid document. <stop> elements are only valid inside <linearGradient> or <radialGradient> elements.");
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void style(Attributes paramAttributes)
    throws SVGParseException
  {
    int i = 0;
    debug("<style>", new Object[0]);
    if (currentElement != null)
    {
      Object localObject = "all";
      boolean bool = true;
      while (i < paramAttributes.getLength())
      {
        String str = paramAttributes.getValue(i).trim();
        switch (1.height[SVGAttr.fromString(paramAttributes.getLocalName(i)).ordinal()])
        {
        default: 
          break;
        case 89: 
          localObject = str;
          break;
        case 88: 
          bool = str.equals("text/css");
        }
        i += 1;
      }
      if ((bool) && (CSSParser.mediaMatches((String)localObject, CSSParser.MediaType.screen)))
      {
        inStyleElement = true;
        return;
      }
      ignoring = true;
      ignoreDepth = 1;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void svg(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<svg>", new Object[0]);
    SVG.ac localAc = new SVG.ac();
    document = svgDocument;
    parent = currentElement;
    parseAttributesCore(localAc, paramAttributes);
    parseAttributesStyle(localAc, paramAttributes);
    parseAttributesConditional(localAc, paramAttributes);
    parseAttributesViewBox(localAc, paramAttributes);
    parseAttributesSVG(localAc, paramAttributes);
    paramAttributes = currentElement;
    if (paramAttributes == null) {
      svgDocument.setRootElement(localAc);
    } else {
      paramAttributes.addChild(localAc);
    }
    currentElement = localAc;
  }
  
  private void symbol(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<symbol>", new Object[0]);
    if (currentElement != null)
    {
      SVG.aq localAq = new SVG.aq();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAq, paramAttributes);
      parseAttributesStyle(localAq, paramAttributes);
      parseAttributesConditional(localAq, paramAttributes);
      parseAttributesViewBox(localAq, paramAttributes);
      currentElement.addChild(localAq);
      currentElement = localAq;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void text(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<text>", new Object[0]);
    if (currentElement != null)
    {
      SVG.at localAt = new SVG.at();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAt, paramAttributes);
      parseAttributesStyle(localAt, paramAttributes);
      parseAttributesTransform(localAt, paramAttributes);
      parseAttributesConditional(localAt, paramAttributes);
      parseAttributesTextPosition(localAt, paramAttributes);
      currentElement.addChild(localAt);
      currentElement = localAt;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void textPath(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<textPath>", new Object[0]);
    if (currentElement != null)
    {
      SVG.aw localAw = new SVG.aw();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAw, paramAttributes);
      parseAttributesStyle(localAw, paramAttributes);
      parseAttributesConditional(localAw, paramAttributes);
      parseAttributesPattern(localAw, paramAttributes);
      currentElement.addChild(localAw);
      currentElement = localAw;
      if ((parent instanceof SVG.ay))
      {
        localAw.b((SVG.ay)parent);
        return;
      }
      localAw.b(((SVG.au)parent).n());
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void tref(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<tref>", new Object[0]);
    Object localObject = currentElement;
    if (localObject != null)
    {
      if ((localObject instanceof SVG.av))
      {
        localObject = new SVG.ar();
        document = svgDocument;
        parent = currentElement;
        parseAttributesCore((SVG.ai)localObject, paramAttributes);
        parseAttributesStyle((SVG.ai)localObject, paramAttributes);
        parseAttributesConditional((SVG.ad)localObject, paramAttributes);
        parseAttributesPattern((SVG.ar)localObject, paramAttributes);
        currentElement.addChild((SVG.ak)localObject);
        if ((parent instanceof SVG.ay))
        {
          ((SVG.ar)localObject).b((SVG.ay)parent);
          return;
        }
        ((SVG.ar)localObject).b(((SVG.au)parent).n());
        return;
      }
      throw new SVGParseException("Invalid document. <tref> elements are only valid inside <text> or <tspan> elements.");
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void tspan(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<tspan>", new Object[0]);
    Object localObject = currentElement;
    if (localObject != null)
    {
      if ((localObject instanceof SVG.av))
      {
        localObject = new SVG.as();
        document = svgDocument;
        parent = currentElement;
        parseAttributesCore((SVG.ai)localObject, paramAttributes);
        parseAttributesStyle((SVG.ai)localObject, paramAttributes);
        parseAttributesConditional((SVG.ad)localObject, paramAttributes);
        parseAttributesTextPosition((SVG.ax)localObject, paramAttributes);
        currentElement.addChild((SVG.ak)localObject);
        currentElement = ((SVG.ag)localObject);
        if ((parent instanceof SVG.ay))
        {
          ((SVG.as)localObject).b((SVG.ay)parent);
          return;
        }
        ((SVG.as)localObject).b(((SVG.au)parent).n());
        return;
      }
      throw new SVGParseException("Invalid document. <tspan> elements are only valid inside <text> or other <tspan> elements.");
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void use(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<use>", new Object[0]);
    if (currentElement != null)
    {
      SVG.ba localBa = new SVG.ba();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localBa, paramAttributes);
      parseAttributesStyle(localBa, paramAttributes);
      parseAttributesTransform(localBa, paramAttributes);
      parseAttributesConditional(localBa, paramAttributes);
      parseAttributesUse(localBa, paramAttributes);
      currentElement.addChild(localBa);
      currentElement = localBa;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private static Float valueOf(String paramString)
  {
    try
    {
      float f2 = parseFloat(paramString);
      float f1 = f2;
      if (f2 < 0.0F) {
        f1 = 0.0F;
      } else if (f2 > 1.0F) {
        f1 = 1.0F;
      }
      return Float.valueOf(f1);
    }
    catch (SVGParseException paramString)
    {
      for (;;) {}
    }
    return null;
  }
  
  private void view(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<view>", new Object[0]);
    if (currentElement != null)
    {
      SVG.bb localBb = new SVG.bb();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localBb, paramAttributes);
      parseAttributesConditional(localBb, paramAttributes);
      parseAttributesViewBox(localBb, paramAttributes);
      currentElement.addChild(localBb);
      currentElement = localBb;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  private void zwitch(Attributes paramAttributes)
    throws SVGParseException
  {
    debug("<switch>", new Object[0]);
    if (currentElement != null)
    {
      SVG.ap localAp = new SVG.ap();
      document = svgDocument;
      parent = currentElement;
      parseAttributesCore(localAp, paramAttributes);
      parseAttributesStyle(localAp, paramAttributes);
      parseAttributesTransform(localAp, paramAttributes);
      parseAttributesConditional(localAp, paramAttributes);
      currentElement.addChild(localAp);
      currentElement = localAp;
      return;
    }
    throw new SVGParseException("Invalid document. Root element must be <svg>");
  }
  
  SVG load(InputStream paramInputStream, boolean paramBoolean)
    throws SVGParseException
  {
    Object localObject = paramInputStream;
    if (!((InputStream)paramInputStream).markSupported()) {
      localObject = new BufferedInputStream((InputStream)paramInputStream);
    }
    paramInputStream = (InputStream)localObject;
    for (;;)
    {
      try
      {
        paramInputStream.mark(3);
        paramInputStream = (InputStream)localObject;
        int i = paramInputStream.read();
        paramInputStream = (InputStream)localObject;
        int j = paramInputStream.read();
        paramInputStream = (InputStream)localObject;
        paramInputStream.reset();
        paramInputStream = (InputStream)localObject;
        if (i + (j << 8) == 35615)
        {
          paramInputStream = (InputStream)localObject;
          paramInputStream = new BufferedInputStream(new GZIPInputStream(paramInputStream));
        }
      }
      catch (IOException paramInputStream)
      {
        paramInputStream = localThrowable;
        continue;
      }
      try
      {
        ((InputStream)paramInputStream).mark(4096);
        parse((InputStream)paramInputStream, paramBoolean);
        paramInputStream = (InputStream)paramInputStream;
      }
      catch (Throwable localThrowable)
      {
        paramInputStream = (InputStream)paramInputStream;
      }
      try
      {
        paramInputStream.close();
      }
      catch (IOException paramInputStream) {}
    }
    Log.e("SVGParser", "Exception thrown closing input stream");
    return svgDocument;
    try
    {
      paramInputStream.close();
    }
    catch (IOException paramInputStream)
    {
      for (;;) {}
    }
    Log.e("SVGParser", "Exception thrown closing input stream");
    throw localThrowable;
  }
  
  private static enum SVGAttr
  {
    private static final Map<String, SVGAttr> cache;
    
    static
    {
      int i = 0;
      CLASS = new SVGAttr("CLASS", 0);
      clip = new SVGAttr("clip", 1);
      clip_path = new SVGAttr("clip_path", 2);
      clipPathUnits = new SVGAttr("clipPathUnits", 3);
      clip_rule = new SVGAttr("clip_rule", 4);
      color = new SVGAttr("color", 5);
      cx = new SVGAttr("cx", 6);
      cy = new SVGAttr("cy", 7);
      direction = new SVGAttr("direction", 8);
      dx = new SVGAttr("dx", 9);
      dy = new SVGAttr("dy", 10);
      fx = new SVGAttr("fx", 11);
      fy = new SVGAttr("fy", 12);
      d = new SVGAttr("d", 13);
      display = new SVGAttr("display", 14);
      fill = new SVGAttr("fill", 15);
      fill_rule = new SVGAttr("fill_rule", 16);
      fill_opacity = new SVGAttr("fill_opacity", 17);
      font = new SVGAttr("font", 18);
      font_family = new SVGAttr("font_family", 19);
      font_size = new SVGAttr("font_size", 20);
      font_weight = new SVGAttr("font_weight", 21);
      font_style = new SVGAttr("font_style", 22);
      gradientTransform = new SVGAttr("gradientTransform", 23);
      gradientUnits = new SVGAttr("gradientUnits", 24);
      height = new SVGAttr("height", 25);
      href = new SVGAttr("href", 26);
      image_rendering = new SVGAttr("image_rendering", 27);
      marker = new SVGAttr("marker", 28);
      marker_start = new SVGAttr("marker_start", 29);
      marker_mid = new SVGAttr("marker_mid", 30);
      marker_end = new SVGAttr("marker_end", 31);
      markerHeight = new SVGAttr("markerHeight", 32);
      markerUnits = new SVGAttr("markerUnits", 33);
      markerWidth = new SVGAttr("markerWidth", 34);
      mask = new SVGAttr("mask", 35);
      maskContentUnits = new SVGAttr("maskContentUnits", 36);
      maskUnits = new SVGAttr("maskUnits", 37);
      media = new SVGAttr("media", 38);
      offset = new SVGAttr("offset", 39);
      opacity = new SVGAttr("opacity", 40);
      orient = new SVGAttr("orient", 41);
      overflow = new SVGAttr("overflow", 42);
      pathLength = new SVGAttr("pathLength", 43);
      patternContentUnits = new SVGAttr("patternContentUnits", 44);
      patternTransform = new SVGAttr("patternTransform", 45);
      patternUnits = new SVGAttr("patternUnits", 46);
      points = new SVGAttr("points", 47);
      preserveAspectRatio = new SVGAttr("preserveAspectRatio", 48);
      r = new SVGAttr("r", 49);
      refX = new SVGAttr("refX", 50);
      refY = new SVGAttr("refY", 51);
      requiredFeatures = new SVGAttr("requiredFeatures", 52);
      requiredExtensions = new SVGAttr("requiredExtensions", 53);
      requiredFormats = new SVGAttr("requiredFormats", 54);
      requiredFonts = new SVGAttr("requiredFonts", 55);
      rx = new SVGAttr("rx", 56);
      ry = new SVGAttr("ry", 57);
      solid_color = new SVGAttr("solid_color", 58);
      solid_opacity = new SVGAttr("solid_opacity", 59);
      spreadMethod = new SVGAttr("spreadMethod", 60);
      startOffset = new SVGAttr("startOffset", 61);
      stop_color = new SVGAttr("stop_color", 62);
      stop_opacity = new SVGAttr("stop_opacity", 63);
      stroke = new SVGAttr("stroke", 64);
      stroke_dasharray = new SVGAttr("stroke_dasharray", 65);
      stroke_dashoffset = new SVGAttr("stroke_dashoffset", 66);
      stroke_linecap = new SVGAttr("stroke_linecap", 67);
      stroke_linejoin = new SVGAttr("stroke_linejoin", 68);
      stroke_miterlimit = new SVGAttr("stroke_miterlimit", 69);
      stroke_opacity = new SVGAttr("stroke_opacity", 70);
      stroke_width = new SVGAttr("stroke_width", 71);
      style = new SVGAttr("style", 72);
      systemLanguage = new SVGAttr("systemLanguage", 73);
      text_anchor = new SVGAttr("text_anchor", 74);
      text_decoration = new SVGAttr("text_decoration", 75);
      transform = new SVGAttr("transform", 76);
      type = new SVGAttr("type", 77);
      vector_effect = new SVGAttr("vector_effect", 78);
      version = new SVGAttr("version", 79);
      viewBox = new SVGAttr("viewBox", 80);
      width = new SVGAttr("width", 81);
      x = new SVGAttr("x", 82);
      y = new SVGAttr("y", 83);
      x1 = new SVGAttr("x1", 84);
      y1 = new SVGAttr("y1", 85);
      x2 = new SVGAttr("x2", 86);
      y2 = new SVGAttr("y2", 87);
      viewport_fill = new SVGAttr("viewport_fill", 88);
      viewport_fill_opacity = new SVGAttr("viewport_fill_opacity", 89);
      visibility = new SVGAttr("visibility", 90);
      UNSUPPORTED = new SVGAttr("UNSUPPORTED", 91);
      $VALUES = new SVGAttr[] { CLASS, clip, clip_path, clipPathUnits, clip_rule, color, cx, cy, direction, dx, dy, fx, fy, d, display, fill, fill_rule, fill_opacity, font, font_family, font_size, font_weight, font_style, gradientTransform, gradientUnits, height, href, image_rendering, marker, marker_start, marker_mid, marker_end, markerHeight, markerUnits, markerWidth, mask, maskContentUnits, maskUnits, media, offset, opacity, orient, overflow, pathLength, patternContentUnits, patternTransform, patternUnits, points, preserveAspectRatio, r, refX, refY, requiredFeatures, requiredExtensions, requiredFormats, requiredFonts, rx, ry, solid_color, solid_opacity, spreadMethod, startOffset, stop_color, stop_opacity, stroke, stroke_dasharray, stroke_dashoffset, stroke_linecap, stroke_linejoin, stroke_miterlimit, stroke_opacity, stroke_width, style, systemLanguage, text_anchor, text_decoration, transform, type, vector_effect, version, viewBox, width, x, y, x1, y1, x2, y2, viewport_fill, viewport_fill_opacity, visibility, UNSUPPORTED };
      cache = new HashMap();
      SVGAttr[] arrayOfSVGAttr = values();
      int j = arrayOfSVGAttr.length;
      while (i < j)
      {
        SVGAttr localSVGAttr = arrayOfSVGAttr[i];
        if (localSVGAttr == CLASS)
        {
          cache.put("class", localSVGAttr);
        }
        else if (localSVGAttr != UNSUPPORTED)
        {
          String str = localSVGAttr.name().replace('_', '-');
          cache.put(str, localSVGAttr);
        }
        i += 1;
      }
    }
    
    public static SVGAttr fromString(String paramString)
    {
      paramString = (SVGAttr)cache.get(paramString);
      if (paramString != null) {
        return paramString;
      }
      return UNSUPPORTED;
    }
  }
  
  private static enum SVGElem
  {
    private static final Map<String, SVGElem> cache;
    
    static
    {
      int i = 0;
      svg = new SVGElem("svg", 0);
      a = new SVGElem("a", 1);
      circle = new SVGElem("circle", 2);
      clipPath = new SVGElem("clipPath", 3);
      defs = new SVGElem("defs", 4);
      desc = new SVGElem("desc", 5);
      ellipse = new SVGElem("ellipse", 6);
      g = new SVGElem("g", 7);
      image = new SVGElem("image", 8);
      line = new SVGElem("line", 9);
      linearGradient = new SVGElem("linearGradient", 10);
      marker = new SVGElem("marker", 11);
      mask = new SVGElem("mask", 12);
      path = new SVGElem("path", 13);
      pattern = new SVGElem("pattern", 14);
      polygon = new SVGElem("polygon", 15);
      polyline = new SVGElem("polyline", 16);
      radialGradient = new SVGElem("radialGradient", 17);
      rect = new SVGElem("rect", 18);
      solidColor = new SVGElem("solidColor", 19);
      stop = new SVGElem("stop", 20);
      style = new SVGElem("style", 21);
      SWITCH = new SVGElem("SWITCH", 22);
      symbol = new SVGElem("symbol", 23);
      text = new SVGElem("text", 24);
      textPath = new SVGElem("textPath", 25);
      title = new SVGElem("title", 26);
      tref = new SVGElem("tref", 27);
      tspan = new SVGElem("tspan", 28);
      use = new SVGElem("use", 29);
      view = new SVGElem("view", 30);
      UNSUPPORTED = new SVGElem("UNSUPPORTED", 31);
      $VALUES = new SVGElem[] { svg, a, circle, clipPath, defs, desc, ellipse, g, image, line, linearGradient, marker, mask, path, pattern, polygon, polyline, radialGradient, rect, solidColor, stop, style, SWITCH, symbol, text, textPath, title, tref, tspan, use, view, UNSUPPORTED };
      cache = new HashMap();
      SVGElem[] arrayOfSVGElem = values();
      int j = arrayOfSVGElem.length;
      while (i < j)
      {
        SVGElem localSVGElem = arrayOfSVGElem[i];
        if (localSVGElem == SWITCH)
        {
          cache.put("switch", localSVGElem);
        }
        else if (localSVGElem != UNSUPPORTED)
        {
          String str = localSVGElem.name();
          cache.put(str, localSVGElem);
        }
        i += 1;
      }
    }
    
    public static SVGElem fromString(String paramString)
    {
      paramString = (SVGElem)cache.get(paramString);
      if (paramString != null) {
        return paramString;
      }
      return UNSUPPORTED;
    }
  }
  
  private static class a
  {
    private static final Map<String, PreserveAspectRatio.Alignment> all = new HashMap(10);
    
    static
    {
      all.put("none", PreserveAspectRatio.Alignment.none);
      all.put("xMinYMin", PreserveAspectRatio.Alignment.xMinYMin);
      all.put("xMidYMin", PreserveAspectRatio.Alignment.xMidYMin);
      all.put("xMaxYMin", PreserveAspectRatio.Alignment.xMaxYMin);
      all.put("xMinYMid", PreserveAspectRatio.Alignment.xMinYMid);
      all.put("xMidYMid", PreserveAspectRatio.Alignment.xMidYMid);
      all.put("xMaxYMid", PreserveAspectRatio.Alignment.xMaxYMid);
      all.put("xMinYMax", PreserveAspectRatio.Alignment.xMinYMax);
      all.put("xMidYMax", PreserveAspectRatio.Alignment.xMidYMax);
      all.put("xMaxYMax", PreserveAspectRatio.Alignment.xMaxYMax);
    }
    
    static PreserveAspectRatio.Alignment get(String paramString)
    {
      return (PreserveAspectRatio.Alignment)all.get(paramString);
    }
  }
  
  private static class b
  {
    private static final Map<String, Integer> aspectRatioKeywords = new HashMap(47);
    
    static
    {
      aspectRatioKeywords.put("aliceblue", Integer.valueOf(-984833));
      aspectRatioKeywords.put("antiquewhite", Integer.valueOf(-332841));
      aspectRatioKeywords.put("aqua", Integer.valueOf(-16711681));
      aspectRatioKeywords.put("aquamarine", Integer.valueOf(-8388652));
      aspectRatioKeywords.put("azure", Integer.valueOf(-983041));
      aspectRatioKeywords.put("beige", Integer.valueOf(-657956));
      aspectRatioKeywords.put("bisque", Integer.valueOf(58564));
      aspectRatioKeywords.put("black", Integer.valueOf(-16777216));
      aspectRatioKeywords.put("blanchedalmond", Integer.valueOf(60365));
      aspectRatioKeywords.put("blue", Integer.valueOf(-16776961));
      aspectRatioKeywords.put("blueviolet", Integer.valueOf(-7722014));
      aspectRatioKeywords.put("brown", Integer.valueOf(-5952982));
      aspectRatioKeywords.put("burlywood", Integer.valueOf(-2180985));
      aspectRatioKeywords.put("cadetblue", Integer.valueOf(-10510688));
      aspectRatioKeywords.put("chartreuse", Integer.valueOf(-8388864));
      aspectRatioKeywords.put("chocolate", Integer.valueOf(-2987746));
      aspectRatioKeywords.put("coral", Integer.valueOf(-32944));
      aspectRatioKeywords.put("cornflowerblue", Integer.valueOf(-10185235));
      aspectRatioKeywords.put("cornsilk", Integer.valueOf(63708));
      aspectRatioKeywords.put("crimson", Integer.valueOf(-2354116));
      aspectRatioKeywords.put("cyan", Integer.valueOf(-16711681));
      aspectRatioKeywords.put("darkblue", Integer.valueOf(-16777077));
      aspectRatioKeywords.put("darkcyan", Integer.valueOf(-16741493));
      aspectRatioKeywords.put("darkgoldenrod", Integer.valueOf(-4684277));
      aspectRatioKeywords.put("darkgray", Integer.valueOf(-5658199));
      aspectRatioKeywords.put("darkgreen", Integer.valueOf(-16751616));
      aspectRatioKeywords.put("darkgrey", Integer.valueOf(-5658199));
      aspectRatioKeywords.put("darkkhaki", Integer.valueOf(-4343957));
      aspectRatioKeywords.put("darkmagenta", Integer.valueOf(-7667573));
      aspectRatioKeywords.put("darkolivegreen", Integer.valueOf(-11179217));
      aspectRatioKeywords.put("darkorange", Integer.valueOf(35840));
      aspectRatioKeywords.put("darkorchid", Integer.valueOf(-6737204));
      aspectRatioKeywords.put("darkred", Integer.valueOf(-7667712));
      aspectRatioKeywords.put("darksalmon", Integer.valueOf(-1468806));
      aspectRatioKeywords.put("darkseagreen", Integer.valueOf(-7357297));
      aspectRatioKeywords.put("darkslateblue", Integer.valueOf(-12042869));
      aspectRatioKeywords.put("darkslategray", Integer.valueOf(-13676721));
      aspectRatioKeywords.put("darkslategrey", Integer.valueOf(-13676721));
      aspectRatioKeywords.put("darkturquoise", Integer.valueOf(-16724271));
      aspectRatioKeywords.put("darkviolet", Integer.valueOf(-7077677));
      aspectRatioKeywords.put("deeppink", Integer.valueOf(-60269));
      aspectRatioKeywords.put("deepskyblue", Integer.valueOf(-16728065));
      aspectRatioKeywords.put("dimgray", Integer.valueOf(-9868951));
      aspectRatioKeywords.put("dimgrey", Integer.valueOf(-9868951));
      aspectRatioKeywords.put("dodgerblue", Integer.valueOf(-14774017));
      aspectRatioKeywords.put("firebrick", Integer.valueOf(-5103070));
      aspectRatioKeywords.put("floralwhite", Integer.valueOf(64240));
      aspectRatioKeywords.put("forestgreen", Integer.valueOf(-14513374));
      aspectRatioKeywords.put("fuchsia", Integer.valueOf(-65281));
      aspectRatioKeywords.put("gainsboro", Integer.valueOf(-2302756));
      aspectRatioKeywords.put("ghostwhite", Integer.valueOf(-460545));
      aspectRatioKeywords.put("gold", Integer.valueOf(55040));
      aspectRatioKeywords.put("goldenrod", Integer.valueOf(-2448096));
      aspectRatioKeywords.put("gray", Integer.valueOf(-8355712));
      aspectRatioKeywords.put("green", Integer.valueOf(-16744448));
      aspectRatioKeywords.put("greenyellow", Integer.valueOf(-5374161));
      aspectRatioKeywords.put("grey", Integer.valueOf(-8355712));
      aspectRatioKeywords.put("honeydew", Integer.valueOf(-983056));
      aspectRatioKeywords.put("hotpink", Integer.valueOf(-38476));
      aspectRatioKeywords.put("indianred", Integer.valueOf(-3318692));
      aspectRatioKeywords.put("indigo", Integer.valueOf(-11861886));
      aspectRatioKeywords.put("ivory", Integer.valueOf(-16));
      aspectRatioKeywords.put("khaki", Integer.valueOf(-989556));
      aspectRatioKeywords.put("lavender", Integer.valueOf(-1644806));
      aspectRatioKeywords.put("lavenderblush", Integer.valueOf(61685));
      aspectRatioKeywords.put("lawngreen", Integer.valueOf(-8586240));
      aspectRatioKeywords.put("lemonchiffon", Integer.valueOf(64205));
      aspectRatioKeywords.put("lightblue", Integer.valueOf(-5383962));
      aspectRatioKeywords.put("lightcoral", Integer.valueOf(-1015680));
      aspectRatioKeywords.put("lightcyan", Integer.valueOf(-2031617));
      aspectRatioKeywords.put("lightgoldenrodyellow", Integer.valueOf(-329006));
      aspectRatioKeywords.put("lightgray", Integer.valueOf(-2894893));
      aspectRatioKeywords.put("lightgreen", Integer.valueOf(-7278960));
      aspectRatioKeywords.put("lightgrey", Integer.valueOf(-2894893));
      aspectRatioKeywords.put("lightpink", Integer.valueOf(46785));
      aspectRatioKeywords.put("lightsalmon", Integer.valueOf(41082));
      aspectRatioKeywords.put("lightseagreen", Integer.valueOf(-14634326));
      aspectRatioKeywords.put("lightskyblue", Integer.valueOf(-7876870));
      aspectRatioKeywords.put("lightslategray", Integer.valueOf(-8943463));
      aspectRatioKeywords.put("lightslategrey", Integer.valueOf(-8943463));
      aspectRatioKeywords.put("lightsteelblue", Integer.valueOf(-5192482));
      aspectRatioKeywords.put("lightyellow", Integer.valueOf(-32));
      aspectRatioKeywords.put("lime", Integer.valueOf(-16711936));
      aspectRatioKeywords.put("limegreen", Integer.valueOf(-13447886));
      aspectRatioKeywords.put("linen", Integer.valueOf(-331546));
      aspectRatioKeywords.put("magenta", Integer.valueOf(-65281));
      aspectRatioKeywords.put("maroon", Integer.valueOf(-8388608));
      aspectRatioKeywords.put("mediumaquamarine", Integer.valueOf(-10039894));
      aspectRatioKeywords.put("mediumblue", Integer.valueOf(-16777011));
      aspectRatioKeywords.put("mediumorchid", Integer.valueOf(-4565549));
      aspectRatioKeywords.put("mediumpurple", Integer.valueOf(-7114533));
      aspectRatioKeywords.put("mediumseagreen", Integer.valueOf(-12799119));
      aspectRatioKeywords.put("mediumslateblue", Integer.valueOf(-8689426));
      aspectRatioKeywords.put("mediumspringgreen", Integer.valueOf(-16713062));
      aspectRatioKeywords.put("mediumturquoise", Integer.valueOf(-12004916));
      aspectRatioKeywords.put("mediumvioletred", Integer.valueOf(-3730043));
      aspectRatioKeywords.put("midnightblue", Integer.valueOf(-15132304));
      aspectRatioKeywords.put("mintcream", Integer.valueOf(-655366));
      aspectRatioKeywords.put("mistyrose", Integer.valueOf(58593));
      aspectRatioKeywords.put("moccasin", Integer.valueOf(58549));
      aspectRatioKeywords.put("navajowhite", Integer.valueOf(57005));
      aspectRatioKeywords.put("navy", Integer.valueOf(-16777088));
      aspectRatioKeywords.put("oldlace", Integer.valueOf(-133658));
      aspectRatioKeywords.put("olive", Integer.valueOf(-8355840));
      aspectRatioKeywords.put("olivedrab", Integer.valueOf(-9728477));
      aspectRatioKeywords.put("orange", Integer.valueOf(42240));
      aspectRatioKeywords.put("orangered", Integer.valueOf(-47872));
      aspectRatioKeywords.put("orchid", Integer.valueOf(-2461482));
      aspectRatioKeywords.put("palegoldenrod", Integer.valueOf(-1120086));
      aspectRatioKeywords.put("palegreen", Integer.valueOf(-6751336));
      aspectRatioKeywords.put("paleturquoise", Integer.valueOf(-5247250));
      aspectRatioKeywords.put("palevioletred", Integer.valueOf(-2396013));
      aspectRatioKeywords.put("papayawhip", Integer.valueOf(61397));
      aspectRatioKeywords.put("peachpuff", Integer.valueOf(55993));
      aspectRatioKeywords.put("peru", Integer.valueOf(-3308225));
      aspectRatioKeywords.put("pink", Integer.valueOf(49355));
      aspectRatioKeywords.put("plum", Integer.valueOf(-2252579));
      aspectRatioKeywords.put("powderblue", Integer.valueOf(-5185306));
      aspectRatioKeywords.put("purple", Integer.valueOf(-8388480));
      aspectRatioKeywords.put("rebeccapurple", Integer.valueOf(-10079335));
      aspectRatioKeywords.put("red", Integer.valueOf(-65536));
      aspectRatioKeywords.put("rosybrown", Integer.valueOf(-4419697));
      aspectRatioKeywords.put("royalblue", Integer.valueOf(-12490271));
      aspectRatioKeywords.put("saddlebrown", Integer.valueOf(-7650029));
      aspectRatioKeywords.put("salmon", Integer.valueOf(-360334));
      aspectRatioKeywords.put("sandybrown", Integer.valueOf(-744352));
      aspectRatioKeywords.put("seagreen", Integer.valueOf(-13726889));
      aspectRatioKeywords.put("seashell", Integer.valueOf(62958));
      aspectRatioKeywords.put("sienna", Integer.valueOf(-6270419));
      aspectRatioKeywords.put("silver", Integer.valueOf(-4144960));
      aspectRatioKeywords.put("skyblue", Integer.valueOf(-7876885));
      aspectRatioKeywords.put("slateblue", Integer.valueOf(-9807155));
      aspectRatioKeywords.put("slategray", Integer.valueOf(-9404272));
      aspectRatioKeywords.put("slategrey", Integer.valueOf(-9404272));
      aspectRatioKeywords.put("snow", Integer.valueOf(64250));
      aspectRatioKeywords.put("springgreen", Integer.valueOf(-16711809));
      aspectRatioKeywords.put("steelblue", Integer.valueOf(-12156236));
      aspectRatioKeywords.put("tan", Integer.valueOf(-2968436));
      aspectRatioKeywords.put("teal", Integer.valueOf(-16744320));
      aspectRatioKeywords.put("thistle", Integer.valueOf(-2572328));
      aspectRatioKeywords.put("tomato", Integer.valueOf(-40121));
      aspectRatioKeywords.put("turquoise", Integer.valueOf(-12525360));
      aspectRatioKeywords.put("violet", Integer.valueOf(-1146130));
      aspectRatioKeywords.put("wheat", Integer.valueOf(-663885));
      aspectRatioKeywords.put("white", Integer.valueOf(-1));
      aspectRatioKeywords.put("whitesmoke", Integer.valueOf(-657931));
      aspectRatioKeywords.put("yellow", Integer.valueOf(65280));
      aspectRatioKeywords.put("yellowgreen", Integer.valueOf(-6632142));
      aspectRatioKeywords.put("transparent", Integer.valueOf(0));
    }
    
    static Integer get(String paramString)
    {
      return (Integer)aspectRatioKeywords.get(paramString);
    }
  }
  
  private static class c
  {
    private static final Map<String, SVG.n> fontSizeKeywords = new HashMap(9);
    
    static
    {
      fontSizeKeywords.put("xx-small", new SVG.n(0.694F, SVG.Unit.pt));
      fontSizeKeywords.put("x-small", new SVG.n(0.833F, SVG.Unit.pt));
      fontSizeKeywords.put("small", new SVG.n(10.0F, SVG.Unit.pt));
      fontSizeKeywords.put("medium", new SVG.n(12.0F, SVG.Unit.pt));
      fontSizeKeywords.put("large", new SVG.n(14.4F, SVG.Unit.pt));
      fontSizeKeywords.put("x-large", new SVG.n(17.3F, SVG.Unit.pt));
      fontSizeKeywords.put("xx-large", new SVG.n(20.7F, SVG.Unit.pt));
      fontSizeKeywords.put("smaller", new SVG.n(83.33F, SVG.Unit.percent));
      fontSizeKeywords.put("larger", new SVG.n(120.0F, SVG.Unit.percent));
    }
    
    static SVG.n parseLength(String paramString)
    {
      return (SVG.n)fontSizeKeywords.get(paramString);
    }
  }
  
  private static class d
  {
    private static final Map<String, Integer> aspectRatioKeywords = new HashMap(13);
    
    static
    {
      aspectRatioKeywords.put("normal", Integer.valueOf(400));
      aspectRatioKeywords.put("bold", Integer.valueOf(700));
      aspectRatioKeywords.put("bolder", Integer.valueOf(1));
      aspectRatioKeywords.put("lighter", Integer.valueOf(-1));
      aspectRatioKeywords.put("100", Integer.valueOf(100));
      aspectRatioKeywords.put("200", Integer.valueOf(200));
      aspectRatioKeywords.put("300", Integer.valueOf(300));
      aspectRatioKeywords.put("400", Integer.valueOf(400));
      aspectRatioKeywords.put("500", Integer.valueOf(500));
      aspectRatioKeywords.put("600", Integer.valueOf(600));
      aspectRatioKeywords.put("700", Integer.valueOf(700));
      aspectRatioKeywords.put("800", Integer.valueOf(800));
      aspectRatioKeywords.put("900", Integer.valueOf(900));
    }
    
    static Integer get(String paramString)
    {
      return (Integer)aspectRatioKeywords.get(paramString);
    }
  }
  
  private class e
    extends DefaultHandler2
  {
    private e() {}
    
    public void characters(char[] paramArrayOfChar, int paramInt1, int paramInt2)
      throws SAXException
    {
      SVGParser.parse(SVGParser.this, new String(paramArrayOfChar, paramInt1, paramInt2));
    }
    
    public void endDocument()
      throws SAXException
    {
      SVGParser.endElement(SVGParser.this);
    }
    
    public void endElement(String paramString1, String paramString2, String paramString3)
      throws SAXException
    {
      SVGParser.parse(SVGParser.this, paramString1, paramString2, paramString3);
    }
    
    public void processingInstruction(String paramString1, String paramString2)
      throws SAXException
    {
      paramString2 = new SVGParser.f(paramString2);
      paramString2 = SVGParser.parse(SVGParser.this, paramString2);
      SVGParser.parse(SVGParser.this, paramString1, paramString2);
    }
    
    public void startDocument()
      throws SAXException
    {
      SVGParser.parse(SVGParser.this);
    }
    
    public void startElement(String paramString1, String paramString2, String paramString3, Attributes paramAttributes)
      throws SAXException
    {
      SVGParser.startElement(SVGParser.this, paramString1, paramString2, paramString3, paramAttributes);
    }
  }
  
  static class f
  {
    private NumberParser field_1 = new NumberParser();
    String input;
    int inputLength = 0;
    int position = 0;
    
    f(String paramString)
    {
      input = paramString.trim();
      inputLength = input.length();
    }
    
    String add(char paramChar)
    {
      return nextToken(paramChar, true);
    }
    
    int advanceChar()
    {
      int j = position;
      int i = inputLength;
      if (j == i) {
        return -1;
      }
      position = (j + 1);
      j = position;
      if (j < i) {
        return input.charAt(j);
      }
      return -1;
    }
    
    String ahead()
    {
      int i = position;
      while ((!empty()) && (!isWhitespace(input.charAt(position)))) {
        position += 1;
      }
      String str = input.substring(i, position);
      position = i;
      return str;
    }
    
    Boolean checkedNextFlag(Object paramObject)
    {
      if (paramObject == null) {
        return null;
      }
      skipCommaWhitespace();
      return nextFlag();
    }
    
    float checkedNextFloat(float paramFloat)
    {
      if (Float.isNaN(paramFloat)) {
        return NaN.0F;
      }
      skipCommaWhitespace();
      return nextFloat();
    }
    
    float checkedNextFloat(Boolean paramBoolean)
    {
      if (paramBoolean == null) {
        return NaN.0F;
      }
      skipCommaWhitespace();
      return nextFloat();
    }
    
    boolean consume(char paramChar)
    {
      int i = position;
      boolean bool;
      if ((i < inputLength) && (input.charAt(i) == paramChar)) {
        bool = true;
      } else {
        bool = false;
      }
      if (bool) {
        position += 1;
      }
      return bool;
    }
    
    boolean consume(String paramString)
    {
      int i = paramString.length();
      int j = position;
      boolean bool;
      if ((j <= inputLength - i) && (input.substring(j, j + i).equals(paramString))) {
        bool = true;
      } else {
        bool = false;
      }
      if (bool) {
        position += i;
      }
      return bool;
    }
    
    boolean empty()
    {
      return position == inputLength;
    }
    
    String get()
    {
      return nextToken(' ', false);
    }
    
    boolean hasLetter()
    {
      int i = position;
      if (i == inputLength) {
        return false;
      }
      i = input.charAt(i);
      return ((i >= 97) && (i <= 122)) || ((i >= 65) && (i <= 90));
    }
    
    boolean isEOL(int paramInt)
    {
      return (paramInt == 10) || (paramInt == 13);
    }
    
    boolean isWhitespace(int paramInt)
    {
      return (paramInt == 32) || (paramInt == 10) || (paramInt == 13) || (paramInt == 9);
    }
    
    Integer nextChar()
    {
      int i = position;
      if (i == inputLength) {
        return null;
      }
      String str = input;
      position = (i + 1);
      return Integer.valueOf(str.charAt(i));
    }
    
    Boolean nextFlag()
    {
      int i = position;
      if (i == inputLength) {
        return null;
      }
      i = input.charAt(i);
      if ((i != 48) && (i != 49)) {
        return null;
      }
      int j = position;
      boolean bool = true;
      position = (j + 1);
      if (i != 49) {
        bool = false;
      }
      return Boolean.valueOf(bool);
    }
    
    float nextFloat()
    {
      float f = field_1.parseNumber(input, position, inputLength);
      if (!Float.isNaN(f)) {
        position = field_1.getEndPos();
      }
      return f;
    }
    
    String nextFunction()
    {
      if (empty()) {
        return null;
      }
      int j = position;
      for (int i = input.charAt(j); ((i >= 97) && (i <= 122)) || ((i >= 65) && (i <= 90)); i = advanceChar()) {}
      int k = position;
      while (isWhitespace(i)) {
        i = advanceChar();
      }
      if (i == 40)
      {
        position += 1;
        return input.substring(j, k);
      }
      position = j;
      return null;
    }
    
    SVG.n nextLength()
    {
      float f = nextFloat();
      if (Float.isNaN(f)) {
        return null;
      }
      SVG.Unit localUnit = nextUnit();
      if (localUnit == null) {
        return new SVG.n(f, SVG.Unit.px);
      }
      return new SVG.n(f, localUnit);
    }
    
    String nextQuotedString()
    {
      if (empty()) {
        return null;
      }
      int j = position;
      int k = input.charAt(j);
      if ((k != 39) && (k != 34)) {
        return null;
      }
      for (int i = advanceChar(); (i != -1) && (i != k); i = advanceChar()) {}
      if (i == -1)
      {
        position = j;
        return null;
      }
      position += 1;
      return input.substring(j + 1, position - 1);
    }
    
    String nextToken()
    {
      if (empty()) {
        return null;
      }
      int j = position;
      int i = input.charAt(j);
      if (((i >= 65) && (i <= 90)) || ((i >= 97) && (i <= 122)))
      {
        for (i = advanceChar(); ((i >= 65) && (i <= 90)) || ((i >= 97) && (i <= 122)); i = advanceChar()) {}
        return input.substring(j, position);
      }
      position = j;
      return null;
    }
    
    String nextToken(char paramChar)
    {
      return nextToken(paramChar, false);
    }
    
    String nextToken(char paramChar, boolean paramBoolean)
    {
      if (empty()) {
        return null;
      }
      char c = input.charAt(position);
      if ((paramBoolean) || (!isWhitespace(c)))
      {
        if (c == paramChar) {
          return null;
        }
        int i = position;
        for (c = advanceChar(); (c != '?') && (c != paramChar) && ((paramBoolean) || (!isWhitespace(c))); c = advanceChar()) {}
        return input.substring(i, position);
      }
      return null;
    }
    
    SVG.Unit nextUnit()
    {
      if (empty()) {
        return null;
      }
      if (input.charAt(position) == '%')
      {
        position += 1;
        return SVG.Unit.percent;
      }
      int i = position;
      if (i > inputLength - 2) {
        return null;
      }
      Object localObject = input;
      try
      {
        localObject = ((String)localObject).substring(i, i + 2);
        Locale localLocale = Locale.US;
        localObject = SVG.Unit.valueOf(((String)localObject).toLowerCase(localLocale));
        position += 2;
        return localObject;
      }
      catch (IllegalArgumentException localIllegalArgumentException) {}
      return null;
    }
    
    float possibleNextFloat()
    {
      skipCommaWhitespace();
      float f = field_1.parseNumber(input, position, inputLength);
      if (!Float.isNaN(f)) {
        position = field_1.getEndPos();
      }
      return f;
    }
    
    String restOfText()
    {
      if (empty()) {
        return null;
      }
      int i = position;
      position = inputLength;
      return input.substring(i);
    }
    
    boolean skipCommaWhitespace()
    {
      skipWhitespace();
      int i = position;
      if (i == inputLength) {
        return false;
      }
      if (input.charAt(i) != ',') {
        return false;
      }
      position += 1;
      skipWhitespace();
      return true;
    }
    
    void skipWhitespace()
    {
      for (;;)
      {
        int i = position;
        if (i >= inputLength) {
          break;
        }
        if (!isWhitespace(input.charAt(i))) {
          return;
        }
        position += 1;
      }
    }
  }
  
  private class g
    implements Attributes
  {
    private XmlPullParser reader;
    
    public g(XmlPullParser paramXmlPullParser)
    {
      reader = paramXmlPullParser;
    }
    
    public int getIndex(String paramString)
    {
      return -1;
    }
    
    public int getIndex(String paramString1, String paramString2)
    {
      return -1;
    }
    
    public int getLength()
    {
      return reader.getAttributeCount();
    }
    
    public String getLocalName(int paramInt)
    {
      return reader.getAttributeName(paramInt);
    }
    
    public String getQName(int paramInt)
    {
      String str = reader.getAttributeName(paramInt);
      Object localObject = str;
      if (reader.getAttributePrefix(paramInt) != null)
      {
        localObject = new StringBuilder();
        ((StringBuilder)localObject).append(reader.getAttributePrefix(paramInt));
        ((StringBuilder)localObject).append(':');
        ((StringBuilder)localObject).append(str);
        localObject = ((StringBuilder)localObject).toString();
      }
      return localObject;
    }
    
    public String getType(int paramInt)
    {
      return null;
    }
    
    public String getType(String paramString)
    {
      return null;
    }
    
    public String getType(String paramString1, String paramString2)
    {
      return null;
    }
    
    public String getURI(int paramInt)
    {
      return reader.getAttributeNamespace(paramInt);
    }
    
    public String getValue(int paramInt)
    {
      return reader.getAttributeValue(paramInt);
    }
    
    public String getValue(String paramString)
    {
      return null;
    }
    
    public String getValue(String paramString1, String paramString2)
    {
      return null;
    }
  }
}
