package com.alibaba.fastjson.parser;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.parser.deserializer.CollectionResolveFieldDeserializer;
import com.alibaba.fastjson.parser.deserializer.ExtraProcessor;
import com.alibaba.fastjson.parser.deserializer.ExtraTypeProvider;
import com.alibaba.fastjson.parser.deserializer.FieldDeserializer;
import com.alibaba.fastjson.parser.deserializer.ListResolveFieldDeserializer;
import com.alibaba.fastjson.parser.deserializer.MapResolveFieldDeserializer;
import com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;
import com.alibaba.fastjson.serializer.IntegerCodec;
import com.alibaba.fastjson.serializer.LongCodec;
import com.alibaba.fastjson.serializer.StringCodec;
import com.alibaba.fastjson.util.TypeUtils;
import java.io.Closeable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

public class DefaultJSONParser
  extends AbstractJSONParser
  implements Closeable
{
  public static final int NONE = 0;
  public static final int NeedToResolve = 1;
  public static final int TypeNameRedirect = 2;
  private static final Set<Class<?>> primitiveClasses = new HashSet();
  protected ParserConfig config;
  protected ParseContext context;
  private ParseContext[] contextArray = new ParseContext[8];
  private int contextArrayIndex = 0;
  private DateFormat dateFormat;
  private String dateFormatPattern = JSON.DEFFAULT_DATE_FORMAT;
  private List<ExtraProcessor> extraProcessors = null;
  private List<ExtraTypeProvider> extraTypeProviders = null;
  protected final Object input;
  protected final JSONLexer lexer;
  private int resolveStatus = 0;
  private List<ResolveTask> resolveTaskList;
  protected final SymbolTable symbolTable;
  
  static
  {
    primitiveClasses.add(Boolean.TYPE);
    primitiveClasses.add(Byte.TYPE);
    primitiveClasses.add(Short.TYPE);
    primitiveClasses.add(Integer.TYPE);
    primitiveClasses.add(Long.TYPE);
    primitiveClasses.add(Float.TYPE);
    primitiveClasses.add(Double.TYPE);
    primitiveClasses.add(Boolean.class);
    primitiveClasses.add(Byte.class);
    primitiveClasses.add(Short.class);
    primitiveClasses.add(Integer.class);
    primitiveClasses.add(Long.class);
    primitiveClasses.add(Float.class);
    primitiveClasses.add(Double.class);
    primitiveClasses.add(BigInteger.class);
    primitiveClasses.add(BigDecimal.class);
    primitiveClasses.add(String.class);
  }
  
  public DefaultJSONParser(JSONLexer paramJSONLexer)
  {
    this(paramJSONLexer, ParserConfig.getGlobalInstance());
  }
  
  public DefaultJSONParser(JSONLexer paramJSONLexer, ParserConfig paramParserConfig)
  {
    this(null, paramJSONLexer, paramParserConfig);
  }
  
  public DefaultJSONParser(Object paramObject, JSONLexer paramJSONLexer, ParserConfig paramParserConfig)
  {
    lexer = paramJSONLexer;
    input = paramObject;
    config = paramParserConfig;
    symbolTable = paramParserConfig.getSymbolTable();
    paramJSONLexer.nextToken(12);
  }
  
  public DefaultJSONParser(String paramString)
  {
    this(paramString, ParserConfig.getGlobalInstance(), JSON.DEFAULT_PARSER_FEATURE);
  }
  
  public DefaultJSONParser(String paramString, ParserConfig paramParserConfig)
  {
    this(paramString, new JSONScanner(paramString, JSON.DEFAULT_PARSER_FEATURE), paramParserConfig);
  }
  
  public DefaultJSONParser(String paramString, ParserConfig paramParserConfig, int paramInt)
  {
    this(paramString, new JSONScanner(paramString, paramInt), paramParserConfig);
  }
  
  public DefaultJSONParser(char[] paramArrayOfChar, int paramInt1, ParserConfig paramParserConfig, int paramInt2)
  {
    this(paramArrayOfChar, new JSONScanner(paramArrayOfChar, paramInt1, paramInt2), paramParserConfig);
  }
  
  private void addContext(ParseContext paramParseContext)
  {
    int i = contextArrayIndex;
    contextArrayIndex = (i + 1);
    ParseContext[] arrayOfParseContext1 = contextArray;
    if (i >= arrayOfParseContext1.length)
    {
      ParseContext[] arrayOfParseContext2 = new ParseContext[arrayOfParseContext1.length * 3 / 2];
      System.arraycopy(arrayOfParseContext1, 0, arrayOfParseContext2, 0, arrayOfParseContext1.length);
      contextArray = arrayOfParseContext2;
    }
    contextArray[i] = paramParseContext;
  }
  
  public final void accept(int paramInt)
  {
    JSONLexer localJSONLexer = getLexer();
    if (localJSONLexer.token() == paramInt)
    {
      localJSONLexer.nextToken();
      return;
    }
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("syntax error, expect ");
    localStringBuilder.append(JSONToken.name(paramInt));
    localStringBuilder.append(", actual ");
    localStringBuilder.append(JSONToken.name(localJSONLexer.token()));
    throw new JSONException(localStringBuilder.toString());
  }
  
  public final void accept(int paramInt1, int paramInt2)
  {
    JSONLexer localJSONLexer = getLexer();
    if (localJSONLexer.token() == paramInt1)
    {
      localJSONLexer.nextToken(paramInt2);
      return;
    }
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("syntax error, expect ");
    localStringBuilder.append(JSONToken.name(paramInt1));
    localStringBuilder.append(", actual ");
    localStringBuilder.append(JSONToken.name(localJSONLexer.token()));
    throw new JSONException(localStringBuilder.toString());
  }
  
  public void acceptType(String paramString)
  {
    JSONLexer localJSONLexer = lexer;
    localJSONLexer.nextTokenWithColon();
    if (localJSONLexer.token() == 4)
    {
      if (paramString.equals(localJSONLexer.stringVal()))
      {
        localJSONLexer.nextToken();
        if (localJSONLexer.token() == 16) {
          localJSONLexer.nextToken();
        }
      }
      else
      {
        throw new JSONException("type not match error");
      }
    }
    else {
      throw new JSONException("type not match error");
    }
  }
  
  public void addResolveTask(ResolveTask paramResolveTask)
  {
    if (resolveTaskList == null) {
      resolveTaskList = new ArrayList(2);
    }
    resolveTaskList.add(paramResolveTask);
  }
  
  public void checkListResolve(Collection paramCollection)
  {
    if (resolveStatus == 1)
    {
      if ((paramCollection instanceof List))
      {
        int i = paramCollection.size();
        paramCollection = (List)paramCollection;
        localResolveTask = getLastResolveTask();
        localResolveTask.setFieldDeserializer(new ListResolveFieldDeserializer(this, paramCollection, i - 1));
        localResolveTask.setOwnerContext(context);
        setResolveStatus(0);
        return;
      }
      ResolveTask localResolveTask = getLastResolveTask();
      localResolveTask.setFieldDeserializer(new CollectionResolveFieldDeserializer(this, paramCollection));
      localResolveTask.setOwnerContext(context);
      setResolveStatus(0);
    }
  }
  
  public void checkMapResolve(Map paramMap, String paramString)
  {
    if (resolveStatus == 1)
    {
      paramMap = new MapResolveFieldDeserializer(paramMap, paramString);
      paramString = getLastResolveTask();
      paramString.setFieldDeserializer(paramMap);
      paramString.setOwnerContext(context);
      setResolveStatus(0);
    }
  }
  
  public void close()
  {
    JSONLexer localJSONLexer = getLexer();
    try
    {
      boolean bool = isEnabled(Feature.AutoCloseSource);
      if (bool)
      {
        int i = localJSONLexer.token();
        if (i != 20)
        {
          StringBuilder localStringBuilder = new StringBuilder();
          localStringBuilder.append("not close json text, token : ");
          localStringBuilder.append(JSONToken.name(localJSONLexer.token()));
          throw new JSONException(localStringBuilder.toString());
        }
      }
      localJSONLexer.close();
      return;
    }
    catch (Throwable localThrowable)
    {
      localJSONLexer.close();
      throw localThrowable;
    }
  }
  
  public void config(Feature paramFeature, boolean paramBoolean)
  {
    getLexer().config(paramFeature, paramBoolean);
  }
  
  public ParserConfig getConfig()
  {
    return config;
  }
  
  public ParseContext getContext()
  {
    return context;
  }
  
  public String getDateFomartPattern()
  {
    return dateFormatPattern;
  }
  
  public DateFormat getDateFormat()
  {
    if (dateFormat == null) {
      dateFormat = new SimpleDateFormat(dateFormatPattern);
    }
    return dateFormat;
  }
  
  public List getExtraProcessors()
  {
    if (extraProcessors == null) {
      extraProcessors = new ArrayList(2);
    }
    return extraProcessors;
  }
  
  public List getExtraProcessorsDirect()
  {
    return extraProcessors;
  }
  
  public List getExtraTypeProviders()
  {
    if (extraTypeProviders == null) {
      extraTypeProviders = new ArrayList(2);
    }
    return extraTypeProviders;
  }
  
  public List getExtraTypeProvidersDirect()
  {
    return extraTypeProviders;
  }
  
  public String getInput()
  {
    Object localObject = input;
    if ((localObject instanceof char[])) {
      return new String((char[])localObject);
    }
    return localObject.toString();
  }
  
  public ResolveTask getLastResolveTask()
  {
    List localList = resolveTaskList;
    return (ResolveTask)localList.get(localList.size() - 1);
  }
  
  public JSONLexer getLexer()
  {
    return lexer;
  }
  
  public Object getObject(String paramString)
  {
    int i = 0;
    while (i < contextArrayIndex)
    {
      if (paramString.equals(contextArray[i].getPath())) {
        return contextArray[i].getObject();
      }
      i += 1;
    }
    return null;
  }
  
  public int getResolveStatus()
  {
    return resolveStatus;
  }
  
  public List getResolveTaskList()
  {
    if (resolveTaskList == null) {
      resolveTaskList = new ArrayList(2);
    }
    return resolveTaskList;
  }
  
  public List getResolveTaskListDirect()
  {
    return resolveTaskList;
  }
  
  public SymbolTable getSymbolTable()
  {
    return symbolTable;
  }
  
  public void handleResovleTask(Object paramObject)
  {
    paramObject = resolveTaskList;
    if (paramObject == null) {
      return;
    }
    int j = paramObject.size();
    int i = 0;
    while (i < j)
    {
      Object localObject = (ResolveTask)resolveTaskList.get(i);
      FieldDeserializer localFieldDeserializer = ((ResolveTask)localObject).getFieldDeserializer();
      if (localFieldDeserializer != null)
      {
        paramObject = null;
        if (((ResolveTask)localObject).getOwnerContext() != null) {
          paramObject = ((ResolveTask)localObject).getOwnerContext().getObject();
        }
        String str = ((ResolveTask)localObject).getReferenceValue();
        if (str.startsWith("$")) {
          localObject = getObject(str);
        } else {
          localObject = ((ResolveTask)localObject).getContext().getObject();
        }
        localFieldDeserializer.setValue(paramObject, localObject);
      }
      i += 1;
    }
  }
  
  public boolean isEnabled(Feature paramFeature)
  {
    return getLexer().isEnabled(paramFeature);
  }
  
  public Object parse()
  {
    return parse(null);
  }
  
  public Object parse(Object paramObject)
  {
    Object localObject = getLexer();
    String str;
    switch (((JSONLexer)localObject).token())
    {
    default: 
      break;
    case 5: 
    case 10: 
    case 11: 
    case 13: 
    case 15: 
    case 16: 
    case 17: 
    case 18: 
    case 19: 
      paramObject = new StringBuilder();
      paramObject.append("syntax error, pos ");
      paramObject.append(((JSONLexer)localObject).getBufferPosition());
      throw new JSONException(paramObject.toString());
    case 23: 
      ((JSONLexer)localObject).nextToken();
      return null;
    case 22: 
      ((JSONLexer)localObject).nextToken();
      localObject = new TreeSet();
      parseArray((Collection)localObject, paramObject);
      return localObject;
    case 21: 
      ((JSONLexer)localObject).nextToken();
      localObject = new HashSet();
      parseArray((Collection)localObject, paramObject);
      return localObject;
    case 20: 
      if (((JSONLexer)localObject).isBlankInput()) {
        return null;
      }
      paramObject = new StringBuilder();
      paramObject.append("unterminated json string, pos ");
      paramObject.append(((JSONLexer)localObject).getBufferPosition());
      throw new JSONException(paramObject.toString());
    case 14: 
      localObject = new JSONArray();
      parseArray((Collection)localObject, paramObject);
      return localObject;
    case 12: 
      return parseObject(new JSONObject(isEnabled(Feature.OrderedField)), paramObject);
    case 9: 
      ((JSONLexer)localObject).nextToken(18);
      if (((JSONLexer)localObject).token() == 18)
      {
        ((JSONLexer)localObject).nextToken(10);
        accept(10);
        long l = ((JSONLexer)localObject).integerValue().longValue();
        accept(2);
        accept(11);
        return new Date(l);
      }
      throw new JSONException("syntax error");
    case 8: 
      ((JSONLexer)localObject).nextToken();
      return null;
    case 7: 
      ((JSONLexer)localObject).nextToken();
      return Boolean.FALSE;
    case 6: 
      ((JSONLexer)localObject).nextToken();
      return Boolean.TRUE;
    case 4: 
      str = ((JSONLexer)localObject).stringVal();
      ((JSONLexer)localObject).nextToken(16);
      if (!((JSONLexer)localObject).isEnabled(Feature.AllowISO8601DateFormat)) {
        break label629;
      }
      paramObject = new JSONScanner(str);
      try
      {
        boolean bool = paramObject.scanISO8601DateIfMatch();
        if (bool)
        {
          localObject = paramObject.getCalendar().getTime();
          paramObject.close();
          return localObject;
        }
        paramObject.close();
        return str;
      }
      catch (Throwable localThrowable)
      {
        paramObject.close();
        throw localThrowable;
      }
    case 3: 
      paramObject = localThrowable.decimalValue(isEnabled(Feature.UseBigDecimal));
      localThrowable.nextToken();
      return paramObject;
    }
    paramObject = localThrowable.integerValue();
    localThrowable.nextToken();
    return paramObject;
    label629:
    return str;
  }
  
  public List parseArray(Class paramClass)
  {
    ArrayList localArrayList = new ArrayList();
    parseArray(paramClass, localArrayList);
    return localArrayList;
  }
  
  public void parseArray(Class paramClass, Collection paramCollection)
  {
    parseArray(paramClass, paramCollection);
  }
  
  public void parseArray(Type paramType, Collection paramCollection)
  {
    parseArray(paramType, paramCollection, null);
  }
  
  public void parseArray(Type paramType, Collection paramCollection, Object paramObject)
  {
    if ((lexer.token() == 21) || (lexer.token() == 22)) {
      lexer.nextToken();
    }
    if (lexer.token() == 14)
    {
      Object localObject1;
      Object localObject2;
      if (Integer.TYPE == paramType)
      {
        localObject1 = IntegerCodec.instance;
        lexer.nextToken(2);
      }
      else if (String.class == paramType)
      {
        localObject1 = StringCodec.instance;
        lexer.nextToken(4);
      }
      else
      {
        localObject2 = config.getDeserializer(paramType);
        localObject1 = localObject2;
        lexer.nextToken(((ObjectDeserializer)localObject2).getFastMatchToken());
      }
      ParseContext localParseContext = getContext();
      setContext(paramCollection, paramObject);
      int i = 0;
      try
      {
        for (;;)
        {
          boolean bool = isEnabled(Feature.AllowArbitraryCommas);
          if (bool) {
            for (;;)
            {
              j = lexer.token();
              if (j != 16) {
                break;
              }
              lexer.nextToken();
            }
          }
          int j = lexer.token();
          if (j == 15)
          {
            setContext(localParseContext);
            lexer.nextToken(16);
            return;
          }
          Class localClass = Integer.TYPE;
          localObject2 = null;
          paramObject = null;
          if (localClass == paramType)
          {
            paramCollection.add(IntegerCodec.instance.deserialze(this, null, null));
          }
          else if (String.class == paramType)
          {
            j = lexer.token();
            if (j == 4)
            {
              paramObject = lexer.stringVal();
              lexer.nextToken(16);
            }
            else
            {
              localObject2 = parse();
              if (localObject2 != null) {
                paramObject = localObject2.toString();
              }
            }
            paramCollection.add(paramObject);
          }
          else
          {
            j = lexer.token();
            if (j == 8)
            {
              lexer.nextToken();
              paramObject = localObject2;
            }
            else
            {
              paramObject = ((ObjectDeserializer)localObject1).deserialze(this, paramType, Integer.valueOf(i));
            }
            paramCollection.add(paramObject);
            checkListResolve(paramCollection);
          }
          j = lexer.token();
          if (j == 16) {
            lexer.nextToken(((ObjectDeserializer)localObject1).getFastMatchToken());
          }
          i += 1;
        }
        paramType = new StringBuilder();
      }
      catch (Throwable paramType)
      {
        setContext(localParseContext);
        throw paramType;
      }
    }
    paramType.append("exepct '[', but ");
    paramType.append(JSONToken.name(lexer.token()));
    throw new JSONException(paramType.toString());
  }
  
  public final void parseArray(Collection paramCollection)
  {
    parseArray(paramCollection, null);
  }
  
  public final void parseArray(Collection paramCollection, Object paramObject)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a13 = a12\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:552)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:1)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:166)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:331)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:387)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:90)\n\t... 17 more\n");
  }
  
  public Object[] parseArray(Type[] paramArrayOfType)
  {
    if (lexer.token() == 8)
    {
      lexer.nextToken(16);
      return null;
    }
    if (lexer.token() == 14)
    {
      Object[] arrayOfObject = new Object[paramArrayOfType.length];
      if (paramArrayOfType.length == 0)
      {
        lexer.nextToken(15);
        if (lexer.token() == 15)
        {
          lexer.nextToken(16);
          return new Object[0];
        }
        throw new JSONException("syntax error");
      }
      lexer.nextToken(2);
      int i = 0;
      while (i < paramArrayOfType.length)
      {
        Object localObject;
        if (lexer.token() == 8)
        {
          lexer.nextToken(16);
          localObject = null;
        }
        else
        {
          Type localType = paramArrayOfType[i];
          if ((localType != Integer.TYPE) && (localType != Integer.class))
          {
            if (localType == String.class)
            {
              if (lexer.token() == 4)
              {
                localObject = lexer.stringVal();
                lexer.nextToken(16);
              }
              else
              {
                localObject = TypeUtils.cast(parse(), localType, config);
              }
            }
            else
            {
              boolean bool;
              if ((i == paramArrayOfType.length - 1) && ((localType instanceof Class)))
              {
                localObject = (Class)localType;
                bool = ((Class)localObject).isArray();
                localObject = ((Class)localObject).getComponentType();
              }
              else
              {
                localObject = null;
                bool = false;
              }
              if ((bool) && (lexer.token() != 14))
              {
                ArrayList localArrayList = new ArrayList();
                localObject = config.getDeserializer((Type)localObject);
                int j = ((ObjectDeserializer)localObject).getFastMatchToken();
                if (lexer.token() != 15)
                {
                  for (;;)
                  {
                    localArrayList.add(((ObjectDeserializer)localObject).deserialze(this, localType, null));
                    if (lexer.token() != 16) {
                      break;
                    }
                    lexer.nextToken(j);
                  }
                  if (lexer.token() != 15)
                  {
                    paramArrayOfType = new StringBuilder();
                    paramArrayOfType.append("syntax error :");
                    paramArrayOfType.append(JSONToken.name(lexer.token()));
                    throw new JSONException(paramArrayOfType.toString());
                  }
                }
                localObject = TypeUtils.cast(localArrayList, localType, config);
              }
              else
              {
                localObject = config.getDeserializer(localType).deserialze(this, localType, null);
              }
            }
          }
          else if (lexer.token() == 2)
          {
            localObject = Integer.valueOf(lexer.intValue());
            lexer.nextToken(16);
          }
          else
          {
            localObject = TypeUtils.cast(parse(), localType, config);
          }
        }
        arrayOfObject[i] = localObject;
        if (lexer.token() != 15) {
          if (lexer.token() == 16)
          {
            if (i == paramArrayOfType.length - 1) {
              lexer.nextToken(15);
            } else {
              lexer.nextToken(2);
            }
            i += 1;
          }
          else
          {
            paramArrayOfType = new StringBuilder();
            paramArrayOfType.append("syntax error :");
            paramArrayOfType.append(JSONToken.name(lexer.token()));
            throw new JSONException(paramArrayOfType.toString());
          }
        }
      }
      if (lexer.token() == 15)
      {
        lexer.nextToken(16);
        return arrayOfObject;
      }
      throw new JSONException("syntax error");
    }
    paramArrayOfType = new StringBuilder();
    paramArrayOfType.append("syntax error : ");
    paramArrayOfType.append(lexer.tokenName());
    throw new JSONException(paramArrayOfType.toString());
  }
  
  public Object parseArrayWithType(Type paramType)
  {
    if (lexer.token() == 8)
    {
      lexer.nextToken();
      return null;
    }
    Object localObject1 = ((ParameterizedType)paramType).getActualTypeArguments();
    if (localObject1.length == 1)
    {
      localObject1 = localObject1[0];
      if ((localObject1 instanceof Class))
      {
        paramType = new ArrayList();
        parseArray((Class)localObject1, paramType);
        return paramType;
      }
      Object localObject2;
      if ((localObject1 instanceof WildcardType))
      {
        localObject2 = (WildcardType)localObject1;
        localObject1 = localObject2.getUpperBounds()[0];
        if (Object.class.equals(localObject1))
        {
          if (((WildcardType)localObject2).getLowerBounds().length == 0) {
            return parse();
          }
          localObject1 = new StringBuilder();
          ((StringBuilder)localObject1).append("not support type : ");
          ((StringBuilder)localObject1).append(paramType);
          throw new JSONException(((StringBuilder)localObject1).toString());
        }
        paramType = new ArrayList();
        parseArray((Class)localObject1, paramType);
        return paramType;
      }
      if ((localObject1 instanceof TypeVariable))
      {
        localObject2 = (TypeVariable)localObject1;
        Type[] arrayOfType = ((TypeVariable)localObject2).getBounds();
        if (arrayOfType.length == 1)
        {
          localObject2 = arrayOfType[0];
          if ((localObject2 instanceof Class))
          {
            paramType = new ArrayList();
            parseArray((Class)localObject2, paramType);
            return paramType;
          }
        }
        else
        {
          paramType = new StringBuilder();
          paramType.append("not support : ");
          paramType.append(localObject2);
          throw new JSONException(paramType.toString());
        }
      }
      if ((localObject1 instanceof ParameterizedType))
      {
        paramType = (ParameterizedType)localObject1;
        localObject1 = new ArrayList();
        parseArray(paramType, (Collection)localObject1);
        return localObject1;
      }
      localObject1 = new StringBuilder();
      ((StringBuilder)localObject1).append("TODO : ");
      ((StringBuilder)localObject1).append(paramType);
      throw new JSONException(((StringBuilder)localObject1).toString());
    }
    localObject1 = new StringBuilder();
    ((StringBuilder)localObject1).append("not support type ");
    ((StringBuilder)localObject1).append(paramType);
    throw new JSONException(((StringBuilder)localObject1).toString());
  }
  
  public Object parseKey()
  {
    if (lexer.token() == 18)
    {
      String str = lexer.stringVal();
      lexer.nextToken(16);
      return str;
    }
    return parse(null);
  }
  
  public JSONObject parseObject()
  {
    JSONObject localJSONObject = new JSONObject(isEnabled(Feature.OrderedField));
    parseObject(localJSONObject);
    return localJSONObject;
  }
  
  public Object parseObject(Class paramClass)
  {
    return parseObject(paramClass);
  }
  
  public Object parseObject(Type paramType)
  {
    if (lexer.token() == 8)
    {
      lexer.nextToken();
      return null;
    }
    Type localType = paramType;
    if (lexer.token() == 4)
    {
      paramType = TypeUtils.unwrap(paramType);
      localType = paramType;
      if (paramType == [B.class)
      {
        paramType = lexer.bytesValue();
        lexer.nextToken();
        return paramType;
      }
      if (paramType == [C.class)
      {
        paramType = lexer.stringVal();
        lexer.nextToken();
        return paramType.toCharArray();
      }
    }
    paramType = config.getDeserializer(localType);
    try
    {
      paramType = paramType.deserialze(this, localType, null);
      return paramType;
    }
    catch (Throwable paramType)
    {
      throw new JSONException(paramType.getMessage(), paramType);
    }
    catch (JSONException paramType)
    {
      throw paramType;
    }
  }
  
  public Object parseObject(Map paramMap)
  {
    return parseObject(paramMap, null);
  }
  
  public final Object parseObject(Map paramMap, Object paramObject)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a60 = a59\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:552)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:1)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:166)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:331)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:387)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:90)\n\t... 17 more\n");
  }
  
  public void parseObject(Object paramObject)
  {
    Class localClass = paramObject.getClass();
    Map localMap = config.getFieldDeserializers(localClass);
    if ((lexer.token() != 12) && (lexer.token() != 16))
    {
      paramObject = new StringBuilder();
      paramObject.append("syntax error, expect {, actual ");
      paramObject.append(lexer.tokenName());
      throw new JSONException(paramObject.toString());
    }
    label358:
    do
    {
      Object localObject2;
      do
      {
        do
        {
          localObject3 = lexer.scanSymbol(symbolTable);
          if (localObject3 != null) {
            break;
          }
          if (lexer.token() == 13)
          {
            lexer.nextToken(16);
            return;
          }
        } while ((lexer.token() == 16) && (isEnabled(Feature.AllowArbitraryCommas)));
        localObject1 = (FieldDeserializer)localMap.get(localObject3);
        localObject2 = localObject1;
        if (localObject1 == null)
        {
          localObject2 = localObject1;
          if (localObject3 != null)
          {
            Iterator localIterator = localMap.entrySet().iterator();
            do
            {
              localObject2 = localObject1;
              if (!localIterator.hasNext()) {
                break;
              }
              localObject2 = (Map.Entry)localIterator.next();
            } while (!((String)localObject3).equalsIgnoreCase((String)((Map.Entry)localObject2).getKey()));
            localObject2 = (FieldDeserializer)((Map.Entry)localObject2).getValue();
          }
        }
        if (localObject2 != null) {
          break label358;
        }
        if (!isEnabled(Feature.IgnoreNotMatch)) {
          break;
        }
        lexer.nextTokenWithColon();
        parse();
      } while (lexer.token() != 13);
      lexer.nextToken();
      return;
      paramObject = new StringBuilder();
      paramObject.append("setter not found, class ");
      paramObject.append(localClass.getName());
      paramObject.append(", property ");
      paramObject.append((String)localObject3);
      throw new JSONException(paramObject.toString());
      Object localObject3 = ((FieldDeserializer)localObject2).getFieldClass();
      Object localObject1 = ((FieldDeserializer)localObject2).getFieldType();
      if (localObject3 == Integer.TYPE)
      {
        lexer.nextTokenWithColon(2);
        localObject1 = IntegerCodec.instance.deserialze(this, (Type)localObject1, null);
      }
      else if (localObject3 == String.class)
      {
        lexer.nextTokenWithColon(4);
        localObject1 = StringCodec.deserialze(this);
      }
      else if (localObject3 == Long.TYPE)
      {
        lexer.nextTokenWithColon(2);
        localObject1 = LongCodec.instance.deserialze(this, (Type)localObject1, null);
      }
      else
      {
        localObject3 = config.getDeserializer((Class)localObject3, (Type)localObject1);
        lexer.nextTokenWithColon(((ObjectDeserializer)localObject3).getFastMatchToken());
        localObject1 = ((ObjectDeserializer)localObject3).deserialze(this, (Type)localObject1, null);
      }
      ((FieldDeserializer)localObject2).setValue(paramObject, localObject1);
    } while ((lexer.token() == 16) || (lexer.token() != 13));
    lexer.nextToken(16);
  }
  
  public void popContext()
  {
    if (isEnabled(Feature.DisableCircularReferenceDetect)) {
      return;
    }
    context = context.getParentContext();
    ParseContext[] arrayOfParseContext = contextArray;
    int i = contextArrayIndex;
    arrayOfParseContext[(i - 1)] = null;
    contextArrayIndex = (i - 1);
  }
  
  public void setConfig(ParserConfig paramParserConfig)
  {
    config = paramParserConfig;
  }
  
  public ParseContext setContext(ParseContext paramParseContext, Object paramObject1, Object paramObject2)
  {
    if (isEnabled(Feature.DisableCircularReferenceDetect)) {
      return null;
    }
    context = new ParseContext(paramParseContext, paramObject1, paramObject2);
    addContext(context);
    return context;
  }
  
  public ParseContext setContext(Object paramObject1, Object paramObject2)
  {
    if (isEnabled(Feature.DisableCircularReferenceDetect)) {
      return null;
    }
    return setContext(context, paramObject1, paramObject2);
  }
  
  public void setContext(ParseContext paramParseContext)
  {
    if (isEnabled(Feature.DisableCircularReferenceDetect)) {
      return;
    }
    context = paramParseContext;
  }
  
  public void setDateFomrat(DateFormat paramDateFormat)
  {
    dateFormat = paramDateFormat;
  }
  
  public void setDateFormat(String paramString)
  {
    dateFormatPattern = paramString;
    dateFormat = null;
  }
  
  public void setResolveStatus(int paramInt)
  {
    resolveStatus = paramInt;
  }
  
  public static class ResolveTask
  {
    private final ParseContext context;
    private FieldDeserializer fieldDeserializer;
    private ParseContext ownerContext;
    private final String referenceValue;
    
    public ResolveTask(ParseContext paramParseContext, String paramString)
    {
      context = paramParseContext;
      referenceValue = paramString;
    }
    
    public ParseContext getContext()
    {
      return context;
    }
    
    public FieldDeserializer getFieldDeserializer()
    {
      return fieldDeserializer;
    }
    
    public ParseContext getOwnerContext()
    {
      return ownerContext;
    }
    
    public String getReferenceValue()
    {
      return referenceValue;
    }
    
    public void setFieldDeserializer(FieldDeserializer paramFieldDeserializer)
    {
      fieldDeserializer = paramFieldDeserializer;
    }
    
    public void setOwnerContext(ParseContext paramParseContext)
    {
      ownerContext = paramParseContext;
    }
  }
}
