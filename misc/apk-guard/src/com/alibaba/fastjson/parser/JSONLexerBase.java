package com.alibaba.fastjson.parser;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONException;
import com.alibaba.fastjson.util.IOUtils;
import java.io.Closeable;
import java.lang.ref.SoftReference;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public abstract class JSONLexerBase
  implements JSONLexer, Closeable
{
  private static final Map<String, Integer> DEFAULT_KEYWORDS;
  protected static final int INT_MULTMIN_RADIX_TEN = -214748364;
  protected static final int INT_N_MULTMAX_RADIX_TEN = -214748364;
  protected static final long MULTMIN_RADIX_TEN = -922337203685477580L;
  protected static final long N_MULTMAX_RADIX_TEN = -922337203685477580L;
  private static final ThreadLocal<SoftReference<char[]>> SBUF_REF_LOCAL;
  protected static final int[] digits;
  protected static final char[] typeFieldName;
  protected int buf;
  protected Calendar calendar = null;
  protected int eofPos;
  protected int features = JSON.DEFAULT_PARSER_FEATURE;
  protected boolean hasSpecial;
  protected char idx;
  protected Map<String, Integer> keywods = DEFAULT_KEYWORDS;
  protected int len;
  public int matchStat = 0;
  protected int off;
  protected int pos;
  protected char[] sbuf;
  protected int token;
  
  static
  {
    Object localObject = new HashMap();
    ((Map)localObject).put("null", Integer.valueOf(8));
    ((Map)localObject).put("new", Integer.valueOf(9));
    ((Map)localObject).put("true", Integer.valueOf(6));
    ((Map)localObject).put("false", Integer.valueOf(7));
    ((Map)localObject).put("undefined", Integer.valueOf(23));
    DEFAULT_KEYWORDS = (Map)localObject;
    SBUF_REF_LOCAL = new ThreadLocal();
    localObject = new StringBuilder();
    ((StringBuilder)localObject).append("\"");
    ((StringBuilder)localObject).append(JSON.DEFAULT_TYPE_KEY);
    ((StringBuilder)localObject).append("\":\"");
    typeFieldName = ((StringBuilder)localObject).toString().toCharArray();
    digits = new int[103];
    int i = 48;
    while (i <= 57)
    {
      digits[i] = (i - 48);
      i += 1;
    }
    i = 97;
    while (i <= 102)
    {
      digits[i] = (i - 97 + 10);
      i += 1;
    }
    i = 65;
    while (i <= 70)
    {
      digits[i] = (i - 65 + 10);
      i += 1;
    }
  }
  
  public JSONLexerBase()
  {
    SoftReference localSoftReference = (SoftReference)SBUF_REF_LOCAL.get();
    if (localSoftReference != null)
    {
      sbuf = ((char[])localSoftReference.get());
      SBUF_REF_LOCAL.set(null);
    }
    if (sbuf == null) {
      sbuf = new char[64];
    }
  }
  
  public static boolean isWhitespace(char paramChar)
  {
    return (paramChar == ' ') || (paramChar == '\n') || (paramChar == '\r') || (paramChar == '\t') || (paramChar == '\f') || (paramChar == '\b');
  }
  
  private void scanStringSingleQuote()
  {
    off = len;
    hasSpecial = false;
    for (;;)
    {
      char c = next();
      if (c == '\'')
      {
        token = 4;
        next();
        return;
      }
      if (c == '\032') {
        break;
      }
      int i;
      Object localObject;
      if (c == '\\')
      {
        if (!hasSpecial)
        {
          hasSpecial = true;
          i = buf;
          localObject = sbuf;
          if (i > localObject.length)
          {
            char[] arrayOfChar = new char[i * 2];
            System.arraycopy(localObject, 0, arrayOfChar, 0, localObject.length);
            sbuf = arrayOfChar;
          }
          copyTo(off + 1, buf, sbuf);
        }
        c = next();
        switch (c)
        {
        default: 
          switch (c)
          {
          default: 
            switch (c)
            {
            default: 
              idx = c;
              throw new JSONException("unclosed single-quote string");
            case 'x': 
              i = next();
              int j = next();
              localObject = digits;
              putChar((char)(localObject[i] * 16 + localObject[j]));
              break;
            case 'r': 
              putChar('\r');
              break;
            case 'n': 
              putChar('\n');
              break;
            case 'b': 
              putChar('\b');
              break;
            case '\\': 
              putChar('\\');
              break;
            case 'F': 
            case 'f': 
              putChar('\f');
              break;
            case '\'': 
              putChar('\'');
              break;
            case '"': 
              putChar('"');
            }
            break;
          case 'v': 
            putChar('\013');
            break;
          case 'u': 
            putChar((char)Integer.parseInt(new String(new char[] { next(), next(), next(), next() }), 16));
            break;
          case 't': 
            putChar('\t');
          }
          break;
        case '7': 
          putChar('\007');
          break;
        case '6': 
          putChar('\006');
          break;
        case '5': 
          putChar('\005');
          break;
        case '4': 
          putChar('\004');
          break;
        case '3': 
          putChar('\003');
          break;
        case '2': 
          putChar('\002');
          break;
        case '1': 
          putChar('\001');
          break;
        case '0': 
          putChar('\000');
          break;
        case '/': 
          putChar('/');
          break;
        }
      }
      else if (!hasSpecial)
      {
        buf += 1;
      }
      else
      {
        i = buf;
        localObject = sbuf;
        if (i == localObject.length)
        {
          putChar(c);
        }
        else
        {
          buf = (i + 1);
          localObject[i] = c;
        }
      }
    }
    throw new JSONException("unclosed single-quote string");
  }
  
  public abstract String addSymbol(int paramInt1, int paramInt2, int paramInt3, SymbolTable paramSymbolTable);
  
  protected abstract void arrayCopy(int paramInt1, char[] paramArrayOfChar, int paramInt2, int paramInt3);
  
  public abstract byte[] bytesValue();
  
  protected abstract boolean charArrayCompare(char[] paramArrayOfChar);
  
  public abstract char charAt(int paramInt);
  
  public void close()
  {
    char[] arrayOfChar = sbuf;
    if (arrayOfChar.length <= 8192) {
      SBUF_REF_LOCAL.set(new SoftReference(arrayOfChar));
    }
    sbuf = null;
  }
  
  public void config(Feature paramFeature, boolean paramBoolean)
  {
    features = Feature.config(features, paramFeature, paramBoolean);
  }
  
  protected abstract void copyTo(int paramInt1, int paramInt2, char[] paramArrayOfChar);
  
  public final Number decimalValue(boolean paramBoolean)
  {
    int i = charAt(off + buf - 1);
    if (i == 70) {
      return Float.valueOf(Float.parseFloat(numberString()));
    }
    if (i == 68) {
      return Double.valueOf(Double.parseDouble(numberString()));
    }
    if (paramBoolean) {
      return decimalValue();
    }
    return Double.valueOf(doubleValue());
  }
  
  public final BigDecimal decimalValue()
  {
    return new BigDecimal(numberString());
  }
  
  public double doubleValue()
  {
    return Double.parseDouble(numberString());
  }
  
  public float floatValue()
  {
    return Float.parseFloat(numberString());
  }
  
  public final int getBufferPosition()
  {
    return len;
  }
  
  public Calendar getCalendar()
  {
    return calendar;
  }
  
  public final char getCurrent()
  {
    return idx;
  }
  
  public final int getPos()
  {
    return pos;
  }
  
  public abstract int indexOf(char paramChar, int paramInt);
  
  public final int intValue()
  {
    int i = off;
    int j = 0;
    if (i == -1) {
      off = 0;
    }
    int k = off;
    int i1 = buf + k;
    int m;
    int n;
    if (charAt(k) == '-')
    {
      k += 1;
      m = 1;
      n = Integer.MIN_VALUE;
    }
    else
    {
      m = 0;
      n = -2147483647;
    }
    i = k;
    if (k < i1) {
      j = -digits[charAt(k)];
    }
    for (i = k + 1;; i = k)
    {
      k = i;
      if (i >= i1) {
        break label181;
      }
      k = i + 1;
      i = charAt(i);
      if ((i == 76) || (i == 83) || (i == 66)) {
        break label181;
      }
      i = digits[i];
      if (j < -214748364) {
        break label169;
      }
      j *= 10;
      if (j < n + i) {
        break;
      }
      j -= i;
    }
    throw new NumberFormatException(numberString());
    label169:
    throw new NumberFormatException(numberString());
    label181:
    if (m != 0)
    {
      if (k > off + 1) {
        return j;
      }
      throw new NumberFormatException(numberString());
    }
    return -j;
  }
  
  public final Number integerValue()
    throws NumberFormatException
  {
    int i = off;
    int m = 0;
    if (i == -1) {
      off = 0;
    }
    int k = off;
    i = buf + k;
    int j = 32;
    int n = charAt(i - 1);
    if (n != 66)
    {
      if (n != 76)
      {
        if (n == 83)
        {
          i -= 1;
          j = 83;
        }
      }
      else
      {
        i -= 1;
        j = 76;
      }
    }
    else
    {
      i -= 1;
      j = 66;
    }
    long l2;
    if (charAt(off) == '-')
    {
      l2 = Long.MIN_VALUE;
      k += 1;
      m = 1;
    }
    else
    {
      l2 = -9223372036854775807L;
    }
    if (k < i)
    {
      n = -digits[charAt(k)];
      k += 1;
      l1 = n;
    }
    else
    {
      l1 = 0L;
    }
    while (k < i)
    {
      n = digits[charAt(k)];
      if (l1 < -922337203685477580L) {
        return new BigInteger(numberString());
      }
      l1 *= 10L;
      long l3 = n;
      if (l1 < l2 + l3) {
        return new BigInteger(numberString());
      }
      l1 -= l3;
      k += 1;
    }
    if (m != 0)
    {
      if (k > off + 1)
      {
        if ((l1 >= -2147483648L) && (j != 76))
        {
          if (j == 83) {
            return Short.valueOf((short)(int)l1);
          }
          if (j == 66) {
            return Byte.valueOf((byte)(int)l1);
          }
          return Integer.valueOf((int)l1);
        }
        return Long.valueOf(l1);
      }
      throw new NumberFormatException(numberString());
    }
    long l1 = -l1;
    if ((l1 <= 2147483647L) && (j != 76))
    {
      if (j == 83) {
        return Short.valueOf((short)(int)l1);
      }
      if (j == 66) {
        return Byte.valueOf((byte)(int)l1);
      }
      return Integer.valueOf((int)l1);
    }
    return Long.valueOf(l1);
  }
  
  public final boolean isBlankInput()
  {
    int i = 0;
    for (;;)
    {
      char c = charAt(i);
      if (c == '\032') {
        return true;
      }
      if (!isWhitespace(c)) {
        return false;
      }
      i += 1;
    }
  }
  
  public abstract boolean isEOF();
  
  public final boolean isEnabled(Feature paramFeature)
  {
    return Feature.isEnabled(features, paramFeature);
  }
  
  public final boolean isRef()
  {
    if (buf != 4) {
      return false;
    }
    return (charAt(off + 1) == '$') && (charAt(off + 2) == 'r') && (charAt(off + 3) == 'e') && (charAt(off + 4) == 'f');
  }
  
  protected void lexError(String paramString, Object... paramVarArgs)
  {
    token = 1;
  }
  
  public final long longValue()
    throws NumberFormatException
  {
    int i = off;
    int j = 0;
    if (i == -1) {
      off = 0;
    }
    i = off;
    int m = buf + i;
    long l2;
    if (charAt(i) == '-')
    {
      l2 = Long.MIN_VALUE;
      i += 1;
      j = 1;
    }
    else
    {
      l2 = -9223372036854775807L;
    }
    long l1;
    if (i < m)
    {
      l1 = -digits[charAt(i)];
      i += 1;
    }
    else
    {
      l1 = 0L;
    }
    int k;
    for (;;)
    {
      k = i;
      if (i >= m) {
        break label201;
      }
      k = i + 1;
      i = charAt(i);
      if ((i == 76) || (i == 83) || (i == 66)) {
        break label201;
      }
      i = digits[i];
      if (l1 < -922337203685477580L) {
        break label189;
      }
      l1 *= 10L;
      long l3 = i;
      if (l1 < l2 + l3) {
        break;
      }
      l1 -= l3;
      i = k;
    }
    throw new NumberFormatException(numberString());
    label189:
    throw new NumberFormatException(numberString());
    label201:
    if (j != 0)
    {
      if (k > off + 1) {
        return l1;
      }
      throw new NumberFormatException(numberString());
    }
    return -l1;
  }
  
  public final boolean matchField(char[] paramArrayOfChar)
  {
    if (!charArrayCompare(paramArrayOfChar)) {
      return false;
    }
    len += paramArrayOfChar.length;
    idx = charAt(len);
    int i = idx;
    if (i == 123)
    {
      next();
      token = 12;
    }
    else if (i == 91)
    {
      next();
      token = 14;
    }
    else
    {
      nextToken();
    }
    return true;
  }
  
  public final int matchStat()
  {
    return matchStat;
  }
  
  public abstract char next();
  
  public final void nextIdent()
  {
    while (isWhitespace(idx)) {
      next();
    }
    char c = idx;
    if ((c != '_') && (!Character.isLetter(c)))
    {
      nextToken();
      return;
    }
    scanIdent();
  }
  
  public final void nextToken()
  {
    buf = 0;
    for (;;)
    {
      pos = len;
      int i = idx;
      if (i == 34)
      {
        scanString();
        return;
      }
      if (i == 44)
      {
        next();
        token = 16;
        return;
      }
      if ((i >= 48) && (i <= 57))
      {
        scanNumber();
        return;
      }
      i = idx;
      if (i == 45)
      {
        scanNumber();
        return;
      }
      switch (i)
      {
      default: 
        if (!isEOF()) {
          break label465;
        }
        if (token == 20) {
          break;
        }
        token = 20;
        i = eofPos;
        len = i;
        pos = i;
        return;
      case 125: 
        next();
        token = 13;
        return;
      case 123: 
        next();
        token = 12;
        return;
      case 117: 
        scanUndefined();
        return;
      case 116: 
        scanTrue();
        return;
      case 110: 
        scanNullOrNew();
        return;
      case 102: 
        scanFalse();
        return;
      case 93: 
        next();
        token = 15;
        return;
      case 91: 
        next();
        token = 14;
        return;
      case 84: 
        scanTreeSet();
        return;
      case 83: 
        scanSet();
        return;
      case 78: 
        scanNULL();
        return;
      case 58: 
        next();
        token = 17;
        return;
      case 41: 
        next();
        token = 11;
        return;
      case 40: 
        next();
        token = 10;
        return;
      case 39: 
        if (isEnabled(Feature.AllowSingleQuotes))
        {
          scanStringSingleQuote();
          return;
        }
        throw new JSONException("Feature.AllowSingleQuotes is false");
      case 8: 
      case 9: 
      case 10: 
      case 12: 
      case 13: 
      case 32: 
        next();
      }
    }
    throw new JSONException("EOF error");
    label465:
    lexError("illegal.char", new Object[] { String.valueOf(idx) });
    next();
  }
  
  public final void nextToken(int paramInt)
  {
    buf = 0;
    for (;;)
    {
      if (paramInt != 2)
      {
        if (paramInt != 4)
        {
          if (paramInt != 12)
          {
            if (paramInt != 18)
            {
              if (paramInt != 20) {
                switch (paramInt)
                {
                default: 
                  break;
                case 16: 
                  i = idx;
                  if (i == 44)
                  {
                    token = 16;
                    next();
                    return;
                  }
                  if (i == 125)
                  {
                    token = 13;
                    next();
                    return;
                  }
                  if (i == 93)
                  {
                    token = 15;
                    next();
                    return;
                  }
                  if (i != 26) {
                    break label450;
                  }
                  token = 20;
                  return;
                case 15: 
                  if (idx == ']')
                  {
                    token = 15;
                    next();
                    return;
                  }
                  break;
                case 14: 
                  i = idx;
                  if (i == 91)
                  {
                    token = 14;
                    next();
                    return;
                  }
                  if (i != 123) {
                    break label450;
                  }
                  token = 12;
                  next();
                  return;
                }
              }
              if (idx == '\032') {
                token = 20;
              }
            }
            else
            {
              nextIdent();
            }
          }
          else
          {
            i = idx;
            if (i == 123)
            {
              token = 12;
              next();
              return;
            }
            if (i == 91)
            {
              token = 14;
              next();
            }
          }
        }
        else
        {
          i = idx;
          if (i == 34)
          {
            pos = len;
            scanString();
            return;
          }
          if ((i >= 48) && (i <= 57))
          {
            pos = len;
            scanNumber();
            return;
          }
          i = idx;
          if (i == 91)
          {
            token = 14;
            next();
            return;
          }
          if (i == 123)
          {
            token = 12;
            next();
          }
        }
      }
      else
      {
        i = idx;
        if ((i >= 48) && (i <= 57))
        {
          pos = len;
          scanNumber();
          return;
        }
        i = idx;
        if (i == 34)
        {
          pos = len;
          scanString();
          return;
        }
        if (i == 91)
        {
          token = 14;
          next();
          return;
        }
        if (i == 123)
        {
          token = 12;
          next();
          return;
        }
      }
      label450:
      int i = idx;
      if ((i != 32) && (i != 10) && (i != 13) && (i != 9) && (i != 12) && (i != 8))
      {
        nextToken();
        return;
      }
      next();
    }
  }
  
  public final void nextTokenWithChar(char paramChar)
  {
    buf = 0;
    for (;;)
    {
      char c = idx;
      if (c == paramChar)
      {
        next();
        nextToken();
        return;
      }
      if ((c != ' ') && (c != '\n') && (c != '\r') && (c != '\t') && (c != '\f') && (c != '\b'))
      {
        StringBuilder localStringBuilder = new StringBuilder();
        localStringBuilder.append("not match ");
        localStringBuilder.append(paramChar);
        localStringBuilder.append(" - ");
        localStringBuilder.append(idx);
        throw new JSONException(localStringBuilder.toString());
      }
      next();
    }
  }
  
  public final void nextTokenWithChar(char paramChar, int paramInt)
  {
    buf = 0;
    for (;;)
    {
      char c = idx;
      if (c == paramChar)
      {
        next();
        for (;;)
        {
          if (paramInt == 2)
          {
            paramChar = idx;
            if ((paramChar >= '0') && (paramChar <= '9'))
            {
              pos = len;
              scanNumber();
              return;
            }
            if (idx == '"')
            {
              pos = len;
              scanString();
            }
          }
          else if (paramInt == 4)
          {
            paramChar = idx;
            if (paramChar == '"')
            {
              pos = len;
              scanString();
              return;
            }
            if ((paramChar >= '0') && (paramChar <= '9'))
            {
              pos = len;
              scanNumber();
            }
          }
          else if (paramInt == 12)
          {
            paramChar = idx;
            if (paramChar == '{')
            {
              token = 12;
              next();
              return;
            }
            if (paramChar == '[')
            {
              token = 14;
              next();
            }
          }
          else if (paramInt == 14)
          {
            paramChar = idx;
            if (paramChar == '[')
            {
              token = 14;
              next();
              return;
            }
            if (paramChar == '{')
            {
              token = 12;
              next();
              return;
            }
          }
          if (!isWhitespace(idx)) {
            break;
          }
          next();
        }
        nextToken();
        return;
      }
      if (!isWhitespace(c)) {
        break;
      }
      next();
    }
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("not match ");
    localStringBuilder.append(paramInt);
    localStringBuilder.append(" - ");
    localStringBuilder.append(idx);
    throw new JSONException(localStringBuilder.toString());
  }
  
  public final void nextTokenWithColon()
  {
    nextTokenWithChar(':');
  }
  
  public final void nextTokenWithColon(int paramInt)
  {
    nextTokenWithChar(':');
  }
  
  public final void nextTokenWithComma()
  {
    nextTokenWithChar(':');
  }
  
  public final void nextTokenWithComma(int paramInt)
  {
    nextTokenWithChar(',');
  }
  
  public abstract String numberString();
  
  protected final void putChar(char paramChar)
  {
    int i = buf;
    char[] arrayOfChar1 = sbuf;
    if (i == arrayOfChar1.length)
    {
      char[] arrayOfChar2 = new char[arrayOfChar1.length * 2];
      System.arraycopy(arrayOfChar1, 0, arrayOfChar2, 0, arrayOfChar1.length);
      sbuf = arrayOfChar2;
    }
    arrayOfChar1 = sbuf;
    i = buf;
    buf = (i + 1);
    arrayOfChar1[i] = paramChar;
  }
  
  public final void resetStringPosition()
  {
    buf = 0;
  }
  
  public boolean scanBoolean(char paramChar)
  {
    boolean bool = false;
    matchStat = 0;
    char c2 = charAt(len + 0);
    char c1 = c2;
    int i = 5;
    if (c2 == 't')
    {
      if ((charAt(len + 1) == 'r') && (charAt(len + 1 + 1) == 'u') && (charAt(len + 1 + 2) == 'e'))
      {
        c1 = charAt(len + 4);
        bool = true;
      }
      else
      {
        matchStat = -1;
        return false;
      }
    }
    else if (c2 == 'f')
    {
      if ((charAt(len + 1) == 'a') && (charAt(len + 1 + 1) == 'l') && (charAt(len + 1 + 2) == 's') && (charAt(len + 1 + 3) == 'e'))
      {
        c1 = charAt(len + 5);
        i = 6;
      }
      else
      {
        matchStat = -1;
        return false;
      }
    }
    else {
      i = 1;
    }
    if (c1 == paramChar)
    {
      len += i - 1;
      next();
      matchStat = 3;
      return bool;
    }
    matchStat = -1;
    return bool;
  }
  
  public Enum scanEnum(Class paramClass, SymbolTable paramSymbolTable, char paramChar)
  {
    paramSymbolTable = scanSymbolWithSeperator(paramSymbolTable, paramChar);
    if (paramSymbolTable == null) {
      return null;
    }
    return Enum.valueOf(paramClass, paramSymbolTable);
  }
  
  public final void scanFalse()
  {
    if (idx == 'f')
    {
      next();
      if (idx == 'a')
      {
        next();
        if (idx == 'l')
        {
          next();
          if (idx == 's')
          {
            next();
            if (idx == 'e')
            {
              next();
              int i = idx;
              if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8) && (i != 58)) {
                throw new JSONException("scan false error");
              }
              token = 7;
              return;
            }
            throw new JSONException("error parse false");
          }
          throw new JSONException("error parse false");
        }
        throw new JSONException("error parse false");
      }
      throw new JSONException("error parse false");
    }
    throw new JSONException("error parse false");
  }
  
  public boolean scanFieldBoolean(char[] paramArrayOfChar)
  {
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return false;
    }
    int j = paramArrayOfChar.length;
    int k = len;
    int i = j + 1;
    j = charAt(k + j);
    boolean bool;
    if (j == 116)
    {
      k = len;
      j = i + 1;
      if (charAt(k + i) != 'r')
      {
        matchStat = -1;
        return false;
      }
      i = len;
      k = j + 1;
      if (charAt(i + j) != 'u')
      {
        matchStat = -1;
        return false;
      }
      j = len;
      i = k + 1;
      if (charAt(j + k) != 'e')
      {
        matchStat = -1;
        return false;
      }
      bool = true;
    }
    else
    {
      if (j != 102) {
        break label499;
      }
      k = len;
      j = i + 1;
      if (charAt(k + i) != 'a')
      {
        matchStat = -1;
        return false;
      }
      k = len;
      i = j + 1;
      if (charAt(k + j) != 'l')
      {
        matchStat = -1;
        return false;
      }
      j = len;
      k = i + 1;
      if (charAt(j + i) != 's')
      {
        matchStat = -1;
        return false;
      }
      if (charAt(len + k) != 'e')
      {
        matchStat = -1;
        return false;
      }
      i = k + 1;
      bool = false;
    }
    k = len;
    j = i + 1;
    i = charAt(k + i);
    if (i == 44)
    {
      len += j - 1;
      next();
      matchStat = 3;
      token = 16;
      return bool;
    }
    if (i == 125)
    {
      k = len;
      i = j + 1;
      j = charAt(k + j);
      if (j == 44)
      {
        token = 16;
        len += i - 1;
        next();
      }
      else if (j == 93)
      {
        token = 15;
        len += i - 1;
        next();
      }
      else if (j == 125)
      {
        token = 13;
        len += i - 1;
        next();
      }
      else
      {
        if (j != 26) {
          break label485;
        }
        token = 20;
        len += i - 1;
        idx = '\032';
      }
      matchStat = 4;
      return bool;
      label485:
      matchStat = -1;
      return false;
    }
    matchStat = -1;
    return false;
    label499:
    matchStat = -1;
    return false;
  }
  
  public final double scanFieldDouble(char paramChar)
  {
    matchStat = 0;
    char c1 = charAt(len + 0);
    if ((c1 >= '0') && (c1 <= '9'))
    {
      char c2;
      char c3;
      char c4;
      for (c1 = '\001';; c1 = c3)
      {
        c2 = len;
        c3 = c1 + '\001';
        c4 = charAt(c2 + c1);
        c2 = c4;
        if ((c4 < '0') || (c4 > '9')) {
          break;
        }
      }
      c1 = c3;
      if (c4 == '.')
      {
        c2 = len;
        c1 = c3 + '\001';
        c2 = charAt(c2 + c3);
        if ((c2 >= '0') && (c2 <= '9')) {
          for (;;)
          {
            c2 = len;
            c3 = c1 + '\001';
            char c5 = charAt(c2 + c1);
            c4 = c5;
            c1 = c3;
            c2 = c4;
            if (c5 < '0') {
              break;
            }
            c1 = c3;
            c2 = c4;
            if (c5 > '9') {
              break;
            }
            c1 = c3;
          }
        }
        matchStat = -1;
        return 0.0D;
      }
      if (c2 != 'e')
      {
        c3 = c1;
        c4 = c2;
        if (c2 != 'E') {}
      }
      else
      {
        c3 = len;
        c2 = c1 + '\001';
        c3 = charAt(c3 + c1);
        if ((c3 != '+') && (c3 != '-'))
        {
          c1 = c2;
          c2 = c3;
        }
        else
        {
          c3 = len;
          c1 = c2 + '\001';
          c2 = charAt(c3 + c2);
        }
        for (;;)
        {
          c3 = c1;
          c4 = c2;
          if (c2 < '0') {
            break;
          }
          c3 = c1;
          c4 = c2;
          if (c2 > '9') {
            break;
          }
          c2 = charAt(len + c1);
          c1 += '\001';
        }
      }
      c1 = len;
      double d = Double.parseDouble(subString(c1, c1 + c3 - c1 - 1));
      if (c4 == paramChar)
      {
        len += c3 - '\001';
        next();
        matchStat = 3;
        token = 16;
        return d;
      }
      matchStat = -1;
      return d;
    }
    matchStat = -1;
    return 0.0D;
  }
  
  public final double scanFieldDouble(char[] paramArrayOfChar)
  {
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return 0.0D;
    }
    int j = paramArrayOfChar.length;
    int k = len;
    int i = j + 1;
    j = charAt(k + j);
    if ((j >= 48) && (j <= 57))
    {
      int m;
      for (;;)
      {
        j = len;
        k = i + 1;
        m = charAt(j + i);
        j = m;
        if ((m < 48) || (m > 57)) {
          break;
        }
        i = k;
      }
      i = k;
      if (m == 46)
      {
        j = len;
        i = k + 1;
        j = charAt(j + k);
        if ((j >= 48) && (j <= 57)) {
          for (;;)
          {
            j = len;
            k = i + 1;
            int n = charAt(j + i);
            m = n;
            i = k;
            j = m;
            if (n < 48) {
              break;
            }
            i = k;
            j = m;
            if (n > 57) {
              break;
            }
            i = k;
          }
        }
        matchStat = -1;
        return 0.0D;
      }
      if (j != 101)
      {
        k = i;
        m = j;
        if (j != 69) {}
      }
      else
      {
        j = len;
        k = i + 1;
        i = charAt(j + i);
        j = i;
        if ((i != 43) && (i != 45))
        {
          i = k;
        }
        else
        {
          j = len;
          i = k + 1;
          j = charAt(j + k);
        }
        for (;;)
        {
          k = i;
          m = j;
          if (j < 48) {
            break;
          }
          k = i;
          m = j;
          if (j > 57) {
            break;
          }
          j = charAt(len + i);
          i += 1;
        }
      }
      i = len;
      j = paramArrayOfChar.length + i;
      double d = Double.parseDouble(subString(j, i + k - j - 1));
      if (m == 44)
      {
        len += k - 1;
        next();
        matchStat = 3;
        token = 16;
        return d;
      }
      if (m == 125)
      {
        j = len;
        i = k + 1;
        j = charAt(j + k);
        if (j == 44)
        {
          token = 16;
          len += i - 1;
          next();
        }
        else if (j == 93)
        {
          token = 15;
          len += i - 1;
          next();
        }
        else if (j == 125)
        {
          token = 13;
          len += i - 1;
          next();
        }
        else
        {
          if (j != 26) {
            break label619;
          }
          token = 20;
          len += i - 1;
          idx = '\032';
        }
        matchStat = 4;
        return d;
        label619:
        matchStat = -1;
        return 0.0D;
      }
      matchStat = -1;
      return 0.0D;
    }
    matchStat = -1;
    return 0.0D;
  }
  
  public final float scanFieldFloat(char[] paramArrayOfChar)
  {
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return 0.0F;
    }
    int j = paramArrayOfChar.length;
    int k = len;
    int i = j + 1;
    j = charAt(k + j);
    if ((j >= 48) && (j <= 57))
    {
      for (;;)
      {
        k = len;
        j = i + 1;
        m = charAt(k + i);
        k = m;
        if ((m < 48) || (m > 57)) {
          break;
        }
        i = j;
      }
      i = j;
      if (m == 46)
      {
        k = len;
        i = j + 1;
        j = charAt(k + j);
        if ((j >= 48) && (j <= 57)) {
          for (;;)
          {
            k = len;
            j = i + 1;
            int n = charAt(k + i);
            m = n;
            i = j;
            k = m;
            if (n < 48) {
              break;
            }
            i = j;
            k = m;
            if (n > 57) {
              break;
            }
            i = j;
          }
        }
        matchStat = -1;
        return 0.0F;
      }
      j = len;
      int m = paramArrayOfChar.length + j;
      float f = Float.parseFloat(subString(m, j + i - m - 1));
      if (k == 44)
      {
        len += i - 1;
        next();
        matchStat = 3;
        token = 16;
        return f;
      }
      if (k == 125)
      {
        k = len;
        j = i + 1;
        i = charAt(k + i);
        if (i == 44)
        {
          token = 16;
          len += j - 1;
          next();
        }
        else if (i == 93)
        {
          token = 15;
          len += j - 1;
          next();
        }
        else if (i == 125)
        {
          token = 13;
          len += j - 1;
          next();
        }
        else
        {
          if (i != 26) {
            break label451;
          }
          len += j - 1;
          token = 20;
          idx = '\032';
        }
        matchStat = 4;
        return f;
        label451:
        matchStat = -1;
        return 0.0F;
      }
      matchStat = -1;
      return 0.0F;
    }
    matchStat = -1;
    return 0.0F;
  }
  
  public int scanFieldInt(char[] paramArrayOfChar)
  {
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return 0;
    }
    int i = paramArrayOfChar.length;
    int k = len;
    int j = i + 1;
    i = charAt(k + i);
    if ((i >= 48) && (i <= 57))
    {
      i = digits[i];
      int m;
      for (;;)
      {
        m = len;
        k = j + 1;
        j = charAt(m + j);
        if ((j < 48) || (j > 57)) {
          break;
        }
        i = i * 10 + digits[j];
        j = k;
      }
      if (j == 46)
      {
        matchStat = -1;
        return 0;
      }
      if (i < 0)
      {
        matchStat = -1;
        return 0;
      }
      if (j == 44)
      {
        len += k - 1;
        next();
        matchStat = 3;
        token = 16;
        return i;
      }
      if (j == 125)
      {
        m = len;
        j = k + 1;
        k = charAt(m + k);
        if (k == 44)
        {
          token = 16;
          len += j - 1;
          next();
        }
        else if (k == 93)
        {
          token = 15;
          len += j - 1;
          next();
        }
        else if (k == 125)
        {
          token = 13;
          len += j - 1;
          next();
        }
        else
        {
          if (k != 26) {
            break label336;
          }
          token = 20;
          len += j - 1;
          idx = '\032';
        }
        matchStat = 4;
        return i;
        label336:
        matchStat = -1;
        return 0;
      }
      matchStat = -1;
      return 0;
    }
    matchStat = -1;
    return 0;
  }
  
  public long scanFieldLong(char[] paramArrayOfChar)
  {
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return 0L;
    }
    int j = paramArrayOfChar.length;
    int k = len;
    int i = j + 1;
    j = charAt(k + j);
    if ((j >= 48) && (j <= 57))
    {
      long l = digits[j];
      for (;;)
      {
        k = len;
        j = i + 1;
        i = charAt(k + i);
        if ((i < 48) || (i > 57)) {
          break;
        }
        l = l * 10L + digits[i];
        i = j;
      }
      if (i == 46)
      {
        matchStat = -1;
        return 0L;
      }
      if (l < 0L)
      {
        matchStat = -1;
        return 0L;
      }
      if (i == 44)
      {
        len += j - 1;
        next();
        matchStat = 3;
        token = 16;
        return l;
      }
      if (i == 125)
      {
        k = len;
        i = j + 1;
        j = charAt(k + j);
        if (j == 44)
        {
          token = 16;
          len += i - 1;
          next();
        }
        else if (j == 93)
        {
          token = 15;
          len += i - 1;
          next();
        }
        else if (j == 125)
        {
          token = 13;
          len += i - 1;
          next();
        }
        else
        {
          if (j != 26) {
            break label337;
          }
          token = 20;
          len += i - 1;
          idx = '\032';
        }
        matchStat = 4;
        return l;
        label337:
        matchStat = -1;
        return 0L;
      }
      matchStat = -1;
      return 0L;
    }
    matchStat = -1;
    return 0L;
  }
  
  public String scanFieldString(char[] paramArrayOfChar)
  {
    int k = 0;
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return stringDefaultValue();
    }
    int m = paramArrayOfChar.length;
    if (charAt(len + m) != '"')
    {
      matchStat = -1;
      return stringDefaultValue();
    }
    int n = indexOf('"', len + paramArrayOfChar.length + 1);
    if (n != -1)
    {
      int i = len + paramArrayOfChar.length + 1;
      String str = subString(i, n - i);
      i = len + paramArrayOfChar.length + 1;
      for (;;)
      {
        j = k;
        if (i >= n) {
          break;
        }
        if (charAt(i) == '\\')
        {
          j = 1;
          break;
        }
        i += 1;
      }
      if (j != 0)
      {
        matchStat = -1;
        return stringDefaultValue();
      }
      int j = len;
      k = m + 1 + (n - (paramArrayOfChar.length + j + 1) + 1);
      i = k + 1;
      j = charAt(j + k);
      if (j == 44)
      {
        len += i - 1;
        next();
        matchStat = 3;
        return str;
      }
      if (j == 125)
      {
        k = len;
        j = i + 1;
        i = charAt(k + i);
        if (i == 44)
        {
          token = 16;
          len += j - 1;
          next();
        }
        else if (i == 93)
        {
          token = 15;
          len += j - 1;
          next();
        }
        else if (i == 125)
        {
          token = 13;
          len += j - 1;
          next();
        }
        else
        {
          if (i != 26) {
            break label383;
          }
          token = 20;
          len += j - 1;
          idx = '\032';
        }
        matchStat = 4;
        return str;
        label383:
        matchStat = -1;
        return stringDefaultValue();
      }
      matchStat = -1;
      return stringDefaultValue();
    }
    throw new JSONException("unclosed str");
  }
  
  public Collection scanFieldStringArray(char[] paramArrayOfChar, Class paramClass)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a4 = a3\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:552)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:1)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:166)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:331)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:387)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:90)\n\t... 17 more\n");
  }
  
  public String scanFieldSymbol(char[] paramArrayOfChar, SymbolTable paramSymbolTable)
  {
    int i = 0;
    matchStat = 0;
    if (!charArrayCompare(paramArrayOfChar))
    {
      matchStat = -2;
      return null;
    }
    int k = paramArrayOfChar.length;
    int m = len;
    int j = k + 1;
    if (charAt(m + k) != '"')
    {
      matchStat = -1;
      return null;
    }
    for (;;)
    {
      m = len;
      k = j + 1;
      j = charAt(m + j);
      if (j == 34)
      {
        j = len;
        m = paramArrayOfChar.length + j + 1;
        paramArrayOfChar = addSymbol(m, j + k - m - 1, i, paramSymbolTable);
        j = len;
        i = k + 1;
        j = charAt(j + k);
        if (j == 44)
        {
          len += i - 1;
          next();
          matchStat = 3;
          return paramArrayOfChar;
        }
        if (j == 125)
        {
          k = len;
          j = i + 1;
          i = charAt(k + i);
          if (i == 44)
          {
            token = 16;
            len += j - 1;
            next();
          }
          else if (i == 93)
          {
            token = 15;
            len += j - 1;
            next();
          }
          else if (i == 125)
          {
            token = 13;
            len += j - 1;
            next();
          }
          else
          {
            if (i != 26) {
              break label341;
            }
            token = 20;
            len += j - 1;
            idx = '\032';
          }
          matchStat = 4;
          return paramArrayOfChar;
          label341:
          matchStat = -1;
          return null;
        }
        matchStat = -1;
        return null;
      }
      i = i * 31 + j;
      if (j == 92)
      {
        matchStat = -1;
        return null;
      }
      j = k;
    }
  }
  
  public final float scanFloat(char paramChar)
  {
    matchStat = 0;
    char c1 = charAt(len + 0);
    if ((c1 >= '0') && (c1 <= '9'))
    {
      for (char c2 = '\001';; c2 = c1)
      {
        c3 = len;
        c1 = c2 + '\001';
        c2 = charAt(c3 + c2);
        if ((c2 < '0') || (c2 > '9')) {
          break;
        }
      }
      if (c2 == '.')
      {
        c3 = len;
        c2 = c1 + '\001';
        c1 = charAt(c3 + c1);
        if ((c1 >= '0') && (c1 <= '9')) {
          for (;;)
          {
            c3 = len;
            c1 = c2 + '\001';
            char c5 = charAt(c3 + c2);
            char c4 = c5;
            c3 = c1;
            c2 = c4;
            if (c5 < '0') {
              break;
            }
            c3 = c1;
            c2 = c4;
            if (c5 > '9') {
              break;
            }
            c2 = c1;
          }
        }
        matchStat = -1;
        return 0.0F;
      }
      char c3 = c1;
      c1 = len;
      float f = Float.parseFloat(subString(c1, c1 + c3 - c1 - 1));
      if (c2 == paramChar)
      {
        len += c3 - '\001';
        next();
        matchStat = 3;
        token = 16;
        return f;
      }
      matchStat = -1;
      return f;
    }
    matchStat = -1;
    return 0.0F;
  }
  
  public final void scanIdent()
  {
    off = (len - 1);
    hasSpecial = false;
    do
    {
      buf += 1;
      next();
    } while (Character.isLetterOrDigit(idx));
    Object localObject = stringVal();
    localObject = (Integer)keywods.get(localObject);
    if (localObject != null)
    {
      token = ((Integer)localObject).intValue();
      return;
    }
    token = 18;
  }
  
  public int scanInt(char paramChar)
  {
    matchStat = 0;
    int i = charAt(len + 0);
    if ((i >= 48) && (i <= 57))
    {
      i = digits[i];
      char c2;
      for (char c1 = '\001';; c1 = c2)
      {
        char c3 = len;
        c2 = c1 + '\001';
        c1 = charAt(c3 + c1);
        if ((c1 < '0') || (c1 > '9')) {
          break;
        }
        i = i * 10 + digits[c1];
      }
      if (c1 == '.')
      {
        matchStat = -1;
        return 0;
      }
      if (i < 0)
      {
        matchStat = -1;
        return 0;
      }
      if (c1 == paramChar)
      {
        len += c2 - '\001';
        next();
        matchStat = 3;
        token = 16;
        return i;
      }
      matchStat = -1;
      return i;
    }
    matchStat = -1;
    return 0;
  }
  
  public long scanLong(char paramChar)
  {
    matchStat = 0;
    char c1 = charAt(len + 0);
    if ((c1 >= '0') && (c1 <= '9'))
    {
      long l = digits[c1];
      char c2;
      for (c1 = '\001';; c1 = c2)
      {
        char c3 = len;
        c2 = c1 + '\001';
        c1 = charAt(c3 + c1);
        if ((c1 < '0') || (c1 > '9')) {
          break;
        }
        l = l * 10L + digits[c1];
      }
      if (c1 == '.')
      {
        matchStat = -1;
        return 0L;
      }
      if (l < 0L)
      {
        matchStat = -1;
        return 0L;
      }
      if (c1 == paramChar)
      {
        len += c2 - '\001';
        next();
        matchStat = 3;
        token = 16;
        return l;
      }
      matchStat = -1;
      return l;
    }
    matchStat = -1;
    return 0L;
  }
  
  public final void scanNULL()
  {
    if (idx == 'N')
    {
      next();
      if (idx == 'U')
      {
        next();
        if (idx == 'L')
        {
          next();
          if (idx == 'L')
          {
            next();
            int i = idx;
            if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8)) {
              throw new JSONException("scan NULL error");
            }
            token = 8;
            return;
          }
          throw new JSONException("error parse NULL");
        }
        throw new JSONException("error parse U");
      }
    }
    else
    {
      throw new JSONException("error parse NULL");
    }
  }
  
  public final void scanNullOrNew()
  {
    if (idx == 'n')
    {
      next();
      int i = idx;
      if (i == 117)
      {
        next();
        if (idx == 'l')
        {
          next();
          if (idx == 'l')
          {
            next();
            i = idx;
            if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8)) {
              throw new JSONException("scan true error");
            }
            token = 8;
            return;
          }
          throw new JSONException("error parse l");
        }
        throw new JSONException("error parse l");
      }
      if (i == 101)
      {
        next();
        if (idx == 'w')
        {
          next();
          i = idx;
          if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8)) {
            throw new JSONException("scan true error");
          }
          token = 9;
          return;
        }
        throw new JSONException("error parse w");
      }
      throw new JSONException("error parse e");
    }
    throw new JSONException("error parse null or new");
  }
  
  public final void scanNumber()
  {
    off = len;
    int i = idx;
    int j = 1;
    if (i == 45)
    {
      buf += 1;
      next();
    }
    for (;;)
    {
      i = idx;
      if ((i < 48) || (i > 57)) {
        break;
      }
      buf += 1;
      next();
    }
    i = 0;
    if (idx == '.')
    {
      buf += 1;
      next();
      for (;;)
      {
        i = idx;
        if ((i < 48) || (i > 57)) {
          break;
        }
        buf += 1;
        next();
      }
      i = 1;
    }
    int k = idx;
    if (k == 76)
    {
      buf += 1;
      next();
    }
    else if (k == 83)
    {
      buf += 1;
      next();
    }
    else if (k == 66)
    {
      buf += 1;
      next();
    }
    else
    {
      if (k == 70)
      {
        buf += 1;
        next();
        i = j;
        break label399;
      }
      if (k == 68)
      {
        buf += 1;
        next();
        i = j;
        break label399;
      }
      if ((k == 101) || (k == 69)) {
        break label281;
      }
    }
    break label399;
    label281:
    buf += 1;
    next();
    i = idx;
    if ((i == 43) || (i == 45))
    {
      buf += 1;
      next();
    }
    for (;;)
    {
      i = idx;
      if ((i < 48) || (i > 57)) {
        break;
      }
      buf += 1;
      next();
    }
    k = idx;
    if (k != 68)
    {
      i = j;
      if (k != 70) {}
    }
    else
    {
      buf += 1;
      next();
      i = j;
    }
    label399:
    if (i != 0)
    {
      token = 3;
      return;
    }
    token = 2;
  }
  
  public final void scanSet()
  {
    if (idx == 'S')
    {
      next();
      if (idx == 'e')
      {
        next();
        if (idx == 't')
        {
          next();
          int i = idx;
          if ((i != 32) && (i != 10) && (i != 13) && (i != 9) && (i != 12) && (i != 8) && (i != 91) && (i != 40)) {
            throw new JSONException("scan set error");
          }
          token = 21;
          return;
        }
        throw new JSONException("error parse true");
      }
      throw new JSONException("error parse true");
    }
    throw new JSONException("error parse true");
  }
  
  public String scanString(char paramChar)
  {
    int k = 0;
    matchStat = 0;
    int i = charAt(len + 0);
    if (i == 110)
    {
      if ((charAt(len + 1) == 'u') && (charAt(len + 1 + 1) == 'l') && (charAt(len + 1 + 2) == 'l'))
      {
        if (charAt(len + 4) == paramChar)
        {
          len += 4;
          next();
          matchStat = 3;
          return null;
        }
        matchStat = -1;
        return null;
      }
      matchStat = -1;
      return null;
    }
    if (i != 34)
    {
      matchStat = -1;
      return stringDefaultValue();
    }
    i = len + 1;
    int m = indexOf('"', i);
    if (m != -1)
    {
      String str = subString(len + 1, m - i);
      i = len + 1;
      for (;;)
      {
        j = k;
        if (i >= m) {
          break;
        }
        if (charAt(i) == '\\')
        {
          j = 1;
          break;
        }
        i += 1;
      }
      if (j != 0)
      {
        matchStat = -1;
        return stringDefaultValue();
      }
      i = len;
      int j = m - (i + 1) + 1 + 1;
      if (charAt(i + j) == paramChar)
      {
        len += j + 1 - 1;
        next();
        matchStat = 3;
        return str;
      }
      matchStat = -1;
      return str;
    }
    throw new JSONException("unclosed str");
  }
  
  public final void scanString()
  {
    int i = len;
    Object localObject1 = this;
    off = i;
    hasSpecial = false;
    char c;
    for (;;)
    {
      c = ((JSONLexerBase)localObject1).next();
      if (c == '"')
      {
        token = 4;
        idx = ((JSONLexerBase)localObject1).next();
        return;
      }
      if (c == '\032') {
        break;
      }
      Object localObject2;
      if (c == '\\')
      {
        localObject2 = localObject1;
        int j;
        if (!hasSpecial)
        {
          hasSpecial = true;
          i = buf;
          localObject2 = sbuf;
          if (i >= localObject2.length)
          {
            j = localObject2.length * 2;
            if (i <= j) {
              i = j;
            }
            localObject2 = new char[i];
            char[] arrayOfChar = sbuf;
            System.arraycopy(arrayOfChar, 0, localObject2, 0, arrayOfChar.length);
            sbuf = ((char[])localObject2);
          }
          i = off;
          ((JSONLexerBase)localObject1).copyTo(i + 1, buf, sbuf);
          localObject2 = localObject1;
        }
        c = ((JSONLexerBase)localObject2).next();
        switch (c)
        {
        default: 
          switch (c)
          {
          default: 
            switch (c)
            {
            default: 
              idx = c;
              localObject1 = new StringBuilder();
              ((StringBuilder)localObject1).append("unclosed string : ");
              ((StringBuilder)localObject1).append(c);
              throw new JSONException(((StringBuilder)localObject1).toString());
            case 'x': 
              i = ((JSONLexerBase)localObject2).next();
              j = ((JSONLexerBase)localObject2).next();
              localObject1 = digits;
              ((JSONLexerBase)localObject2).putChar((char)(localObject1[i] * 16 + localObject1[j]));
              localObject1 = localObject2;
              break;
            case 'r': 
              ((JSONLexerBase)localObject2).putChar('\r');
              localObject1 = localObject2;
              break;
            case 'n': 
              ((JSONLexerBase)localObject2).putChar('\n');
              localObject1 = localObject2;
              break;
            case 'b': 
              ((JSONLexerBase)localObject2).putChar('\b');
              localObject1 = localObject2;
              break;
            case '\\': 
              ((JSONLexerBase)localObject2).putChar('\\');
              localObject1 = localObject2;
              break;
            case 'F': 
            case 'f': 
              ((JSONLexerBase)localObject2).putChar('\f');
              localObject1 = localObject2;
              break;
            case '\'': 
              ((JSONLexerBase)localObject2).putChar('\'');
              localObject1 = localObject2;
              break;
            case '"': 
              ((JSONLexerBase)localObject2).putChar('"');
              localObject1 = localObject2;
            }
            break;
          case 'v': 
            ((JSONLexerBase)localObject2).putChar('\013');
            localObject1 = localObject2;
            break;
          case 'u': 
            ((JSONLexerBase)localObject2).putChar((char)Integer.parseInt(new String(new char[] { ((JSONLexerBase)localObject2).next(), ((JSONLexerBase)localObject2).next(), ((JSONLexerBase)localObject2).next(), ((JSONLexerBase)localObject2).next() }), 16));
            localObject1 = localObject2;
            break;
          case 't': 
            ((JSONLexerBase)localObject2).putChar('\t');
            localObject1 = localObject2;
          }
          break;
        case '7': 
          ((JSONLexerBase)localObject2).putChar('\007');
          localObject1 = localObject2;
          break;
        case '6': 
          ((JSONLexerBase)localObject2).putChar('\006');
          localObject1 = localObject2;
          break;
        case '5': 
          ((JSONLexerBase)localObject2).putChar('\005');
          localObject1 = localObject2;
          break;
        case '4': 
          ((JSONLexerBase)localObject2).putChar('\004');
          localObject1 = localObject2;
          break;
        case '3': 
          ((JSONLexerBase)localObject2).putChar('\003');
          localObject1 = localObject2;
          break;
        case '2': 
          ((JSONLexerBase)localObject2).putChar('\002');
          localObject1 = localObject2;
          break;
        case '1': 
          ((JSONLexerBase)localObject2).putChar('\001');
          localObject1 = localObject2;
          break;
        case '0': 
          ((JSONLexerBase)localObject2).putChar('\000');
          localObject1 = localObject2;
          break;
        case '/': 
          ((JSONLexerBase)localObject2).putChar('/');
          localObject1 = localObject2;
          break;
        }
      }
      else if (!hasSpecial)
      {
        i = buf;
        buf = (i + 1);
      }
      else
      {
        i = buf;
        localObject2 = localObject1;
        localObject1 = sbuf;
        if (i == localObject1.length)
        {
          ((JSONLexerBase)localObject2).putChar(c);
          localObject1 = localObject2;
        }
        else
        {
          buf = (i + 1);
          localObject1[i] = c;
          localObject1 = localObject2;
        }
      }
    }
    localObject1 = new StringBuilder();
    ((StringBuilder)localObject1).append("unclosed string : ");
    ((StringBuilder)localObject1).append(c);
    throw new JSONException(((StringBuilder)localObject1).toString());
  }
  
  public Collection scanStringArray(Class paramClass, char paramChar)
  {
    throw new Runtime("d2j fail translate: java.lang.RuntimeException: fail exe a4 = a3\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:92)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.dfs(Cfg.java:255)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze0(BaseAnalyze.java:75)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.analyze(BaseAnalyze.java:69)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer.transform(UnSSATransformer.java:274)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:163)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\nCaused by: java.lang.NullPointerException\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:552)\n\tat com.googlecode.dex2jar.ir.ts.UnSSATransformer$LiveA.onUseLocal(UnSSATransformer.java:1)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:166)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.onUse(BaseAnalyze.java:1)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:331)\n\tat com.googlecode.dex2jar.ir.ts.Cfg.travel(Cfg.java:387)\n\tat com.googlecode.dex2jar.ir.ts.an.BaseAnalyze.exec(BaseAnalyze.java:90)\n\t... 17 more\n");
  }
  
  public final String scanSymbol(SymbolTable paramSymbolTable)
  {
    skipWhitespace();
    int i = idx;
    if (i == 34) {
      return scanSymbol(paramSymbolTable, '"');
    }
    if (i == 39)
    {
      if (isEnabled(Feature.AllowSingleQuotes)) {
        return scanSymbol(paramSymbolTable, '\'');
      }
      throw new JSONException("syntax error");
    }
    if (i == 125)
    {
      next();
      token = 13;
      return null;
    }
    if (i == 44)
    {
      next();
      token = 16;
      return null;
    }
    if (i == 26)
    {
      token = 20;
      return null;
    }
    if (isEnabled(Feature.AllowUnQuotedFieldNames)) {
      return scanSymbolUnQuoted(paramSymbolTable);
    }
    throw new JSONException("syntax error");
  }
  
  public final String scanSymbol(SymbolTable paramSymbolTable, char paramChar)
  {
    off = len;
    buf = 0;
    int k = 0;
    int i = 0;
    for (;;)
    {
      char c1 = next();
      if (c1 == paramChar)
      {
        token = 4;
        if (k == 0)
        {
          paramChar = off;
          if (paramChar == '?') {
            paramChar = '\000';
          } else {
            paramChar += '\001';
          }
          paramSymbolTable = addSymbol(paramChar, buf, i, paramSymbolTable);
        }
        else
        {
          paramSymbolTable = paramSymbolTable.addSymbol(sbuf, 0, buf, i);
        }
        buf = 0;
        next();
        return paramSymbolTable;
      }
      if (c1 == '\032') {
        break;
      }
      int j;
      Object localObject;
      if (c1 == '\\')
      {
        j = k;
        if (k == 0)
        {
          j = buf;
          localObject = sbuf;
          if (j >= localObject.length)
          {
            k = localObject.length * 2;
            if (j <= k) {
              j = k;
            }
            localObject = new char[j];
            char[] arrayOfChar = sbuf;
            System.arraycopy(arrayOfChar, 0, localObject, 0, arrayOfChar.length);
            sbuf = ((char[])localObject);
          }
          arrayCopy(off + 1, sbuf, 0, buf);
          j = 1;
        }
        c1 = next();
        switch (c1)
        {
        default: 
          switch (c1)
          {
          default: 
            switch (c1)
            {
            default: 
              idx = c1;
              throw new JSONException("unclosed.str.lit");
            case 'x': 
              c1 = next();
              idx = c1;
              char c2 = next();
              idx = c2;
              localObject = digits;
              c1 = (char)(localObject[c1] * 16 + localObject[c2]);
              i = i * 31 + c1;
              putChar(c1);
              k = j;
              break;
            case 'r': 
              i = i * 31 + 13;
              putChar('\r');
              k = j;
              break;
            case 'n': 
              i = i * 31 + 10;
              putChar('\n');
              k = j;
              break;
            case 'b': 
              i = i * 31 + 8;
              putChar('\b');
              k = j;
              break;
            case '\\': 
              i = i * 31 + 92;
              putChar('\\');
              k = j;
              break;
            case 'F': 
            case 'f': 
              i = i * 31 + 12;
              putChar('\f');
              k = j;
              break;
            case '\'': 
              i = i * 31 + 39;
              putChar('\'');
              k = j;
              break;
            case '"': 
              i = i * 31 + 34;
              putChar('"');
              k = j;
            }
            break;
          case 'v': 
            i = i * 31 + 11;
            putChar('\013');
            k = j;
            break;
          case 'u': 
            k = Integer.parseInt(new String(new char[] { next(), next(), next(), next() }), 16);
            i = i * 31 + k;
            putChar((char)k);
            k = j;
            break;
          case 't': 
            i = i * 31 + 9;
            putChar('\t');
            k = j;
          }
          break;
        case '7': 
          i = i * 31 + c1;
          putChar('\007');
          k = j;
          break;
        case '6': 
          i = i * 31 + c1;
          putChar('\006');
          k = j;
          break;
        case '5': 
          i = i * 31 + c1;
          putChar('\005');
          k = j;
          break;
        case '4': 
          i = i * 31 + c1;
          putChar('\004');
          k = j;
          break;
        case '3': 
          i = i * 31 + c1;
          putChar('\003');
          k = j;
          break;
        case '2': 
          i = i * 31 + c1;
          putChar('\002');
          k = j;
          break;
        case '1': 
          i = i * 31 + c1;
          putChar('\001');
          k = j;
          break;
        case '0': 
          i = i * 31 + c1;
          putChar('\000');
          k = j;
          break;
        case '/': 
          i = i * 31 + 47;
          putChar('/');
          k = j;
          break;
        }
      }
      else
      {
        i = i * 31 + c1;
        if (k == 0)
        {
          buf += 1;
        }
        else
        {
          j = buf;
          localObject = sbuf;
          if (j == localObject.length)
          {
            putChar(c1);
          }
          else
          {
            buf = (j + 1);
            localObject[j] = c1;
          }
        }
      }
    }
    throw new JSONException("unclosed.str");
  }
  
  public final String scanSymbolUnQuoted(SymbolTable paramSymbolTable)
  {
    boolean[] arrayOfBoolean = IOUtils.firstIdentifierFlags;
    int j = idx;
    int i;
    if ((j < arrayOfBoolean.length) && (arrayOfBoolean[j] == 0)) {
      i = 0;
    } else {
      i = 1;
    }
    if (i != 0)
    {
      arrayOfBoolean = IOUtils.identifierFlags;
      off = len;
      buf = 1;
      i = j;
      for (;;)
      {
        j = next();
        if ((j < arrayOfBoolean.length) && (arrayOfBoolean[j] == 0))
        {
          idx = charAt(len);
          token = 18;
          if ((buf == 4) && (i == 3392903) && (charAt(off) == 'n') && (charAt(off + 1) == 'u') && (charAt(off + 2) == 'l') && (charAt(off + 3) == 'l')) {
            return null;
          }
          return addSymbol(off, buf, i, paramSymbolTable);
        }
        i = i * 31 + j;
        buf += 1;
      }
    }
    paramSymbolTable = new StringBuilder();
    paramSymbolTable.append("illegal identifier : ");
    paramSymbolTable.append(idx);
    throw new JSONException(paramSymbolTable.toString());
  }
  
  public String scanSymbolWithSeperator(SymbolTable paramSymbolTable, char paramChar)
  {
    matchStat = 0;
    int i = charAt(len + 0);
    if (i == 110)
    {
      if ((charAt(len + 1) == 'u') && (charAt(len + 1 + 1) == 'l') && (charAt(len + 1 + 2) == 'l'))
      {
        if (charAt(len + 4) == paramChar)
        {
          len += 4;
          next();
          matchStat = 3;
          return null;
        }
        matchStat = -1;
        return null;
      }
      matchStat = -1;
      return null;
    }
    if (i != 34)
    {
      matchStat = -1;
      return null;
    }
    int j = 1;
    i = 0;
    for (;;)
    {
      int m = len;
      int k = j + 1;
      j = charAt(m + j);
      if (j == 34)
      {
        j = len;
        m = j + 0 + 1;
        paramSymbolTable = addSymbol(m, j + k - m - 1, i, paramSymbolTable);
        if (charAt(len + k) == paramChar)
        {
          len += k + 1 - 1;
          next();
          matchStat = 3;
          return paramSymbolTable;
        }
        matchStat = -1;
        return paramSymbolTable;
      }
      i = i * 31 + j;
      if (j == 92)
      {
        matchStat = -1;
        return null;
      }
      j = k;
    }
  }
  
  public final void scanTreeSet()
  {
    if (idx == 'T')
    {
      next();
      if (idx == 'r')
      {
        next();
        if (idx == 'e')
        {
          next();
          if (idx == 'e')
          {
            next();
            if (idx == 'S')
            {
              next();
              if (idx == 'e')
              {
                next();
                if (idx == 't')
                {
                  next();
                  int i = idx;
                  if ((i != 32) && (i != 10) && (i != 13) && (i != 9) && (i != 12) && (i != 8) && (i != 91) && (i != 40)) {
                    throw new JSONException("scan set error");
                  }
                  token = 22;
                  return;
                }
                throw new JSONException("error parse true");
              }
              throw new JSONException("error parse true");
            }
            throw new JSONException("error parse true");
          }
          throw new JSONException("error parse true");
        }
        throw new JSONException("error parse true");
      }
      throw new JSONException("error parse true");
    }
    throw new JSONException("error parse true");
  }
  
  public final void scanTrue()
  {
    if (idx == 't')
    {
      next();
      if (idx == 'r')
      {
        next();
        if (idx == 'u')
        {
          next();
          if (idx == 'e')
          {
            next();
            int i = idx;
            if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8) && (i != 58)) {
              throw new JSONException("scan true error");
            }
            token = 6;
            return;
          }
          throw new JSONException("error parse true");
        }
        throw new JSONException("error parse true");
      }
      throw new JSONException("error parse true");
    }
    throw new JSONException("error parse true");
  }
  
  public int scanType(String paramString)
  {
    int i = 0;
    matchStat = 0;
    if (!charArrayCompare(typeFieldName)) {
      return -2;
    }
    int j = len + typeFieldName.length;
    int k = paramString.length();
    while (i < k)
    {
      if (paramString.charAt(i) != charAt(j + i)) {
        return -1;
      }
      i += 1;
    }
    i = j + k;
    if (charAt(i) != '"') {
      return -1;
    }
    j = i + 1;
    idx = charAt(j);
    k = idx;
    if (k == 44)
    {
      i = j + 1;
      idx = charAt(i);
      len = i;
      token = 16;
      return 3;
    }
    i = j;
    if (k == 125)
    {
      i = j + 1;
      idx = charAt(i);
      j = idx;
      if (j == 44)
      {
        token = 16;
        i += 1;
        idx = charAt(i);
      }
      else if (j == 93)
      {
        token = 15;
        i += 1;
        idx = charAt(i);
      }
      else if (j == 125)
      {
        token = 13;
        i += 1;
        idx = charAt(i);
      }
      else
      {
        if (j != 26) {
          break label266;
        }
        token = 20;
      }
      matchStat = 4;
      break label268;
      label266:
      return -1;
    }
    label268:
    len = i;
    return matchStat;
  }
  
  public final void scanUndefined()
  {
    if (idx == 'u')
    {
      next();
      if (idx == 'n')
      {
        next();
        if (idx == 'd')
        {
          next();
          if (idx == 'e')
          {
            next();
            if (idx == 'f')
            {
              next();
              if (idx == 'i')
              {
                next();
                if (idx == 'n')
                {
                  next();
                  if (idx == 'e')
                  {
                    next();
                    if (idx == 'd')
                    {
                      next();
                      int i = idx;
                      if ((i != 32) && (i != 44) && (i != 125) && (i != 93) && (i != 10) && (i != 13) && (i != 9) && (i != 26) && (i != 12) && (i != 8)) {
                        throw new JSONException("scan false error");
                      }
                      token = 23;
                      return;
                    }
                    throw new JSONException("error parse false");
                  }
                  throw new JSONException("error parse false");
                }
                throw new JSONException("error parse false");
              }
              throw new JSONException("error parse false");
            }
            throw new JSONException("error parse false");
          }
          throw new JSONException("error parse false");
        }
        throw new JSONException("error parse false");
      }
      throw new JSONException("error parse false");
    }
    throw new JSONException("error parse false");
  }
  
  public final void skipWhitespace()
  {
    while ((idx < IOUtils.whitespaceFlags.length) && (IOUtils.whitespaceFlags[idx] != 0)) {
      next();
    }
  }
  
  public final String stringDefaultValue()
  {
    if (isEnabled(Feature.InitStringFieldAsEmpty)) {
      return "";
    }
    return null;
  }
  
  public abstract String stringVal();
  
  public abstract String subString(int paramInt1, int paramInt2);
  
  public final int token()
  {
    return token;
  }
  
  public final String tokenName()
  {
    return JSONToken.name(token);
  }
}
