package com.huawei.secure.android.common.encrypt.thirdparty;

import com.huawei.secure.android.common.encrypt.utils.EncryptUtil;
import com.huawei.secure.android.common.encrypt.utils.HexUtil;
import java.security.GeneralSecurityException;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class CipherUtil
{
  private static final String CIPHER = "AES";
  private static final int CONTEXT_MENU_DELETE_ID = 16;
  private static final String NULL_LABEL = "";
  private static final String PAGE_KEY = "CipherUtil";
  private static final int SELECT_FOLDER = 12;
  private static final String SQL_UPDATE_6_4 = "AES/GCM/NoPadding";
  private static final int TRANSACTION_stat = 16;
  private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
  
  public CipherUtil() {}
  
  private static int decrypt(Cipher paramCipher, byte[] paramArrayOfByte)
  {
    if ((paramCipher != null) && (paramArrayOfByte != null)) {
      return paramCipher.getOutputSize(paramArrayOfByte.length);
    }
    return -1;
  }
  
  private static Cipher encrypt(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt)
  {
    return encrypt(paramArrayOfByte1, paramArrayOfByte2, paramInt, "AES/CBC/PKCS5Padding");
  }
  
  private static Cipher encrypt(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt, String paramString)
  {
    if ((paramArrayOfByte1 != null) && (paramArrayOfByte1.length >= 16) && (paramArrayOfByte2 != null) && (paramArrayOfByte2.length >= 12) && (AesGcm.isBuildVersionHigherThan19())) {
      try
      {
        SecretKeySpec localSecretKeySpec = new SecretKeySpec(paramArrayOfByte1, "AES");
        Cipher localCipher = Cipher.getInstance(paramString);
        boolean bool = "AES/GCM/NoPadding".equals(paramString);
        if (bool) {
          paramArrayOfByte1 = AesGcm.getGcmAlgorithmParams(paramArrayOfByte2);
        } else {
          paramArrayOfByte1 = new IvParameterSpec(paramArrayOfByte2);
        }
        paramArrayOfByte1 = (AlgorithmParameterSpec)paramArrayOfByte1;
        localCipher.init(paramInt, localSecretKeySpec, paramArrayOfByte1);
        return localCipher;
      }
      catch (GeneralSecurityException paramArrayOfByte1)
      {
        paramArrayOfByte2 = new StringBuilder();
        paramArrayOfByte2.append("GCM encrypt data error");
        paramArrayOfByte2.append(paramArrayOfByte1.getMessage());
        com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", paramArrayOfByte2.toString());
        return null;
      }
    }
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "gcm encrypt param is not right");
    return null;
  }
  
  public static Cipher getAesCbcDecryptCipher(byte[] paramArrayOfByte, Cipher paramCipher)
  {
    return getAesCbcDecryptCipher(paramArrayOfByte, paramCipher.getIV());
  }
  
  public static Cipher getAesCbcDecryptCipher(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return encrypt(paramArrayOfByte1, paramArrayOfByte2, 2);
  }
  
  public static Cipher getAesCbcEncryptCipher(byte[] paramArrayOfByte)
  {
    return getAesCbcEncryptCipher(paramArrayOfByte, EncryptUtil.generateSecureRandom(16));
  }
  
  public static Cipher getAesCbcEncryptCipher(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return encrypt(paramArrayOfByte1, paramArrayOfByte2, 1);
  }
  
  public static int getAesCbcEncryptContentLen(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return getAesCbcEncryptContentLen(paramArrayOfByte1, paramArrayOfByte2, EncryptUtil.generateSecureRandom(16));
  }
  
  public static int getAesCbcEncryptContentLen(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3)
  {
    return decrypt(getAesCbcEncryptCipher(paramArrayOfByte2, paramArrayOfByte3), paramArrayOfByte1);
  }
  
  public static Cipher getAesGcmDecryptCipher(byte[] paramArrayOfByte, Cipher paramCipher)
  {
    return getAesGcmDecryptCipher(paramArrayOfByte, paramCipher.getIV());
  }
  
  public static Cipher getAesGcmDecryptCipher(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return processBlock(paramArrayOfByte1, paramArrayOfByte2, 2);
  }
  
  public static Cipher getAesGcmEncryptCipher(byte[] paramArrayOfByte)
  {
    byte[] arrayOfByte = EncryptUtil.generateSecureRandom(12);
    StringBuilder localStringBuilder = new StringBuilder();
    localStringBuilder.append("getEncryptCipher: iv is : ");
    localStringBuilder.append(HexUtil.byteArray2HexStr(arrayOfByte));
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.writeString("CipherUtil", localStringBuilder.toString());
    return getAesGcmEncryptCipher(paramArrayOfByte, arrayOfByte);
  }
  
  public static Cipher getAesGcmEncryptCipher(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return processBlock(paramArrayOfByte1, paramArrayOfByte2, 1);
  }
  
  public static int getAesGcmEncryptContentLen(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    return getAesGcmEncryptContentLen(paramArrayOfByte1, paramArrayOfByte2, EncryptUtil.generateSecureRandom(12));
  }
  
  public static int getAesGcmEncryptContentLen(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3)
  {
    return decrypt(getAesGcmEncryptCipher(paramArrayOfByte2, paramArrayOfByte3), paramArrayOfByte1);
  }
  
  public static int getContent(Cipher paramCipher, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2)
  {
    int i;
    if ((paramCipher != null) && (paramArrayOfByte1 != null)) {
      i = paramArrayOfByte1.length;
    }
    try
    {
      i = paramCipher.doFinal(paramArrayOfByte1, 0, i, paramArrayOfByte2);
      return i;
    }
    catch (BadPaddingException paramCipher)
    {
      for (;;) {}
    }
    catch (IllegalBlockSizeException paramCipher)
    {
      for (;;) {}
    }
    catch (ShortBufferException paramCipher)
    {
      for (;;) {}
    }
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getContent: ShortBufferException");
    return -1;
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getContent: IllegalBlockSizeException");
    return -1;
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getContent: BadPaddingException");
    return -1;
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getEncryptCOntent: cipher is null or content is null");
    return -1;
  }
  
  public static byte[] getContent(Cipher paramCipher, byte[] paramArrayOfByte)
  {
    int i;
    if ((paramCipher != null) && (paramArrayOfByte != null)) {
      i = paramArrayOfByte.length;
    }
    try
    {
      paramCipher = paramCipher.doFinal(paramArrayOfByte, 0, i);
      return paramCipher;
    }
    catch (BadPaddingException paramCipher)
    {
      for (;;) {}
    }
    catch (IllegalBlockSizeException paramCipher)
    {
      for (;;) {}
    }
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getContent: IllegalBlockSizeException");
    break label41;
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getContent: BadPaddingException");
    label41:
    return new byte[0];
    com.huawei.secure.android.common.encrypt.utils.StringBuilder.append("CipherUtil", "getEncryptCOntent: cipher is null or content is null");
    return new byte[0];
  }
  
  private static Cipher processBlock(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt)
  {
    return encrypt(paramArrayOfByte1, paramArrayOfByte2, paramInt, "AES/GCM/NoPadding");
  }
}
