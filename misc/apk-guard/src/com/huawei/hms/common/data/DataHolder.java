package com.huawei.hms.common.data;

import android.content.ContentValues;
import android.database.CharArrayBuffer;
import android.database.Cursor;
import android.database.CursorWindow;
import android.database.CursorWrapper;
import android.database.sqlite.SQLiteClosable;
import android.os.BaseBundle;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable.Creator;
import com.huawei.hms.common.internal.Preconditions;
import com.huawei.hms.common.internal.safeparcel.AbstractSafeParcelable;
import com.huawei.hms.common.internal.safeparcel.SafeParcelWriter;
import com.huawei.hms.common.sqlite.HMSCursorWrapper;
import com.huawei.hms.support.model.HMSLog;
import java.io.Closeable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public final class DataHolder
  extends AbstractSafeParcelable
  implements Closeable
{
  public static final Parcelable.Creator<DataHolder> CREATOR = new DataHolderCreator();
  public static final String TYPE_BOOLEAN = "type_boolean";
  public static final String TYPE_BYTE_ARRAY = "type_byte_array";
  public static final String TYPE_DOUBLE = "type_double";
  public static final String TYPE_FLOAT = "type_float";
  public static final String TYPE_INT = "type_int";
  public static final String TYPE_LONG = "type_long";
  public static final String TYPE_STRING = "type_string";
  private static final Builder builder = new DataHolderBuilderCreator(new String[0], null);
  private static final String data = "DataHolder";
  private String[] columns;
  private Bundle columnsBundle;
  private CursorWindow[] cursorWindows;
  private int dataCount;
  private boolean isInstance;
  private boolean mClosed;
  private Bundle metadata;
  private int[] perCursorCounts;
  private int statusCode;
  private int version;
  
  DataHolder(int paramInt1, String[] paramArrayOfString, CursorWindow[] paramArrayOfCursorWindow, int paramInt2, Bundle paramBundle)
  {
    mClosed = false;
    isInstance = true;
    version = paramInt1;
    columns = paramArrayOfString;
    cursorWindows = paramArrayOfCursorWindow;
    statusCode = paramInt2;
    metadata = paramBundle;
    collectColumsAndCount();
  }
  
  public DataHolder(Cursor paramCursor, int paramInt, Bundle paramBundle)
  {
    this(new HMSCursorWrapper(paramCursor), paramInt, paramBundle);
  }
  
  private DataHolder(Builder paramBuilder, int paramInt, Bundle paramBundle)
  {
    this(builderColumns, getCursorWindows(paramBuilder, -1), paramInt, null);
  }
  
  private DataHolder(Builder paramBuilder, int paramInt1, Bundle paramBundle, int paramInt2)
  {
    this(builderColumns, getCursorWindows(paramBuilder, -1), paramInt1, paramBundle);
  }
  
  private DataHolder(HMSCursorWrapper paramHMSCursorWrapper, int paramInt, Bundle paramBundle)
  {
    this(paramHMSCursorWrapper.getColumnNames(), getCursorWindows(paramHMSCursorWrapper), paramInt, paramBundle);
  }
  
  public DataHolder(String[] paramArrayOfString, CursorWindow[] paramArrayOfCursorWindow, int paramInt, Bundle paramBundle)
  {
    Preconditions.checkNotNull(paramArrayOfString, "columnsP cannot be null");
    Preconditions.checkNotNull(paramArrayOfString, "cursorWindowP cannot be null");
    mClosed = false;
    isInstance = true;
    version = 1;
    columns = paramArrayOfString;
    cursorWindows = paramArrayOfCursorWindow;
    statusCode = paramInt;
    metadata = paramBundle;
    collectColumsAndCount();
  }
  
  public static Builder builder(String[] paramArrayOfString)
  {
    return new Builder(paramArrayOfString, null, null);
  }
  
  private void checkAvailable(String paramString, int paramInt)
  {
    Object localObject = "";
    Bundle localBundle = columnsBundle;
    if ((localBundle != null) && (localBundle.containsKey(paramString)))
    {
      if (isClosed())
      {
        paramString = "buffer has been closed";
      }
      else if (paramInt >= 0)
      {
        paramString = (String)localObject;
        if (paramInt < dataCount) {}
      }
      else
      {
        paramString = new StringBuilder();
        paramString.append("row is out of index:");
        paramString.append(paramInt);
        paramString = paramString.toString();
      }
    }
    else
    {
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("cannot find column: ");
      ((StringBuilder)localObject).append(paramString);
      paramString = ((StringBuilder)localObject).toString();
    }
    Preconditions.checkArgument(paramString.isEmpty(), paramString);
  }
  
  public static DataHolder empty(int paramInt)
  {
    return new DataHolder(builder, paramInt, null);
  }
  
  private static CursorWindow[] getCursorWindows(Builder paramBuilder, int paramInt)
  {
    if (builderColumns.length == 0) {
      return new CursorWindow[0];
    }
    int i;
    if (paramInt >= 0)
    {
      i = paramInt;
      if (paramInt < dataCollectionList.size()) {}
    }
    else
    {
      i = dataCollectionList.size();
    }
    paramBuilder = iterCursorWindow(paramBuilder, i, dataCollectionList.subList(0, i));
    return (CursorWindow[])paramBuilder.toArray(new CursorWindow[paramBuilder.size()]);
  }
  
  private static CursorWindow[] getCursorWindows(HMSCursorWrapper paramHMSCursorWrapper)
  {
    Object localObject1 = new ArrayList();
    try
    {
      int j = paramHMSCursorWrapper.getCount();
      localObject2 = paramHMSCursorWrapper.getWindow();
      if (localObject2 != null)
      {
        i = ((CursorWindow)localObject2).getStartPosition();
        if (i == 0)
        {
          ((SQLiteClosable)localObject2).acquireReference();
          paramHMSCursorWrapper.setWindow(null);
          ((ArrayList)localObject1).add(localObject2);
          i = ((CursorWindow)localObject2).getNumRows();
          break label62;
        }
      }
      int i = 0;
      label62:
      ((ArrayList)localObject1).addAll(iterCursorWrapper(paramHMSCursorWrapper, i, j));
      localObject1 = (CursorWindow[])((ArrayList)localObject1).toArray(new CursorWindow[((ArrayList)localObject1).size()]);
      paramHMSCursorWrapper.close();
      return localObject1;
    }
    catch (Throwable localThrowable1)
    {
      try
      {
        Object localObject2 = new StringBuilder();
        ((StringBuilder)localObject2).append("fail to getCursorWindows: ");
        ((StringBuilder)localObject2).append(localThrowable1.getMessage());
        HMSLog.toString("DataHolder", ((StringBuilder)localObject2).toString());
        paramHMSCursorWrapper.close();
        return new CursorWindow[0];
      }
      catch (Throwable localThrowable2)
      {
        paramHMSCursorWrapper.close();
        throw localThrowable2;
      }
    }
  }
  
  private static ArrayList iterCursorWindow(Builder paramBuilder, int paramInt, List paramList)
  {
    ArrayList localArrayList = new ArrayList();
    CursorWindow localCursorWindow = new CursorWindow(null);
    localCursorWindow.setNumColumns(builderColumns.length);
    localArrayList.add(localCursorWindow);
    int i = 0;
    while (i < paramInt) {
      try
      {
        boolean bool1 = localCursorWindow.allocRow();
        if (!bool1)
        {
          HMSLog.d("DataHolder", "Failed to allocate a row");
          localCursorWindow = new CursorWindow(null);
          localCursorWindow.setStartPosition(i);
          localCursorWindow.setNumColumns(builderColumns.length);
          bool1 = localCursorWindow.allocRow();
          if (!bool1)
          {
            HMSLog.toString("DataHolder", "Failed to retry to allocate a row");
            return localArrayList;
          }
          localArrayList.add(localCursorWindow);
        }
        HashMap localHashMap = (HashMap)paramList.get(i);
        int j = 0;
        bool1 = true;
        for (;;)
        {
          int k = builderColumns.length;
          if (j >= k) {
            break;
          }
          boolean bool2 = putValue(localCursorWindow, localHashMap.get(builderColumns[j]), i, j);
          bool1 = bool2;
          if (!bool2) {
            break;
          }
          j += 1;
        }
        if (!bool1)
        {
          paramList = new StringBuilder();
          paramList.append("fail to put data for row ");
          paramList.append(i);
          HMSLog.d("DataHolder", paramList.toString());
          localCursorWindow.freeLastRow();
          paramList = new CursorWindow(null);
          paramList.setStartPosition(i);
          paramList.setNumColumns(builderColumns.length);
          localArrayList.add(paramList);
          return localArrayList;
        }
        i += 1;
      }
      catch (RuntimeException paramBuilder)
      {
        paramList = localArrayList.iterator();
        while (paramList.hasNext()) {
          ((CursorWindow)paramList.next()).close();
        }
        throw paramBuilder;
      }
    }
    return localArrayList;
  }
  
  private static ArrayList iterCursorWrapper(HMSCursorWrapper paramHMSCursorWrapper, int paramInt1, int paramInt2)
  {
    ArrayList localArrayList = new ArrayList();
    while ((paramInt1 < paramInt2) && (paramHMSCursorWrapper.moveToPosition(paramInt1)))
    {
      CursorWindow localCursorWindow2 = paramHMSCursorWrapper.getWindow();
      CursorWindow localCursorWindow1 = localCursorWindow2;
      if (localCursorWindow2 == null)
      {
        localCursorWindow1 = new CursorWindow(null);
        localCursorWindow1.setStartPosition(paramInt1);
        paramHMSCursorWrapper.fillWindow(paramInt1, localCursorWindow1);
      }
      else
      {
        localCursorWindow2.acquireReference();
        paramHMSCursorWrapper.setWindow(null);
      }
      if (localCursorWindow1.getNumRows() == 0) {
        return localArrayList;
      }
      localArrayList.add(localCursorWindow1);
      paramInt1 = localCursorWindow1.getNumRows() + localCursorWindow1.getStartPosition();
    }
    return localArrayList;
  }
  
  private static boolean putValue(CursorWindow paramCursorWindow, Object paramObject, int paramInt1, int paramInt2)
    throws IllegalArgumentException
  {
    if (paramObject == null) {
      return paramCursorWindow.putNull(paramInt1, paramInt2);
    }
    if ((paramObject instanceof Boolean))
    {
      long l;
      if (((Boolean)paramObject).booleanValue()) {
        l = 1L;
      } else {
        l = 0L;
      }
      return paramCursorWindow.putLong(l, paramInt1, paramInt2);
    }
    if ((paramObject instanceof Integer)) {
      return paramCursorWindow.putLong(((Integer)paramObject).intValue(), paramInt1, paramInt2);
    }
    if ((paramObject instanceof Long)) {
      return paramCursorWindow.putLong(((Long)paramObject).longValue(), paramInt1, paramInt2);
    }
    if ((paramObject instanceof Float)) {
      return paramCursorWindow.putDouble(((Float)paramObject).floatValue(), paramInt1, paramInt2);
    }
    if ((paramObject instanceof Double)) {
      return paramCursorWindow.putDouble(((Double)paramObject).doubleValue(), paramInt1, paramInt2);
    }
    if ((paramObject instanceof String)) {
      return paramCursorWindow.putString((String)paramObject, paramInt1, paramInt2);
    }
    if ((paramObject instanceof byte[])) {
      return paramCursorWindow.putBlob((byte[])paramObject, paramInt1, paramInt2);
    }
    paramCursorWindow = new StringBuilder();
    paramCursorWindow.append("unsupported type for column: ");
    paramCursorWindow.append(paramObject);
    throw new IllegalArgumentException(paramCursorWindow.toString());
  }
  
  public final void close()
  {
    try
    {
      if (!mClosed)
      {
        CursorWindow[] arrayOfCursorWindow = cursorWindows;
        int j = arrayOfCursorWindow.length;
        int i = 0;
        while (i < j)
        {
          arrayOfCursorWindow[i].close();
          i += 1;
        }
        mClosed = true;
      }
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public final void collectColumsAndCount()
  {
    columnsBundle = new Bundle();
    int k = 0;
    int i = 0;
    Object localObject;
    for (;;)
    {
      localObject = columns;
      if (i >= localObject.length) {
        break;
      }
      columnsBundle.putInt(localObject[i], i);
      i += 1;
    }
    perCursorCounts = new int[cursorWindows.length];
    int j = 0;
    i = k;
    for (;;)
    {
      localObject = cursorWindows;
      if (i >= localObject.length) {
        break;
      }
      perCursorCounts[i] = j;
      j = localObject[i].getStartPosition() + cursorWindows[i].getNumRows();
      i += 1;
    }
    dataCount = j;
  }
  
  public final void copyToBuffer(String paramString, int paramInt1, int paramInt2, CharArrayBuffer paramCharArrayBuffer)
  {
    checkAvailable(paramString, paramInt1);
    cursorWindows[paramInt2].copyStringToBuffer(paramInt1, columnsBundle.getInt(paramString), paramCharArrayBuffer);
  }
  
  protected final void finalize()
    throws Throwable
  {
    if ((isInstance) && (cursorWindows.length > 0) && (!isClosed())) {
      close();
    }
    super.finalize();
  }
  
  public final int getCount()
  {
    return dataCount;
  }
  
  public final Bundle getMetadata()
  {
    return metadata;
  }
  
  public final int getStatusCode()
  {
    return statusCode;
  }
  
  public final Object getValue(String paramString1, int paramInt1, int paramInt2, String paramString2)
  {
    int i = paramString2.hashCode();
    boolean bool = true;
    switch (i)
    {
    default: 
      break;
    case 1300508295: 
      if (paramString2.equals("type_byte_array")) {
        i = 6;
      }
      break;
    case 878975158: 
      if (paramString2.equals("type_string")) {
        i = 2;
      }
      break;
    case 519136353: 
      if (paramString2.equals("type_long")) {
        i = 1;
      }
      break;
    case 445002870: 
      if (paramString2.equals("type_double")) {
        i = 5;
      }
      break;
    case -675993238: 
      if (paramString2.equals("type_int")) {
        i = 0;
      }
      break;
    case -870070237: 
      if (paramString2.equals("type_boolean")) {
        i = 3;
      }
      break;
    case -1092271849: 
      if (paramString2.equals("type_float")) {
        i = 4;
      }
      break;
    }
    i = -1;
    switch (i)
    {
    default: 
      return null;
    case 6: 
      checkAvailable(paramString1, paramInt1);
      return cursorWindows[paramInt2].getBlob(paramInt1, columnsBundle.getInt(paramString1));
    case 5: 
      checkAvailable(paramString1, paramInt1);
      return Double.valueOf(cursorWindows[paramInt2].getDouble(paramInt1, columnsBundle.getInt(paramString1)));
    case 4: 
      checkAvailable(paramString1, paramInt1);
      return Float.valueOf(cursorWindows[paramInt2].getFloat(paramInt1, columnsBundle.getInt(paramString1)));
    case 3: 
      checkAvailable(paramString1, paramInt1);
      if (cursorWindows[paramInt2].getLong(paramInt1, columnsBundle.getInt(paramString1)) != 1L) {
        bool = false;
      }
      return Boolean.valueOf(bool);
    case 2: 
      checkAvailable(paramString1, paramInt1);
      return cursorWindows[paramInt2].getString(paramInt1, columnsBundle.getInt(paramString1));
    case 1: 
      checkAvailable(paramString1, paramInt1);
      return Long.valueOf(cursorWindows[paramInt2].getLong(paramInt1, columnsBundle.getInt(paramString1)));
    }
    checkAvailable(paramString1, paramInt1);
    return Integer.valueOf(cursorWindows[paramInt2].getInt(paramInt1, columnsBundle.getInt(paramString1)));
  }
  
  public final int getWindowIndex(int paramInt)
  {
    int i = 0;
    boolean bool;
    if ((paramInt < 0) && (paramInt >= dataCount)) {
      bool = false;
    } else {
      bool = true;
    }
    Object localObject = new StringBuilder();
    ((StringBuilder)localObject).append("rowIndex is out of index:");
    ((StringBuilder)localObject).append(paramInt);
    Preconditions.checkArgument(bool, ((StringBuilder)localObject).toString());
    int j;
    for (;;)
    {
      localObject = perCursorCounts;
      j = i;
      if (i >= localObject.length) {
        break;
      }
      if (paramInt < localObject[i])
      {
        j = i - 1;
        break;
      }
      i += 1;
    }
    if (j == perCursorCounts.length) {
      return j - 1;
    }
    return j;
  }
  
  public final boolean hasColumn(String paramString)
  {
    return columnsBundle.containsKey(paramString);
  }
  
  public final boolean hasNull(String paramString, int paramInt1, int paramInt2)
  {
    checkAvailable(paramString, paramInt1);
    return cursorWindows[paramInt2].getType(paramInt1, columnsBundle.getInt(paramString)) == 0;
  }
  
  public final boolean isClosed()
  {
    try
    {
      boolean bool = mClosed;
      return bool;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public final void writeToParcel(Parcel paramParcel, int paramInt)
  {
    int i = SafeParcelWriter.beginObjectHeader(paramParcel);
    SafeParcelWriter.writeStringArray(paramParcel, 1, columns, false);
    SafeParcelWriter.writeTypedArray(paramParcel, 2, cursorWindows, paramInt, false);
    SafeParcelWriter.writeInt(paramParcel, 3, getStatusCode());
    SafeParcelWriter.writeBundle(paramParcel, 4, getMetadata(), false);
    SafeParcelWriter.writeInt(paramParcel, 1000, version);
    SafeParcelWriter.finishObjectHeader(paramParcel, i);
    if ((paramInt & 0x1) != 0) {
      close();
    }
  }
  
  public static class Builder
  {
    private String[] builderColumns;
    private final ArrayList<HashMap<String, Object>> dataCollectionList;
    private final String type;
    private final HashMap<Object, Integer> typeAndDataCollectionCountMapping;
    
    private Builder(String[] paramArrayOfString, String paramString)
    {
      Preconditions.checkNotNull(paramArrayOfString, "builderColumnsP cannot be null");
      builderColumns = paramArrayOfString;
      dataCollectionList = new ArrayList();
      type = paramString;
      typeAndDataCollectionCountMapping = new HashMap();
    }
    
    Builder(String[] paramArrayOfString, String paramString, DataHolderBuilderCreator paramDataHolderBuilderCreator)
    {
      this(paramArrayOfString, null);
    }
    
    public DataHolder build(int paramInt)
    {
      return new DataHolder(this, paramInt, null, null);
    }
    
    public DataHolder build(int paramInt, Bundle paramBundle)
    {
      return new DataHolder(this, paramInt, paramBundle, -1, null);
    }
    
    public Builder setDataForContentValuesHashMap(HashMap paramHashMap)
    {
      Preconditions.checkNotNull(paramHashMap, "contentValuesHashMap cannot be null");
      Object localObject = type;
      int i = 0;
      if (localObject != null)
      {
        localObject = paramHashMap.get(localObject);
        if (localObject != null)
        {
          Integer localInteger = (Integer)typeAndDataCollectionCountMapping.get(localObject);
          if (localInteger != null)
          {
            i = localInteger.intValue();
            j = 1;
            break label85;
          }
          typeAndDataCollectionCountMapping.put(localObject, Integer.valueOf(dataCollectionList.size()));
        }
      }
      int j = 0;
      label85:
      if (j != 0)
      {
        dataCollectionList.remove(i);
        dataCollectionList.add(i, paramHashMap);
        return this;
      }
      dataCollectionList.add(paramHashMap);
      return this;
    }
    
    public Builder withRow(ContentValues paramContentValues)
    {
      Preconditions.checkNotNull(paramContentValues, "contentValues cannot be null");
      HashMap localHashMap = new HashMap(paramContentValues.size());
      paramContentValues = paramContentValues.valueSet().iterator();
      while (paramContentValues.hasNext())
      {
        Map.Entry localEntry = (Map.Entry)paramContentValues.next();
        localHashMap.put(localEntry.getKey(), localEntry.getValue());
      }
      return setDataForContentValuesHashMap(localHashMap);
    }
  }
  
  public static class DataHolderException
    extends RuntimeException
  {
    public DataHolderException(String paramString)
    {
      super();
    }
  }
}
