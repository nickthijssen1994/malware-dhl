package com.huawei.hms.common.internal;

import android.content.Context;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.text.TextUtils;
import com.huawei.hms.api.Api.ApiOptions;
import com.huawei.hms.common.HuaweiApi;
import com.huawei.hms.configurations.ConnectionResult;
import com.huawei.hms.configurations.HuaweiApiAvailability;
import com.huawei.hms.core.aidl.IMessageEntity;
import com.huawei.hms.support.hianalytics.HiAnalyticsInnerClient;
import com.huawei.hms.support.model.HMSLog;
import com.huawei.hms.utils.Checker;
import com.huawei.hms.utils.HMSPackageManager;
import com.huawei.hms.utils.Util;
import com.huawei.provider.tasks.TaskCompletionSource;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class HuaweiApiManager
  implements Handler.Callback
{
  private static final String HANDLER_NAME = "HuaweiApiHandler";
  private static final Object LOCK_OBJECT = new Object();
  private static final int MSG_RECEIVE_SEND_REQ = 4;
  private static final String PAGE_KEY = "HuaweiApiManager";
  private static HuaweiApiManager mInstance;
  private final Map<ConnectionManagerKey<?>, ConnectionManager<?>> mConnectionCache = new ConcurrentHashMap(5, 0.75F, 1);
  private final Handler mHandler = new Handler(paramLooper, this);
  private final AtomicInteger mSerial = new AtomicInteger(0);
  
  private HuaweiApiManager(Context paramContext, Looper paramLooper, HuaweiApiAvailability paramHuaweiApiAvailability) {}
  
  private void connectAndSendRequest(HandlerMessageWrapper paramHandlerMessageWrapper)
  {
    HuaweiApi localHuaweiApi = mApi;
    ConnectionManager localConnectionManager2 = (ConnectionManager)mConnectionCache.get(localHuaweiApi.getConnectionManagerKey());
    ConnectionManager localConnectionManager1 = localConnectionManager2;
    if (localConnectionManager2 == null)
    {
      localConnectionManager1 = new ConnectionManager(localHuaweiApi);
      mConnectionCache.put(localHuaweiApi.getConnectionManagerKey(), localConnectionManager1);
    }
    localConnectionManager1.sendRequest((TaskApiCallWrapper)mContentWrapper);
  }
  
  public static HuaweiApiManager getInstance(Context paramContext)
  {
    Object localObject = LOCK_OBJECT;
    try
    {
      if (mInstance == null)
      {
        HandlerThread localHandlerThread = new HandlerThread("HuaweiApiManager");
        localHandlerThread.start();
        mInstance = new HuaweiApiManager(paramContext.getApplicationContext(), localHandlerThread.getLooper(), HuaweiApiAvailability.getInstance());
      }
      return mInstance;
    }
    catch (Throwable paramContext)
    {
      throw paramContext;
    }
  }
  
  private void innerDisconnect(HuaweiApi paramHuaweiApi, TaskCompletionSource paramTaskCompletionSource)
  {
    paramHuaweiApi = (ConnectionManager)mConnectionCache.get(paramHuaweiApi.getConnectionManagerKey());
    if (paramHuaweiApi == null)
    {
      paramTaskCompletionSource.setResult(Boolean.valueOf(false));
      return;
    }
    paramTaskCompletionSource.setResult(Boolean.valueOf(paramHuaweiApi.disconnect()));
  }
  
  public void disconnectService(final HuaweiApi paramHuaweiApi, final TaskCompletionSource paramTaskCompletionSource)
  {
    if (Looper.myLooper() == mHandler.getLooper())
    {
      innerDisconnect(paramHuaweiApi, paramTaskCompletionSource);
      return;
    }
    mHandler.post(new Runnable()
    {
      public void run()
      {
        HuaweiApiManager.this.innerDisconnect(paramHuaweiApi, paramTaskCompletionSource);
      }
    });
  }
  
  public boolean handleMessage(Message paramMessage)
  {
    if (what != 4)
    {
      StringBuilder localStringBuilder = new StringBuilder();
      localStringBuilder.append("Unknown message id: ");
      localStringBuilder.append(what);
      HMSLog.get("HuaweiApiManager", localStringBuilder.toString());
      return false;
    }
    connectAndSendRequest((HandlerMessageWrapper)obj);
    return true;
  }
  
  public final void sendRequest(HuaweiApi paramHuaweiApi, TaskApiCall paramTaskApiCall, TaskCompletionSource paramTaskCompletionSource)
  {
    paramTaskApiCall = new TaskApiCallWrapper(paramTaskApiCall, paramTaskCompletionSource);
    paramTaskCompletionSource = mHandler;
    paramTaskCompletionSource.sendMessage(paramTaskCompletionSource.obtainMessage(4, new HandlerMessageWrapper(paramTaskApiCall, mSerial.getAndIncrement(), paramHuaweiApi)));
  }
  
  public class ConnectionManager<OptionsT extends Api.ApiOptions>
    implements BaseHmsClient.ConnectionCallbacks, BaseHmsClient.OnConnectionFailedListener
  {
    private final Queue<HuaweiApiManager.TaskApiCallbackWrapper> callbackQueue = new LinkedList();
    private final HuaweiApi<OptionsT> mApi;
    private final AnyClient mClient;
    private final ConnectionManagerKey mConnectionManagerKey;
    private ConnectionResult mConnectionResult;
    private ResolveClientBean mResolveClientBean;
    
    ConnectionManager(HuaweiApi paramHuaweiApi)
    {
      mApi = paramHuaweiApi;
      mClient = paramHuaweiApi.getClient(mHandler.getLooper(), this);
      mConnectionResult = null;
      mConnectionManagerKey = paramHuaweiApi.getConnectionManagerKey();
    }
    
    private String errorReason(ConnectionResult paramConnectionResult)
    {
      int i;
      if (Util.isAvailableLibExist(mApi.getContext()))
      {
        i = paramConnectionResult.getErrorCode();
        if (i == -1) {
          break label143;
        }
        if (i != 3)
        {
          if (i == 8) {
            break label140;
          }
          if (i == 10) {
            break label137;
          }
          if (i != 13)
          {
            if (i != 21) {
              switch (i)
              {
              default: 
                break;
              case 27: 
                return "there is already an update popup at the front desk, but it hasn't been clicked or it is not effective for a while";
              case 26: 
                return "update failed, because no activity incoming, can't pop update page";
              case 25: 
                return "failed to get update result";
              }
            } else {
              return "device is too old to be support";
            }
          }
          else {
            return "update cancelled";
          }
        }
        else
        {
          return "HuaWei Mobile Service is disabled";
        }
      }
      else
      {
        i = paramConnectionResult.getErrorCode();
        if (i == -1) {
          break label143;
        }
        if (i == 8) {
          break label140;
        }
        if (i == 10) {
          break label137;
        }
      }
      return "unknown errorReason";
      label137:
      return "application configuration error, please developer check configuration";
      label140:
      return "internal error";
      label143:
      return "get update result, but has other error codes";
    }
    
    private String getTransactionId(String paramString1, String paramString2)
    {
      String str = paramString1;
      if (TextUtils.isEmpty(paramString1)) {
        str = TransactionIdCreater.getId(mApi.getAppID(), paramString2);
      }
      return str;
    }
    
    private void innerConnected()
    {
      Checker.assertHandlerThread(mHandler);
      mConnectionResult = null;
      Iterator localIterator = callbackQueue.iterator();
      while (localIterator.hasNext()) {
        postMessage((HuaweiApiManager.TaskApiCallbackWrapper)localIterator.next());
      }
      callbackQueue.clear();
    }
    
    private void innerConnectionFailed(ConnectionResult paramConnectionResult)
    {
      Checker.assertHandlerThread(mHandler);
      mConnectionResult = paramConnectionResult;
      Iterator localIterator = callbackQueue.iterator();
      int i;
      for (int j = 1; localIterator.hasNext(); j = i)
      {
        TaskApiCallWrapper localTaskApiCallWrapper = ((HuaweiApiManager.TaskApiCallbackWrapper)localIterator.next()).getApiCallWrapper();
        Object localObject = new StringBuilder();
        ((StringBuilder)localObject).append("Connection Failed:");
        ((StringBuilder)localObject).append(errorReason(paramConnectionResult));
        ((StringBuilder)localObject).append("(");
        ((StringBuilder)localObject).append(paramConnectionResult.getErrorCode());
        ((StringBuilder)localObject).append(")");
        localObject = new ResponseHeader(1, 907135003, ((StringBuilder)localObject).toString());
        ((ResponseHeader)localObject).setTransactionId(localTaskApiCallWrapper.getTaskApiCall().getTransactionId());
        HiAnalyticsInnerClient.reportEntryExit(mApi.getContext(), (ResponseHeader)localObject, String.valueOf(mApi.getKitSdkVersion()));
        i = j;
        if (mConnectionResult.getResolution() != null)
        {
          i = j;
          if (j != 0)
          {
            ((ResponseHeader)localObject).setParcelable(mConnectionResult.getResolution());
            j = 0;
            i = j;
            if (Util.isAvailableLibExist(mApi.getContext()))
            {
              i = j;
              if (mConnectionResult.getErrorCode() == 26)
              {
                ((ResponseHeader)localObject).setResolution("hasContextResolution");
                i = j;
              }
            }
          }
        }
        localTaskApiCallWrapper.getTaskApiCall().onResponse(mClient, (ResponseErrorCode)localObject, null, localTaskApiCallWrapper.getTaskCompletionSource());
      }
      callbackQueue.clear();
      mConnectionResult = null;
      mClient.disconnect();
      mConnectionCache.remove(mConnectionManagerKey);
    }
    
    private void innerConnectionSuspended(int paramInt)
    {
      Checker.assertHandlerThread(mHandler);
      Iterator localIterator = callbackQueue.iterator();
      while (localIterator.hasNext())
      {
        TaskApiCallWrapper localTaskApiCallWrapper = ((HuaweiApiManager.TaskApiCallbackWrapper)localIterator.next()).getApiCallWrapper();
        ResponseHeader localResponseHeader = new ResponseHeader(1, 907135003, "Connection Suspended");
        localResponseHeader.setTransactionId(localTaskApiCallWrapper.getTaskApiCall().getTransactionId());
        localTaskApiCallWrapper.getTaskApiCall().onResponse(mClient, localResponseHeader, null, localTaskApiCallWrapper.getTaskCompletionSource());
      }
      callbackQueue.clear();
      mConnectionResult = null;
      mClient.disconnect();
      mConnectionCache.remove(mConnectionManagerKey);
    }
    
    private void postMessage(HuaweiApiManager.TaskApiCallbackWrapper paramTaskApiCallbackWrapper)
    {
      String str = paramTaskApiCallbackWrapper.getApiCallWrapper().getTaskApiCall().getUri();
      RequestHeader localRequestHeader = new RequestHeader();
      localRequestHeader.setSrvName(str.split("\\.")[0]);
      localRequestHeader.setApiName(str);
      Object localObject = new StringBuilder();
      ((StringBuilder)localObject).append(mApi.getAppID());
      ((StringBuilder)localObject).append("|");
      ((StringBuilder)localObject).append(mApi.getSubAppID());
      localRequestHeader.setAppID(((StringBuilder)localObject).toString());
      localRequestHeader.setPkgName(mApi.getContext().getPackageName());
      localRequestHeader.setSessionId(mClient.getSessionId());
      localObject = paramTaskApiCallbackWrapper.getApiCallWrapper().getTaskApiCall();
      localRequestHeader.setTransactionId(getTransactionId(((TaskApiCall)localObject).getTransactionId(), str));
      localRequestHeader.setParcelable(((TaskApiCall)localObject).getParcelable());
      localRequestHeader.setKitSdkVersion(mApi.getKitSdkVersion());
      localRequestHeader.setApiLevel(Math.max(mApi.getApiLevel(), ((TaskApiCall)localObject).getApiLevel()));
      mClient.post(localRequestHeader, ((TaskApiCall)localObject).getRequestJson(), paramTaskApiCallbackWrapper.getCallBack());
    }
    
    private HuaweiApiManager.TaskApiCallbackWrapper wrapperRequest(final TaskApiCallWrapper paramTaskApiCallWrapper)
    {
      new HuaweiApiManager.TaskApiCallbackWrapper(paramTaskApiCallWrapper, new AnyClient.CallBack()
      {
        private AtomicBoolean isFirstRsp = new AtomicBoolean(true);
        
        public void onCallback(IMessageEntity paramAnonymousIMessageEntity, String paramAnonymousString)
        {
          if (!(paramAnonymousIMessageEntity instanceof ResponseHeader))
          {
            HMSLog.toString("HuaweiApiManager", "header is not instance of ResponseHeader");
            return;
          }
          paramAnonymousIMessageEntity = (ResponseHeader)paramAnonymousIMessageEntity;
          if (!TextUtils.isEmpty(paramAnonymousIMessageEntity.getResolution()))
          {
            StringBuilder localStringBuilder = new StringBuilder();
            localStringBuilder.append("Response has resolution: ");
            localStringBuilder.append(paramAnonymousIMessageEntity.getResolution());
            HMSLog.toString("HuaweiApiManager", localStringBuilder.toString());
          }
          if (isFirstRsp.compareAndSet(true, false)) {
            HiAnalyticsInnerClient.reportEntryExit(mApi.getContext(), paramAnonymousIMessageEntity, String.valueOf(mApi.getKitSdkVersion()));
          }
          paramTaskApiCallWrapper.getTaskApiCall().onResponse(mClient, paramAnonymousIMessageEntity, paramAnonymousString, paramTaskApiCallWrapper.getTaskCompletionSource());
        }
      });
    }
    
    void connect(int paramInt)
    {
      try
      {
        Checker.assertHandlerThread(mHandler);
        if (mClient.isConnected())
        {
          HMSLog.d("HuaweiApiManager", "client is connected");
          return;
        }
        if (mClient.isConnecting())
        {
          HMSLog.d("HuaweiApiManager", "client is isConnecting");
          return;
        }
        if (mApi.getActivity() != null)
        {
          if (mResolveClientBean == null) {
            mResolveClientBean = new ResolveClientBean(mClient, paramInt);
          }
          if (BindResolveClients.getInstance().isClientRegistered(mResolveClientBean))
          {
            HMSLog.append("HuaweiApiManager", "mResolveClientBean has already register, return!");
            return;
          }
          BindResolveClients.getInstance().register(mResolveClientBean);
        }
        mClient.connect(paramInt);
        return;
      }
      catch (Throwable localThrowable)
      {
        throw localThrowable;
      }
    }
    
    boolean disconnect()
    {
      Checker.assertHandlerThread(mHandler);
      mClient.disconnect();
      return true;
    }
    
    public void onConnected()
    {
      HMSLog.d("HuaweiApiManager", "onConnected");
      BindResolveClients.getInstance().unRegister(mResolveClientBean);
      mResolveClientBean = null;
      if (Looper.myLooper() == mHandler.getLooper())
      {
        innerConnected();
        return;
      }
      mHandler.post(new Runnable()
      {
        public void run()
        {
          HuaweiApiManager.ConnectionManager.this.innerConnected();
        }
      });
    }
    
    public void onConnectionFailed(final ConnectionResult paramConnectionResult)
    {
      HMSLog.append("HuaweiApiManager", "onConnectionFailed");
      BindResolveClients.getInstance().unRegister(mResolveClientBean);
      mResolveClientBean = null;
      if (Looper.myLooper() == mHandler.getLooper())
      {
        innerConnectionFailed(paramConnectionResult);
        return;
      }
      mHandler.post(new Runnable()
      {
        public void run()
        {
          HuaweiApiManager.ConnectionManager.this.innerConnectionFailed(paramConnectionResult);
        }
      });
    }
    
    public void onConnectionSuspended(final int paramInt)
    {
      HMSLog.append("HuaweiApiManager", "onConnectionSuspended");
      BindResolveClients.getInstance().unRegister(mResolveClientBean);
      mResolveClientBean = null;
      if (Looper.myLooper() == mHandler.getLooper())
      {
        innerConnectionSuspended(paramInt);
        return;
      }
      mHandler.post(new Runnable()
      {
        public void run()
        {
          HuaweiApiManager.ConnectionManager.this.innerConnectionSuspended(paramInt);
        }
      });
    }
    
    void sendRequest(TaskApiCallWrapper paramTaskApiCallWrapper)
    {
      HMSLog.append("HuaweiApiManager", "sendRequest");
      Checker.assertHandlerThread(mHandler);
      HuaweiApiManager.TaskApiCallbackWrapper localTaskApiCallbackWrapper = wrapperRequest(paramTaskApiCallWrapper);
      int i = paramTaskApiCallWrapper.getTaskApiCall().getMinApkVersion();
      if (mClient.isConnected())
      {
        if (HMSPackageManager.getInstance(mApi.getContext()).hmsVerHigherThan(i))
        {
          postMessage(localTaskApiCallbackWrapper);
          return;
        }
        disconnect();
        callbackQueue.add(localTaskApiCallbackWrapper);
        connect(i);
        return;
      }
      callbackQueue.add(localTaskApiCallbackWrapper);
      paramTaskApiCallWrapper = mConnectionResult;
      if ((paramTaskApiCallWrapper != null) && (paramTaskApiCallWrapper.getErrorCode() != 0))
      {
        onConnectionFailed(mConnectionResult);
        return;
      }
      connect(i);
    }
  }
  
  private static class TaskApiCallbackWrapper
  {
    private final TaskApiCallWrapper mApiCallWrapper;
    private final AnyClient.CallBack mCallBack;
    
    TaskApiCallbackWrapper(TaskApiCallWrapper paramTaskApiCallWrapper, AnyClient.CallBack paramCallBack)
    {
      mApiCallWrapper = paramTaskApiCallWrapper;
      mCallBack = paramCallBack;
    }
    
    TaskApiCallWrapper getApiCallWrapper()
    {
      return mApiCallWrapper;
    }
    
    AnyClient.CallBack getCallBack()
    {
      return mCallBack;
    }
  }
}
