package com.huawei.hms.push;

import android.net.Uri;
import android.os.BaseBundle;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.Parcelable.Creator;
import android.text.TextUtils;
import com.huawei.hms.push.utils.DateUtil;
import com.huawei.hms.push.utils.JsonUtil;
import com.huawei.hms.support.model.HMSLog;
import com.huawei.hms.support.mozilla.push.PushException;
import com.huawei.hms.support.mozilla.push.utils.CommFun;
import com.huawei.hms.support.mozilla.push.utils.common.base.BaseUtil;
import com.huawei.hms.support.mozilla.push.utils.common.base.PushConst;
import java.io.Serializable;
import java.nio.charset.Charset;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.json.JSONException;
import org.json.JSONObject;

public class RemoteMessage
  implements Parcelable
{
  public static final Parcelable.Creator<RemoteMessage> CREATOR = new Point.1();
  public static final String[] P = new String[0];
  public static final int PRIORITY_HIGH = 1;
  public static final int PRIORITY_NORMAL = 2;
  public static final int PRIORITY_UNKNOWN = 0;
  public static final HashMap<String, Object> a;
  public static final HashMap<String, Object> b;
  public static final HashMap<String, Object> c;
  public static final HashMap<String, Object> d;
  public static final int[] i = new int[0];
  public static final HashMap<String, Object> items;
  public static final long[] o = new long[0];
  public Bundle arguments;
  public Notification state;
  
  static
  {
    d = new HashMap(6);
    d.put("from", "");
    d.put("collapseKey", "");
    d.put("sendTime", "");
    d.put("ttl", Integer.valueOf(86400));
    d.put("urgency", Integer.valueOf(2));
    d.put("oriUrgency", Integer.valueOf(2));
    d.put("sendMode", Integer.valueOf(0));
    d.put("receiptMode", Integer.valueOf(0));
    a = new HashMap(8);
    a.put("title_loc_key", "");
    a.put("body_loc_key", "");
    a.put("notifyIcon", "");
    a.put("title_loc_args", P);
    a.put("body_loc_args", P);
    a.put("ticker", "");
    a.put("notifyTitle", "");
    a.put("content", "");
    c = new HashMap(8);
    c.put("icon", "");
    c.put("color", "");
    c.put("sound", "");
    c.put("defaultLightSettings", Integer.valueOf(1));
    c.put("lightSettings", i);
    c.put("defaultSound", Integer.valueOf(1));
    c.put("defaultVibrateTimings", Integer.valueOf(1));
    c.put("vibrateTimings", o);
    b = new HashMap(8);
    b.put("tag", "");
    b.put("when", "");
    b.put("localOnly", Integer.valueOf(1));
    b.put("badgeSetNum", "");
    b.put("priority", "");
    b.put("autoCancel", Integer.valueOf(1));
    b.put("visibility", "");
    b.put("channelId", "");
    items = new HashMap(3);
    items.put("acn", "");
    items.put("intentUri", "");
    items.put("url", "");
  }
  
  public RemoteMessage(Bundle paramBundle)
  {
    arguments = onPostExecute(paramBundle);
  }
  
  public RemoteMessage(Parcel paramParcel)
  {
    arguments = paramParcel.readBundle();
    state = ((Notification)paramParcel.readSerializable());
  }
  
  public static JSONObject get(Bundle paramBundle)
  {
    try
    {
      paramBundle = BaseUtil.byte2Str(paramBundle.getByteArray("message_body"));
      paramBundle = new JSONObject(paramBundle);
      return paramBundle;
    }
    catch (JSONException paramBundle)
    {
      for (;;) {}
    }
    HMSLog.get("RemoteMessage", "JSONException:parse message body failed.");
    return null;
  }
  
  public static JSONObject getFile(JSONObject paramJSONObject)
  {
    if (paramJSONObject != null) {
      return paramJSONObject.optJSONObject("psContent");
    }
    return null;
  }
  
  public static JSONObject getJSONObject(JSONObject paramJSONObject)
  {
    if (paramJSONObject != null) {
      return paramJSONObject.optJSONObject("notifyDetail");
    }
    return null;
  }
  
  public static JSONObject parse(JSONObject paramJSONObject)
  {
    if (paramJSONObject != null) {
      return paramJSONObject.optJSONObject("param");
    }
    return null;
  }
  
  public static JSONObject toString(JSONObject paramJSONObject)
  {
    if (paramJSONObject != null) {
      return paramJSONObject.optJSONObject("msgContent");
    }
    return null;
  }
  
  public final int describeContents()
  {
    return 0;
  }
  
  public String getCollapseKey()
  {
    return arguments.getString("collapseKey");
  }
  
  public String getData()
  {
    return arguments.getString("data");
  }
  
  public Map getDataOfMap()
  {
    HashMap localHashMap = new HashMap();
    Object localObject = arguments.getString("data");
    if ((localObject != null) && (!((String)localObject).trim().isEmpty()))
    {
      try
      {
        localObject = new JSONObject((String)localObject);
        Iterator localIterator = ((JSONObject)localObject).keys();
        for (;;)
        {
          boolean bool = localIterator.hasNext();
          if (!bool) {
            break;
          }
          String str = String.valueOf(localIterator.next());
          localHashMap.put(str, String.valueOf(((JSONObject)localObject).get(str)));
        }
      }
      catch (JSONException localJSONException)
      {
        for (;;) {}
      }
      HMSLog.get("RemoteMessage", "JSONException: get data from map failed");
      return localHashMap;
    }
    return localHashMap;
  }
  
  public String getFrom()
  {
    return arguments.getString("from");
  }
  
  public String getMessageId()
  {
    return arguments.getString("msgId");
  }
  
  public String getMessageType()
  {
    return arguments.getString("message_type");
  }
  
  public Notification getNotification()
  {
    Bundle localBundle = arguments.getBundle("notification");
    if ((state == null) && (localBundle != null)) {
      state = new Notification(localBundle, null);
    }
    if (state == null) {
      state = new Notification(new Bundle(), null);
    }
    return state;
  }
  
  public int getOriginalUrgency()
  {
    int j = arguments.getInt("oriUrgency");
    if ((j != 1) && (j != 2)) {
      return 0;
    }
    return j;
  }
  
  public int getReceiptMode()
  {
    return arguments.getInt("receiptMode");
  }
  
  public int getSendMode()
  {
    return arguments.getInt("sendMode");
  }
  
  public long getSentTime()
  {
    Object localObject = arguments;
    try
    {
      localObject = ((BaseBundle)localObject).getString("sendTime");
      boolean bool = TextUtils.isEmpty((CharSequence)localObject);
      if (bool) {
        break label48;
      }
      long l = Long.parseLong((String)localObject);
      return l;
    }
    catch (NumberFormatException localNumberFormatException)
    {
      for (;;) {}
    }
    HMSLog.get("RemoteMessage", "NumberFormatException: get sendTime error.");
    return 0L;
    label48:
    return 0L;
  }
  
  public String getTo()
  {
    return arguments.getString("to");
  }
  
  public String getToken()
  {
    return arguments.getString("device_token");
  }
  
  public int getTtl()
  {
    return arguments.getInt("ttl");
  }
  
  public int getUrgency()
  {
    int j = arguments.getInt("urgency");
    if ((j != 1) && (j != 2)) {
      return 0;
    }
    return j;
  }
  
  public final Bundle onPostExecute(Bundle paramBundle)
  {
    Bundle localBundle = new Bundle();
    JSONObject localJSONObject1 = get(paramBundle);
    JSONObject localJSONObject2 = toString(localJSONObject1);
    String str1 = JsonUtil.getString(localJSONObject2, "data", null);
    localBundle.putString("device_token", paramBundle.getString("device_token"));
    JSONObject localJSONObject3 = getFile(localJSONObject2);
    JSONObject localJSONObject4 = getJSONObject(localJSONObject3);
    JSONObject localJSONObject5 = parse(localJSONObject3);
    if ((paramBundle.getInt("inputType") == 1) && (CommFun.isOldMsg(localJSONObject2, localJSONObject3, str1)))
    {
      localBundle.putString("data", BaseUtil.byte2Str(paramBundle.getByteArray("message_body")));
      return localBundle;
    }
    String str2 = paramBundle.getString("to");
    paramBundle = paramBundle.getString("message_type");
    String str3 = JsonUtil.getString(localJSONObject2, "msgId", null);
    localBundle.putString("to", str2);
    localBundle.putString("data", str1);
    localBundle.putString("msgId", str3);
    localBundle.putString("message_type", paramBundle);
    JsonUtil.transferJsonObjectToBundle(localJSONObject1, localBundle, d);
    localBundle.putBundle("notification", save(localJSONObject1, localJSONObject2, localJSONObject3, localJSONObject4, localJSONObject5));
    return localBundle;
  }
  
  public final Bundle save(JSONObject paramJSONObject1, JSONObject paramJSONObject2, JSONObject paramJSONObject3, JSONObject paramJSONObject4, JSONObject paramJSONObject5)
  {
    Bundle localBundle = new Bundle();
    JsonUtil.transferJsonObjectToBundle(paramJSONObject3, localBundle, a);
    JsonUtil.transferJsonObjectToBundle(paramJSONObject4, localBundle, c);
    JsonUtil.transferJsonObjectToBundle(paramJSONObject1, localBundle, b);
    JsonUtil.transferJsonObjectToBundle(paramJSONObject5, localBundle, items);
    localBundle.putInt("notifyId", JsonUtil.getInt(paramJSONObject2, "notifyId", 0));
    return localBundle;
  }
  
  public void writeToParcel(Parcel paramParcel, int paramInt)
  {
    paramParcel.writeBundle(arguments);
    paramParcel.writeSerializable(state);
  }
  
  public static class Builder
  {
    public final Bundle data = new Bundle();
    public final Map<String, String> next = new HashMap();
    
    public Builder(String paramString)
    {
      data.putString("to", paramString);
    }
    
    public Builder addData(String paramString1, String paramString2)
    {
      if (paramString1 != null)
      {
        next.put(paramString1, paramString2);
        return this;
      }
      throw new IllegalArgumentException("add data failed, key is null.");
    }
    
    public RemoteMessage build()
    {
      Bundle localBundle = new Bundle();
      Object localObject1 = new JSONObject();
      Object localObject2 = next;
      for (;;)
      {
        try
        {
          localObject2 = ((Map)localObject2).entrySet().iterator();
          boolean bool = ((Iterator)localObject2).hasNext();
          if (bool)
          {
            localObject3 = ((Iterator)localObject2).next();
            localObject3 = (Map.Entry)localObject3;
            localObject4 = ((Map.Entry)localObject3).getKey();
            localObject4 = (String)localObject4;
            ((JSONObject)localObject1).put((String)localObject4, ((Map.Entry)localObject3).getValue());
            continue;
          }
        }
        catch (JSONException localJSONException1)
        {
          Object localObject3;
          Object localObject4;
          int i;
          label331:
          continue;
        }
        try
        {
          localObject3 = ((JSONObject)localObject1).toString();
          localObject2 = new JSONObject();
          localObject4 = data;
        }
        catch (JSONException localJSONException2)
        {
          continue;
        }
        try
        {
          ((JSONObject)localObject2).put("collapseKey", ((BaseBundle)localObject4).getString("collapseKey"));
          localObject4 = data;
        }
        catch (JSONException localJSONException3)
        {
          continue;
        }
        try
        {
          ((JSONObject)localObject2).put("ttl", ((BaseBundle)localObject4).getInt("ttl"));
          localObject4 = data;
        }
        catch (JSONException localJSONException4)
        {
          continue;
        }
        try
        {
          ((JSONObject)localObject2).put("sendMode", ((BaseBundle)localObject4).getInt("sendMode"));
          localObject4 = data;
        }
        catch (JSONException localJSONException5)
        {
          continue;
        }
        try
        {
          ((JSONObject)localObject2).put("receiptMode", ((BaseBundle)localObject4).getInt("receiptMode"));
          localObject4 = new JSONObject();
          i = ((JSONObject)localObject1).length();
          if (i == 0) {}
        }
        catch (JSONException localJSONException6) {}
      }
      try
      {
        ((JSONObject)localObject4).put("data", localObject3);
        localObject1 = data;
      }
      catch (JSONException localJSONException7)
      {
        break label331;
      }
      try
      {
        localObject1 = ((BaseBundle)localObject1).getString("msgId");
      }
      catch (JSONException localJSONException8)
      {
        break label331;
      }
      try
      {
        ((JSONObject)localObject4).put("msgId", localObject1);
      }
      catch (JSONException localJSONException9)
      {
        break label331;
      }
      try
      {
        ((JSONObject)localObject2).put("msgContent", localObject4);
        localObject1 = ((JSONObject)localObject2).toString();
        localObject2 = PushConst.UTF_8;
        localObject1 = ((String)localObject1).getBytes((Charset)localObject2);
      }
      catch (JSONException localJSONException10)
      {
        break label331;
      }
      try
      {
        localBundle.putByteArray("message_body", (byte[])localObject1);
        localBundle.putString("to", data.getString("to"));
        localBundle.putString("message_type", data.getString("message_type"));
        return new RemoteMessage(localBundle);
      }
      catch (JSONException localJSONException11)
      {
        break label331;
      }
      HMSLog.get("RemoteMessage", "JSONException: parse message body failed.");
      throw new PushException("send message failed");
      HMSLog.get("RemoteMessage", "JSONException: parse data to json failed.");
      throw new PushException("send message failed");
    }
    
    public Builder clearData()
    {
      next.clear();
      return this;
    }
    
    public Builder setCollapseKey(String paramString)
    {
      data.putString("collapseKey", paramString);
      return this;
    }
    
    public Builder setData(Map paramMap)
    {
      next.clear();
      paramMap = paramMap.entrySet().iterator();
      while (paramMap.hasNext())
      {
        Map.Entry localEntry = (Map.Entry)paramMap.next();
        next.put(localEntry.getKey(), localEntry.getValue());
      }
      return this;
    }
    
    public Builder setMessageId(String paramString)
    {
      data.putString("msgId", paramString);
      return this;
    }
    
    public Builder setMessageType(String paramString)
    {
      data.putString("message_type", paramString);
      return this;
    }
    
    public Builder setReceiptMode(int paramInt)
    {
      if ((paramInt != 1) && (paramInt != 0)) {
        throw new IllegalArgumentException("receipt mode can only be 0 or 1.");
      }
      data.putInt("receiptMode", paramInt);
      return this;
    }
    
    public Builder setSendMode(int paramInt)
    {
      if ((paramInt != 0) && (paramInt != 1)) {
        throw new IllegalArgumentException("send mode can only be 0 or 1.");
      }
      data.putInt("sendMode", paramInt);
      return this;
    }
    
    public Builder setTtl(int paramInt)
    {
      if ((paramInt >= 1) && (paramInt <= 1296000))
      {
        data.putInt("ttl", paramInt);
        return this;
      }
      throw new IllegalArgumentException("ttl must be greater than or equal to 1 and less than or equal to 1296000");
    }
  }
  
  public static class Notification
    implements Serializable
  {
    public final String address;
    public final String bgColor;
    public final String body;
    public final String comment;
    public final String condition;
    public final String data;
    public final String dataDir;
    public final int hidemode;
    public final String imageUri;
    public final String imageUrl;
    public final Uri link;
    public final int[] mColors;
    public final int mErrorCode;
    public final int mErrorType;
    public final String mFragment;
    public final int mMax;
    public final int mMessageType;
    public final String mTag;
    public final String mTitle;
    public final String mUnitM;
    public final String[] mUnits;
    public final String msg;
    public final long[] password;
    public final int portal;
    public final String ticker;
    public final String title;
    public final String type;
    public final String[] types;
    
    public Notification(Bundle paramBundle)
    {
      title = paramBundle.getString("notifyTitle");
      body = paramBundle.getString("content");
      type = paramBundle.getString("title_loc_key");
      condition = paramBundle.getString("body_loc_key");
      types = paramBundle.getStringArray("title_loc_args");
      mUnits = paramBundle.getStringArray("body_loc_args");
      mUnitM = paramBundle.getString("icon");
      bgColor = paramBundle.getString("color");
      msg = paramBundle.getString("sound");
      mTag = paramBundle.getString("tag");
      mFragment = paramBundle.getString("channelId");
      dataDir = paramBundle.getString("acn");
      comment = paramBundle.getString("intentUri");
      portal = paramBundle.getInt("notifyId");
      Object localObject = paramBundle.getString("url");
      if (!TextUtils.isEmpty((CharSequence)localObject)) {
        localObject = Uri.parse((String)localObject);
      } else {
        localObject = null;
      }
      link = ((Uri)localObject);
      imageUrl = paramBundle.getString("notifyIcon");
      mMessageType = paramBundle.getInt("defaultLightSettings");
      mErrorType = paramBundle.getInt("defaultSound");
      mErrorCode = paramBundle.getInt("defaultVibrateTimings");
      mColors = paramBundle.getIntArray("lightSettings");
      mTitle = paramBundle.getString("when");
      mMax = paramBundle.getInt("localOnly");
      imageUri = paramBundle.getString("badgeSetNum", null);
      hidemode = paramBundle.getInt("autoCancel");
      data = paramBundle.getString("priority", null);
      ticker = paramBundle.getString("ticker");
      password = paramBundle.getLongArray("vibrateTimings");
      address = paramBundle.getString("visibility", null);
    }
    
    public Integer getBadgeNumber()
    {
      return parse(imageUri);
    }
    
    public String getBody()
    {
      return body;
    }
    
    public String[] getBodyLocalizationArgs()
    {
      String[] arrayOfString = mUnits;
      if (arrayOfString == null) {
        return new String[0];
      }
      return (String[])arrayOfString.clone();
    }
    
    public String getBodyLocalizationKey()
    {
      return condition;
    }
    
    public String getChannelId()
    {
      return mFragment;
    }
    
    public String getClickAction()
    {
      return dataDir;
    }
    
    public String getColor()
    {
      return bgColor;
    }
    
    public String getIcon()
    {
      return mUnitM;
    }
    
    public Uri getImageUrl()
    {
      String str = imageUrl;
      if (str == null) {
        return null;
      }
      return Uri.parse(str);
    }
    
    public Integer getImportance()
    {
      return parse(data);
    }
    
    public String getIntentUri()
    {
      return comment;
    }
    
    public int[] getLightSettings()
    {
      int[] arrayOfInt = mColors;
      if (arrayOfInt == null) {
        return new int[0];
      }
      return (int[])arrayOfInt.clone();
    }
    
    public Uri getLink()
    {
      return link;
    }
    
    public int getNotifyId()
    {
      return portal;
    }
    
    public String getSound()
    {
      return msg;
    }
    
    public String getTag()
    {
      return mTag;
    }
    
    public String getTicker()
    {
      return ticker;
    }
    
    public String getTitle()
    {
      return title;
    }
    
    public String[] getTitleLocalizationArgs()
    {
      String[] arrayOfString = types;
      if (arrayOfString == null) {
        return new String[0];
      }
      return (String[])arrayOfString.clone();
    }
    
    public String getTitleLocalizationKey()
    {
      return type;
    }
    
    public long[] getVibrateConfig()
    {
      long[] arrayOfLong = password;
      if (arrayOfLong == null) {
        return new long[0];
      }
      return (long[])arrayOfLong.clone();
    }
    
    public Integer getVisibility()
    {
      return parse(address);
    }
    
    public Long getWhen()
    {
      String str;
      if (!TextUtils.isEmpty(mTitle)) {
        str = mTitle;
      }
      try
      {
        long l = DateUtil.parseUtcToMillisecond(str);
        return Long.valueOf(l);
      }
      catch (ParseException localParseException)
      {
        for (;;) {}
      }
      catch (StringIndexOutOfBoundsException localStringIndexOutOfBoundsException)
      {
        for (;;) {}
      }
      HMSLog.get("RemoteMessage", "StringIndexOutOfBoundsException: parse when failed.");
      break label46;
      HMSLog.get("RemoteMessage", "ParseException: parse when failed.");
      label46:
      return null;
    }
    
    public boolean isAutoCancel()
    {
      return hidemode == 1;
    }
    
    public boolean isDefaultLight()
    {
      return mMessageType == 1;
    }
    
    public boolean isDefaultSound()
    {
      return mErrorType == 1;
    }
    
    public boolean isDefaultVibrate()
    {
      return mErrorCode == 1;
    }
    
    public boolean isLocalOnly()
    {
      return mMax == 1;
    }
    
    public final Integer parse(String paramString)
    {
      if (paramString != null) {}
      try
      {
        localObject = Integer.valueOf(paramString);
        return localObject;
      }
      catch (NumberFormatException localNumberFormatException)
      {
        Object localObject;
        for (;;) {}
      }
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("NumberFormatException: get ");
      ((StringBuilder)localObject).append(paramString);
      ((StringBuilder)localObject).append(" failed.");
      HMSLog.get("RemoteMessage", ((StringBuilder)localObject).toString());
      return null;
    }
  }
}
