package com.huawei.hms.support.mozilla;

import android.os.Handler;
import android.os.Looper;
import com.huawei.hms.support.api.client.PendingResult;
import com.huawei.hms.support.gentyref.GenericTypeReflector;
import com.huawei.hms.support.model.HMSLog;
import com.huawei.hms.support.mozilla.client.ResultCallback;
import com.huawei.hms.support.mozilla.client.Status;
import java.util.concurrent.TimeUnit;

public abstract class ErrorResultImpl<R extends com.huawei.hms.support.api.client.Result>
  extends PendingResult<R>
{
  private static final String PAGE_KEY = "ErrorResultImpl";
  private R result = null;
  private int statusCode;
  
  public ErrorResultImpl(int paramInt)
  {
    statusCode = paramInt;
  }
  
  private com.huawei.hms.support.mozilla.client.Result newResultInstance(int paramInt)
  {
    Object localObject = com.huawei.hms.support.api.ErrorResultImpl.class.getGenericSuperclass();
    if (localObject != null) {
      localObject = GenericTypeReflector.getType(((java.lang.reflect.ParameterizedType)localObject).getActualTypeArguments()[0]);
    }
    try
    {
      localObject = ((Class)localObject).newInstance();
      result = ((com.huawei.hms.support.mozilla.client.Result)localObject);
      localObject = result;
      ((com.huawei.hms.support.mozilla.client.Result)localObject).setStatus(new Status(paramInt));
    }
    catch (InstantiationException localInstantiationException)
    {
      for (;;) {}
    }
    catch (IllegalAccessException localIllegalAccessException)
    {
      for (;;) {}
    }
    HMSLog.toString("ErrorResultImpl", "IllegalAccessException");
    break label75;
    HMSLog.toString("ErrorResultImpl", "InstantiationException");
    label75:
    return result;
    return null;
  }
  
  public final com.huawei.hms.support.mozilla.client.Result await()
  {
    return await(0L, null);
  }
  
  public com.huawei.hms.support.mozilla.client.Result await(long paramLong, TimeUnit paramTimeUnit)
  {
    if (Looper.myLooper() != Looper.getMainLooper()) {
      return newResultInstance(statusCode);
    }
    throw new IllegalStateException("await must not be called on the UI thread");
  }
  
  public void cancel() {}
  
  public boolean isCanceled()
  {
    return false;
  }
  
  public final void setResultCallback(Looper paramLooper, ResultCallback paramResultCallback)
  {
    Looper localLooper = paramLooper;
    if (paramLooper == null) {
      localLooper = Looper.myLooper();
    }
    new Handler(localLooper).post(new ErrorResultImpl.1(this, paramResultCallback));
  }
  
  public final void setResultCallback(ResultCallback paramResultCallback)
  {
    setResultCallback(Looper.getMainLooper(), paramResultCallback);
  }
  
  public void setResultCallback(ResultCallback paramResultCallback, long paramLong, TimeUnit paramTimeUnit)
  {
    setResultCallback(paramResultCallback);
  }
}
