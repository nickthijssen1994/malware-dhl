package com.huawei.hms.adapter;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Build.VERSION;
import android.os.Looper;
import com.huawei.hms.activity.BridgeActivity;
import com.huawei.hms.adapter.sysobs.SystemManager;
import com.huawei.hms.adapter.sysobs.SystemNotifier;
import com.huawei.hms.adapter.sysobs.SystemObserver;
import com.huawei.hms.adapter.ui.UpdateAdapter;
import com.huawei.hms.support.model.HMSLog;
import com.huawei.hms.utils.Checker;
import com.huawei.hms.utils.HMSPackageManager;
import com.huawei.hms.utils.PackageManagerHelper.PackageStates;
import java.util.concurrent.atomic.AtomicBoolean;

public class AvailableAdapter
{
  public static AtomicBoolean shutdown = new AtomicBoolean(false);
  public static int u = 0;
  public final int deviceId;
  public SystemObserver prefs = new a();
  public AvailableCallBack val;
  
  public AvailableAdapter(int paramInt)
  {
    deviceId = paramInt;
  }
  
  public final AvailableCallBack getValue()
  {
    return val;
  }
  
  public int isHuaweiMobileServicesAvailable(Context paramContext)
  {
    Checker.checkNonNull(paramContext, "context must not be null.");
    if (Build.VERSION.SDK_INT < 16)
    {
      HMSLog.append("AvailableAdapter", "HMS can not be supported under android 4.1");
      return 21;
    }
    paramContext = HMSPackageManager.getInstance(paramContext);
    PackageManagerHelper.PackageStates localPackageStates = paramContext.getHMSPackageStates();
    if (PackageManagerHelper.PackageStates.NOT_INSTALLED.equals(localPackageStates))
    {
      HMSLog.append("AvailableAdapter", "HMS is not installed");
      return 1;
    }
    if (PackageManagerHelper.PackageStates.DISABLED.equals(localPackageStates))
    {
      HMSLog.append("AvailableAdapter", "HMS is disabled");
      return 3;
    }
    if (paramContext.isApkUpdateNecessary(deviceId))
    {
      HMSLog.append("AvailableAdapter", "The current version does not meet the minimum version requirements");
      return 2;
    }
    return 0;
  }
  
  public boolean isUserResolvableError(int paramInt)
  {
    return (paramInt == 1) || (paramInt == 2);
  }
  
  public void startResolution(Activity paramActivity, AvailableCallBack paramAvailableCallBack)
  {
    int j = HMSPackageManager.getInstance(paramActivity).getHmsVersionCode();
    int i = 0;
    boolean bool;
    if (j >= 40000000)
    {
      HMSLog.append("AvailableAdapter", "enter 4.0 HmsCore upgrade process");
      bool = true;
    }
    else
    {
      bool = false;
    }
    if (shutdown.compareAndSet(false, true))
    {
      HMSLog.append("AvailableAdapter", "Start to resolution for the 1st time.");
    }
    else
    {
      if (Looper.getMainLooper() != Looper.myLooper()) {
        break label140;
      }
      HMSLog.append("AvailableAdapter", "main thread invokes resolution.");
    }
    HMSLog.append("AvailableAdapter", "startResolution");
    if (paramActivity != null)
    {
      if (paramAvailableCallBack == null) {
        return;
      }
      val = paramAvailableCallBack;
      SystemManager.getSystemNotifier().registerObserver(prefs);
      paramAvailableCallBack = BridgeActivity.getIntentStartBridgeActivity(paramActivity, UpdateAdapter.class.getName());
      paramAvailableCallBack.putExtra("update_version", deviceId);
      paramAvailableCallBack.putExtra("new_update", bool);
      paramActivity.startActivity(paramAvailableCallBack);
      return;
      label140:
      HMSLog.append("AvailableAdapter", "Another thread start to resolution.");
      while (shutdown.get())
      {
        if (i >= 300)
        {
          HMSLog.append("AvailableAdapter", "Previous popup is not handled by user or download has not finished within 1min.");
          if (paramAvailableCallBack == null) {
            return;
          }
          paramAvailableCallBack.onComplete(27);
          return;
        }
        try
        {
          HMSLog.d("AvailableAdapter", "Concurrent startResolution thread is waiting.");
          Thread.sleep(200L);
          i += 1;
        }
        catch (InterruptedException paramActivity)
        {
          for (;;) {}
        }
        HMSLog.d("AvailableAdapter", "Concurrent startResolution thread waiting is interrupted.");
      }
      HMSLog.append("AvailableAdapter", "Concurrent startResolution thread waiting finished.");
      if (paramAvailableCallBack != null)
      {
        paramAvailableCallBack.onComplete(u);
        return;
      }
    }
  }
  
  public static abstract interface AvailableCallBack
  {
    public abstract void onComplete(int paramInt);
  }
  
  public class a
    implements SystemObserver
  {
    public a() {}
    
    public boolean onSolutionResult(Intent paramIntent, String paramString)
    {
      return false;
    }
    
    public boolean onUpdateResult(int paramInt)
    {
      Object localObject = AvailableAdapter.f(AvailableAdapter.this);
      if (localObject == null)
      {
        HMSLog.toString("AvailableAdapter", "onUpdateResult baseCallBack null");
        return true;
      }
      ((AvailableAdapter.AvailableCallBack)localObject).onComplete(paramInt);
      AvailableAdapter.f(paramInt);
      localObject = new StringBuilder();
      ((StringBuilder)localObject).append("user response ");
      ((StringBuilder)localObject).append(AvailableAdapter.either());
      HMSLog.append("AvailableAdapter", ((StringBuilder)localObject).toString());
      AvailableAdapter.access$getShutdown().set(false);
      return true;
    }
  }
}
