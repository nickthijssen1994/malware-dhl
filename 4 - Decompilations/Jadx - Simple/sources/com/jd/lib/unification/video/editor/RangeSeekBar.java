package com.jd.lib.unification.video.editor;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import androidx.annotation.Nullable;
import com.jd.unalbumwidget.R;
import com.jingdong.common.DpiUtil;
import java.text.DecimalFormat;

/* compiled from: TbsSdkJava */
/* loaded from: classes.dex */
public class RangeSeekBar extends View {
    public static final int ACTION_POINTER_INDEX_MASK = 65280;
    public static final int ACTION_POINTER_INDEX_SHIFT = 8;
    public static final int INVALID_POINTER_ID = 255;
    private static final String TAG = "RangeSeekBar";
    private double absoluteMaxValuePrim;
    private double absoluteMinValuePrim;
    private Context context;
    private boolean isMin;
    private boolean isTouchDown;
    private OnRangeSeekBarChangeListener listener;
    private Bitmap mBitmapBlack;
    private Bitmap mBitmapTrans;
    private float mDownMotionX;
    private boolean mIsDragging;
    private int mScaledTouchSlop;
    private Paint paint;
    private Thumb pressedThumb;
    private Paint rectPaint;
    private Paint textPaint;
    private float thumbHalfWidth;
    private Bitmap thumbImageLeft;
    private Bitmap thumbImageRight;
    private Bitmap thumbPressedImage;
    private int thumbWidth;
    private double normalizedMinValue = 0.0d;
    private double normalizedMaxValue = 1.0d;
    private long minCutTime = 3000;
    private double normalizedMinValueTime = 0.0d;
    private double normalizedMaxValueTime = 1.0d;
    private final float padding = 0.0f;
    private float thumbPaddingTop = 0.0f;
    private float thumbPressPaddingTop = 0.0f;
    private int mActivePointerId = 255;
    private double minWidth = 1.0d;
    private boolean notifyWhileDragging = false;
    private int textHeight = 0;

    /* compiled from: TbsSdkJava */
    /* loaded from: classes.dex */
    public interface OnRangeSeekBarChangeListener {
        void onRangeSeekBarValuesChanged(RangeSeekBar rangeSeekBar, long j, long j2, int i, boolean z, Thumb thumb);
    }

    /* compiled from: TbsSdkJava */
    /* loaded from: classes.dex */
    public enum Thumb {
        MIN,
        MAX
    }

    public RangeSeekBar(Context context) {
        super(context);
    }

    public RangeSeekBar(Context context, @Nullable AttributeSet attributeSet) {
        super(context, attributeSet);
    }

    public RangeSeekBar(Context context, @Nullable AttributeSet attributeSet, int i) {
        super(context, attributeSet, i);
    }

    public RangeSeekBar(Context context, long j, long j2) {
        super(context);
        this.absoluteMinValuePrim = (double) j;
        this.absoluteMaxValuePrim = (double) j2;
        setFocusable(true);
        setFocusableInTouchMode(true);
        init(context);
    }

    private void init(Context context) {
        this.context = context;
        this.mScaledTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();
        this.thumbImageLeft = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_handle);
        int width = this.thumbImageLeft.getWidth();
        Bitmap bitmap = this.thumbImageLeft;
        this.thumbImageRight = bitmap;
        this.thumbPressedImage = bitmap;
        this.thumbWidth = width;
        this.thumbHalfWidth = (float) (this.thumbWidth / 2);
        this.textHeight = DpiUtil.dip2px(context, 15.0f);
        this.mBitmapBlack = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_overlay_black);
        this.mBitmapTrans = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_overlay_trans);
        this.paint = new Paint(1);
        this.rectPaint = new Paint(1);
        this.rectPaint.setStyle(Paint.Style.FILL);
        this.rectPaint.setColor(Color.parseColor("#ffffff"));
        this.textPaint = new Paint();
        this.textPaint.setAntiAlias(true);
        this.textPaint.setStyle(Paint.Style.FILL);
        this.textPaint.setColor(Color.parseColor("#ffffff"));
        this.textPaint.setTextSize((float) DpiUtil.sp2px(context, 12.0f));
    }

    @Override // android.view.View
    protected void onMeasure(int i, int i2) {
        int size = View.MeasureSpec.getMode(i) != 0 ? View.MeasureSpec.getSize(i) : 300;
        int i3 = 120;
        if (View.MeasureSpec.getMode(i2) != 0) {
            i3 = View.MeasureSpec.getSize(i2);
        }
        setMeasuredDimension(size, i3);
    }

    @Override // android.view.View
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        float width = (((float) (getWidth() - getPaddingRight())) - 0.0f) / ((float) this.mBitmapTrans.getWidth());
        float normalizedToScreen = normalizedToScreen(this.normalizedMinValue);
        float normalizedToScreen2 = normalizedToScreen(this.normalizedMaxValue);
        float width2 = (normalizedToScreen2 - normalizedToScreen) / ((float) this.mBitmapTrans.getWidth());
        if (width2 > 0.0f) {
            try {
                Matrix matrix = new Matrix();
                matrix.postScale(width2, 1.0f);
                canvas.drawBitmap(Bitmap.createBitmap(this.mBitmapTrans, 0, 0, this.mBitmapTrans.getWidth(), this.mBitmapTrans.getHeight(), matrix, true), normalizedToScreen, this.thumbPaddingTop + ((float) this.textHeight), this.paint);
                Matrix matrix2 = new Matrix();
                matrix2.postScale(width, 1.0f);
                Bitmap createBitmap = Bitmap.createBitmap(this.mBitmapBlack, 0, 0, this.mBitmapBlack.getWidth(), this.mBitmapBlack.getHeight(), matrix2, true);
                canvas.drawBitmap(Bitmap.createBitmap(createBitmap, 0, 0, ((int) (normalizedToScreen - 0.0f)) + (this.thumbWidth / 2), this.mBitmapBlack.getHeight()), 0.0f, this.thumbPaddingTop + ((float) this.textHeight), this.paint);
                int i = (int) (normalizedToScreen2 - ((float) (this.thumbWidth / 2)));
                double width3 = (double) (((float) getWidth()) - normalizedToScreen2);
                Double.isNaN(width3);
                canvas.drawBitmap(Bitmap.createBitmap(createBitmap, i, 0, ((int) (width3 + 0.9999d)) + (this.thumbWidth / 2), this.mBitmapBlack.getHeight()), (float) ((int) (normalizedToScreen2 - ((float) (this.thumbWidth / 2)))), this.thumbPaddingTop + ((float) this.textHeight), this.paint);
                canvas.drawRect(normalizedToScreen, this.thumbPaddingTop + ((float) this.textHeight), normalizedToScreen2, this.thumbPaddingTop + ((float) this.textHeight) + ((float) DpiUtil.dip2px(this.context, 3.0f)), this.rectPaint);
                canvas.drawRect(normalizedToScreen, (float) (getHeight() - DpiUtil.dip2px(this.context, 3.0f)), normalizedToScreen2, (float) getHeight(), this.rectPaint);
                drawThumb(normalizedToScreen(this.normalizedMinValue), false, canvas, true);
                drawThumb(normalizedToScreen(this.normalizedMaxValue), false, canvas, false);
                canvas.drawText(((getSelectedMaxValue() - getSelectedMinValue()) / 1000) + "s", (normalizedToScreen(this.normalizedMaxValue) - ((float) this.thumbWidth)) - ((float) DpiUtil.dip2px(this.context, 15.0f)), (this.thumbPaddingTop + ((float) this.textHeight)) - ((float) DpiUtil.dip2px(this.context, 3.0f)), this.textPaint);
            } catch (Exception unused) {
            }
        }
    }

    private void drawThumb(float f, boolean z, Canvas canvas, boolean z2) {
        canvas.drawBitmap(z ? this.thumbPressedImage : z2 ? this.thumbImageLeft : this.thumbImageRight, f - ((float) (z2 ? 0 : this.thumbWidth)), z ? this.thumbPressPaddingTop : this.thumbPaddingTop + ((float) this.textHeight), this.paint);
    }

    @Override // android.view.View
    public boolean onTouchEvent(MotionEvent motionEvent) {
        OnRangeSeekBarChangeListener onRangeSeekBarChangeListener;
        if (this.isTouchDown) {
            return super.onTouchEvent(motionEvent);
        }
        if (motionEvent.getPointerCount() > 1) {
            return super.onTouchEvent(motionEvent);
        }
        if (!isEnabled()) {
            return false;
        }
        if (this.absoluteMaxValuePrim <= ((double) this.minCutTime)) {
            return super.onTouchEvent(motionEvent);
        }
        switch (motionEvent.getAction() & 255) {
            case 0:
                this.rectPaint.setColor(Color.parseColor("#F23030"));
                this.thumbImageLeft = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_handle_red);
                this.thumbImageRight = this.thumbImageLeft;
                this.mActivePointerId = motionEvent.getPointerId(motionEvent.getPointerCount() - 1);
                this.mDownMotionX = motionEvent.getX(motionEvent.findPointerIndex(this.mActivePointerId));
                this.pressedThumb = evalPressedThumb(this.mDownMotionX);
                if (this.pressedThumb != null) {
                    setPressed(true);
                    onStartTrackingTouch();
                    trackTouchEvent(motionEvent);
                    attemptClaimDrag();
                    OnRangeSeekBarChangeListener onRangeSeekBarChangeListener2 = this.listener;
                    if (onRangeSeekBarChangeListener2 != null) {
                        onRangeSeekBarChangeListener2.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue(), 0, this.isMin, this.pressedThumb);
                        break;
                    }
                } else {
                    return super.onTouchEvent(motionEvent);
                }
                break;
            case 1:
                this.rectPaint.setColor(Color.parseColor("#FFFFFF"));
                this.thumbImageLeft = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_handle);
                this.thumbImageRight = this.thumbImageLeft;
                if (this.mIsDragging) {
                    trackTouchEvent(motionEvent);
                    onStopTrackingTouch();
                    setPressed(false);
                } else {
                    onStartTrackingTouch();
                    trackTouchEvent(motionEvent);
                    onStopTrackingTouch();
                }
                invalidate();
                OnRangeSeekBarChangeListener onRangeSeekBarChangeListener3 = this.listener;
                if (onRangeSeekBarChangeListener3 != null) {
                    onRangeSeekBarChangeListener3.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue(), 1, this.isMin, this.pressedThumb);
                }
                this.pressedThumb = null;
                break;
            case 2:
                if (this.pressedThumb != null) {
                    if (this.mIsDragging) {
                        trackTouchEvent(motionEvent);
                    } else if (Math.abs(motionEvent.getX(motionEvent.findPointerIndex(this.mActivePointerId)) - this.mDownMotionX) > ((float) this.mScaledTouchSlop)) {
                        setPressed(true);
                        invalidate();
                        onStartTrackingTouch();
                        trackTouchEvent(motionEvent);
                        attemptClaimDrag();
                    }
                    if (this.notifyWhileDragging && (onRangeSeekBarChangeListener = this.listener) != null) {
                        onRangeSeekBarChangeListener.onRangeSeekBarValuesChanged(this, getSelectedMinValue(), getSelectedMaxValue(), 2, this.isMin, this.pressedThumb);
                        break;
                    }
                }
                break;
            case 3:
                if (this.mIsDragging) {
                    onStopTrackingTouch();
                    setPressed(false);
                }
                invalidate();
                break;
            case 5:
                this.rectPaint.setColor(Color.parseColor("#F23030"));
                this.thumbImageLeft = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_handle_red);
                this.thumbImageRight = this.thumbImageLeft;
                int pointerCount = motionEvent.getPointerCount() - 1;
                this.mDownMotionX = motionEvent.getX(pointerCount);
                this.mActivePointerId = motionEvent.getPointerId(pointerCount);
                invalidate();
                break;
            case 6:
                this.rectPaint.setColor(Color.parseColor("#FFFFFF"));
                this.thumbImageLeft = BitmapFactory.decodeResource(getResources(), R.drawable.lib_uni_video_editor_handle);
                this.thumbImageRight = this.thumbImageLeft;
                onSecondaryPointerUp(motionEvent);
                invalidate();
                break;
        }
        return true;
    }

    private void onSecondaryPointerUp(MotionEvent motionEvent) {
        int action = (motionEvent.getAction() & ACTION_POINTER_INDEX_MASK) >> 8;
        if (motionEvent.getPointerId(action) == this.mActivePointerId) {
            int i = action == 0 ? 1 : 0;
            this.mDownMotionX = motionEvent.getX(i);
            this.mActivePointerId = motionEvent.getPointerId(i);
        }
    }

    private void trackTouchEvent(MotionEvent motionEvent) {
        if (motionEvent.getPointerCount() <= 1) {
            try {
                float x = motionEvent.getX(motionEvent.findPointerIndex(this.mActivePointerId));
                if (Thumb.MIN.equals(this.pressedThumb)) {
                    setNormalizedMinValue(screenToNormalized(x, 0));
                } else if (Thumb.MAX.equals(this.pressedThumb)) {
                    setNormalizedMaxValue(screenToNormalized(x, 1));
                }
            } catch (Exception unused) {
            }
        }
    }

    private double screenToNormalized(float f, int i) {
        double d;
        double d2;
        double d3;
        int width = getWidth();
        float f2 = (float) width;
        if (f2 <= 0.0f) {
            return 0.0d;
        }
        this.isMin = false;
        double d4 = (double) f;
        float normalizedToScreen = normalizedToScreen(this.normalizedMinValue);
        float normalizedToScreen2 = normalizedToScreen(this.normalizedMaxValue);
        double d5 = (double) this.minCutTime;
        double d6 = this.absoluteMaxValuePrim;
        Double.isNaN(d5);
        double d7 = d5 / (d6 - this.absoluteMinValuePrim);
        double d8 = (double) (width - (this.thumbWidth * 2));
        Double.isNaN(d8);
        double d9 = d7 * d8;
        if (d6 > 300000.0d) {
            this.minWidth = Double.parseDouble(new DecimalFormat("0.0000").format(d9));
        } else {
            this.minWidth = (double) Math.round(d9 + 0.5d);
        }
        if (i == 0) {
            if (isInThumbRangeLeft(f, this.normalizedMinValue, 0.5d)) {
                return this.normalizedMinValue;
            }
            float width2 = ((float) getWidth()) - normalizedToScreen2 >= 0.0f ? ((float) getWidth()) - normalizedToScreen2 : 0.0f;
            double valueLength = (double) getValueLength();
            double d10 = (double) width2;
            double d11 = this.minWidth;
            Double.isNaN(d10);
            Double.isNaN(valueLength);
            double d12 = valueLength - (d10 + d11);
            double d13 = (double) normalizedToScreen;
            if (d4 > d13) {
                Double.isNaN(d4);
                Double.isNaN(d13);
                Double.isNaN(d13);
                d4 = (d4 - d13) + d13;
            } else if (d4 <= d13) {
                Double.isNaN(d13);
                Double.isNaN(d4);
                Double.isNaN(d13);
                d4 = d13 - (d13 - d4);
            }
            if (d4 > d12) {
                this.isMin = true;
            } else {
                d12 = d4;
            }
            if (d12 < ((double) ((this.thumbWidth * 2) / 3))) {
                d3 = 0.0d;
                d2 = 0.0d;
            } else {
                d2 = d12;
                d3 = 0.0d;
            }
            double d14 = d2 - d3;
            double d15 = (double) (width - (this.thumbWidth * 2));
            Double.isNaN(d15);
            this.normalizedMinValueTime = Math.min(1.0d, Math.max(d3, d14 / d15));
            double d16 = (double) (f2 - 0.0f);
            Double.isNaN(d16);
            return Math.min(1.0d, Math.max(d3, d14 / d16));
        } else if (isInThumbRange(f, this.normalizedMaxValue, 0.5d)) {
            return this.normalizedMaxValue;
        } else {
            double valueLength2 = (double) getValueLength();
            double d17 = (double) normalizedToScreen;
            double d18 = this.minWidth;
            Double.isNaN(d17);
            Double.isNaN(valueLength2);
            double d19 = valueLength2 - (d17 + d18);
            double d20 = (double) normalizedToScreen2;
            if (d4 > d20) {
                Double.isNaN(d4);
                Double.isNaN(d20);
                Double.isNaN(d20);
                d4 = (d4 - d20) + d20;
            } else if (d4 <= d20) {
                Double.isNaN(d20);
                Double.isNaN(d4);
                Double.isNaN(d20);
                d4 = d20 - (d20 - d4);
            }
            double width3 = (double) getWidth();
            Double.isNaN(width3);
            double d21 = width3 - d4;
            if (d21 > d19) {
                this.isMin = true;
                double width4 = (double) getWidth();
                Double.isNaN(width4);
                d4 = width4 - d19;
            } else {
                d19 = d21;
            }
            if (d19 < ((double) ((this.thumbWidth * 2) / 3))) {
                d4 = (double) getWidth();
                d19 = 0.0d;
                d = 0.0d;
            } else {
                d = 0.0d;
            }
            double d22 = (double) (width - (this.thumbWidth * 2));
            Double.isNaN(d22);
            this.normalizedMaxValueTime = Math.min(1.0d, Math.max(d, 1.0d - ((d19 - d) / d22)));
            double d23 = (double) (f2 - 0.0f);
            Double.isNaN(d23);
            return Math.min(1.0d, Math.max(d, (d4 - d) / d23));
        }
    }

    private int getValueLength() {
        return getWidth() - (this.thumbWidth * 2);
    }

    private Thumb evalPressedThumb(float f) {
        boolean isInThumbRange = isInThumbRange(f, this.normalizedMinValue, (double) DpiUtil.dip2px(this.context, 3.0f));
        boolean isInThumbRange2 = isInThumbRange(f, this.normalizedMaxValue, (double) DpiUtil.dip2px(this.context, 3.0f));
        if (isInThumbRange && isInThumbRange2) {
            return f / ((float) getWidth()) > 0.5f ? Thumb.MIN : Thumb.MAX;
        }
        if (isInThumbRange) {
            return Thumb.MIN;
        }
        if (isInThumbRange2) {
            return Thumb.MAX;
        }
        return null;
    }

    private boolean isInThumbRange(float f, double d, double d2) {
        double d3 = (double) this.thumbHalfWidth;
        Double.isNaN(d3);
        return ((double) Math.abs(f - normalizedToScreen(d))) <= d3 * d2;
    }

    private boolean isInThumbRangeLeft(float f, double d, double d2) {
        double d3 = (double) this.thumbHalfWidth;
        Double.isNaN(d3);
        return ((double) Math.abs((f - normalizedToScreen(d)) - ((float) this.thumbWidth))) <= d3 * d2;
    }

    private void attemptClaimDrag() {
        if (getParent() != null) {
            getParent().requestDisallowInterceptTouchEvent(true);
        }
    }

    void onStartTrackingTouch() {
        this.mIsDragging = true;
    }

    void onStopTrackingTouch() {
        this.mIsDragging = false;
    }

    public void setMinCutTime(long j) {
        this.minCutTime = j;
    }

    private float normalizedToScreen(double d) {
        double paddingLeft = (double) getPaddingLeft();
        double width = (double) ((getWidth() - getPaddingLeft()) - getPaddingRight());
        Double.isNaN(width);
        Double.isNaN(paddingLeft);
        return (float) (paddingLeft + (d * width));
    }

    private double valueToNormalized(long j) {
        double d = this.absoluteMaxValuePrim;
        double d2 = this.absoluteMinValuePrim;
        if (0.0d == d - d2) {
            return 0.0d;
        }
        double d3 = (double) j;
        Double.isNaN(d3);
        return (d3 - d2) / (d - d2);
    }

    public void setSelectedMinValue(long j) {
        if (0.0d == this.absoluteMaxValuePrim - this.absoluteMinValuePrim) {
            setNormalizedMinValue(0.0d);
        } else {
            setNormalizedMinValue(valueToNormalized(j));
        }
    }

    public void setSelectedMaxValue(long j) {
        if (0.0d == this.absoluteMaxValuePrim - this.absoluteMinValuePrim) {
            setNormalizedMaxValue(1.0d);
        } else {
            setNormalizedMaxValue(valueToNormalized(j));
        }
    }

    public void setNormalizedMinValue(double d) {
        this.normalizedMinValue = Math.max(0.0d, Math.min(1.0d, Math.min(d, this.normalizedMaxValue)));
        invalidate();
    }

    public void setNormalizedMaxValue(double d) {
        this.normalizedMaxValue = Math.max(0.0d, Math.min(1.0d, Math.max(d, this.normalizedMinValue)));
        invalidate();
    }

    public long getSelectedMinValue() {
        return normalizedToValue(this.normalizedMinValueTime);
    }

    public long getSelectedMaxValue() {
        return normalizedToValue(this.normalizedMaxValueTime);
    }

    private long normalizedToValue(double d) {
        double d2 = this.absoluteMinValuePrim;
        return (long) (d2 + (d * (this.absoluteMaxValuePrim - d2)));
    }

    public boolean isNotifyWhileDragging() {
        return this.notifyWhileDragging;
    }

    public void setNotifyWhileDragging(boolean z) {
        this.notifyWhileDragging = z;
    }

    public void setTouchDown(boolean z) {
        this.isTouchDown = z;
    }

    @Override // android.view.View
    protected Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable("SUPER", super.onSaveInstanceState());
        bundle.putDouble("MIN", this.normalizedMinValue);
        bundle.putDouble("MAX", this.normalizedMaxValue);
        bundle.putDouble("MIN_TIME", this.normalizedMinValueTime);
        bundle.putDouble("MAX_TIME", this.normalizedMaxValueTime);
        return bundle;
    }

    @Override // android.view.View
    protected void onRestoreInstanceState(Parcelable parcelable) {
        Bundle bundle = (Bundle) parcelable;
        super.onRestoreInstanceState(bundle.getParcelable("SUPER"));
        this.normalizedMinValue = bundle.getDouble("MIN");
        this.normalizedMaxValue = bundle.getDouble("MAX");
        this.normalizedMinValueTime = bundle.getDouble("MIN_TIME");
        this.normalizedMaxValueTime = bundle.getDouble("MAX_TIME");
    }

    public void setOnRangeSeekBarChangeListener(OnRangeSeekBarChangeListener onRangeSeekBarChangeListener) {
        this.listener = onRangeSeekBarChangeListener;
    }
}
